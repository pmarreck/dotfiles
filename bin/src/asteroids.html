<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }

        canvas {
            border: 1px solid #fff;
            background-color: #111;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: var(--game-width, 800px);
            margin-bottom: 10px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            display: none;
            color: white;
        }

        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        /* Test output styles */
        .test-output {
            font-family: monospace;
            background: white;
            color: black;
            padding: 20px;
            margin: 20px;
            border: 1px solid #ccc;
            max-height: 80vh;
            overflow-y: auto;
        }

        .test-suite {
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        .test-case {
            margin-left: 20px;
            margin-bottom: 2px;
        }

        .test-pass {
            color: #22c55e;
            font-weight: bold;
        }

        .test-fail {
            color: #ef4444;
            font-weight: bold;
        }

        .test-fail-message {
            color: #ef4444;
        }

        .test-completion {
            color: #22c55e;
            font-weight: bold;
            margin-top: 15px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-info">
        <div>Score: <span id="scoreValue">0</span></div>
        <div>Lives: <span id="livesValue">3</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="gameOverScreen" class="game-over">
        <h2>Game Over</h2>
        <p>Your score: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <div id="pauseScreen" class="game-over" style="display: none;">
        <h2>Paused</h2>
        <p>Press ESC again to resume</p>
        <div style="margin-top: 20px; text-align: left; font-size: 14px;">
            <h3>Controls:</h3>
            <p>← → : Rotate ship</p>
            <p>↑ : Thrust</p>
            <p>Space : Fire bullets</p>
            <p>ESC : Pause/Resume</p>
            <p>shift-T : Test mode (press browser Back button to return to game)</p>
            <p>shift-K : Toggle "kid mode" (infinite lives, no scoring)</p>
        </div>
    </div>


    <script>
        // Check if we're in test mode (browser) or Node.js environment
        const isNodeJS = typeof window === 'undefined';
        const urlParams = isNodeJS ? { has: () => true } : new URLSearchParams(window.location.search);
        const isTestMode = isNodeJS || urlParams.has('test');

        // Add test mode toggle with capital T
        let testModeTriggered = false;

        // Node.js compatibility shims
        if (isNodeJS) {
            global.document = {
                getElementById: () => ({
                    style: {
                        setProperty: () => {},
                        display: ''
                    },
                    textContent: ''
                }),
                querySelector: () => ({ style: {} }),
                createElement: () => ({ id: '', appendChild: () => {} }),
                body: {
                    appendChild: () => {},
                    style: {}
                }
            };
            global.window = {
                ...global,
                addEventListener: () => {},
                AudioContext: null,
                webkitAudioContext: null,
                location: { search: '?test' }
            };
            global.requestAnimationFrame = () => {};
        }

        // Sound Interface Classes
        class RealSoundInterface {
            constructor() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    // AudioContext not available (e.g., in Node.js or some browsers)
                    this.audioContext = null;
                }
            }

            playShoot() {
                if (!this.audioContext) return;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            playThrust() {
                if (!this.audioContext) return;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();

                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(60, this.audioContext.currentTime);

                filterNode.type = 'lowpass';
                filterNode.frequency.setValueAtTime(200, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.05);
            }

            playAsteroidExplosion() {
                if (!this.audioContext) return;
                const bufferSize = this.audioContext.sampleRate * 0.5;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.08));
                }

                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();
                const bassBoost = this.audioContext.createBiquadFilter();

                source.buffer = buffer;
                source.connect(bassBoost);
                bassBoost.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Add bass boost for more punch
                bassBoost.type = 'peaking';
                bassBoost.frequency.setValueAtTime(120, this.audioContext.currentTime);
                bassBoost.Q.setValueAtTime(2, this.audioContext.currentTime);
                bassBoost.gain.setValueAtTime(8, this.audioContext.currentTime);

                filterNode.type = 'lowpass';
                filterNode.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                filterNode.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.5);

                gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);

                source.start(this.audioContext.currentTime);
            }

            playShipExplosion() {
                if (!this.audioContext) return;

                const ctx = this.audioContext;
                const duration = 1.2;
                const bufferSize = ctx.sampleRate * duration;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Fill buffer with layered noise: white + brownish
                let lastOut = 0.0;
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    const decay = Math.exp(-5 * t);
                    const white = (Math.random() * 2 - 1);
                    lastOut = (lastOut + (0.02 * white)) / 1.02; // Brownian-ish
                    const noise = (0.6 * white + 0.4 * lastOut) * decay;

                    // Add subtle transient impulse at start
                    const impulse = i < 200 ? Math.sin(i * 0.2) * (1 - i / 200) : 0;

                    data[i] = noise + impulse;
                }

                const source = ctx.createBufferSource();
                source.buffer = buffer;

                const bandpass = ctx.createBiquadFilter();
                bandpass.type = "bandpass";
                bandpass.frequency.setValueAtTime(300, ctx.currentTime);
                bandpass.Q.value = 0.8;

                const lowpass = ctx.createBiquadFilter();
                lowpass.type = "lowpass";
                lowpass.frequency.setValueAtTime(3000, ctx.currentTime);
                lowpass.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + duration);

                const gain = ctx.createGain();
                gain.gain.setValueAtTime(1.0, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

                // Connect nodes
                source.connect(bandpass);
                bandpass.connect(lowpass);
                lowpass.connect(gain);
                gain.connect(ctx.destination);

                source.start();
            }


            // Legacy method for backward compatibility - calls asteroid explosion
            playExplosion() {
                this.playAsteroidExplosion();
            }
        }

        class MockSoundInterface {
            constructor() {
                this.calls = [];
            }

            playShoot() {
                this.calls.push({ method: 'playShoot', timestamp: Date.now() });
            }

            playThrust() {
                this.calls.push({ method: 'playThrust', timestamp: Date.now() });
            }

            playAsteroidExplosion() {
                this.calls.push({ method: 'playAsteroidExplosion', timestamp: Date.now() });
            }

            playShipExplosion() {
                this.calls.push({ method: 'playShipExplosion', timestamp: Date.now() });
            }

            playExplosion() {
                this.playAsteroidExplosion();
            }

            // Test helper methods
            getCalls() {
                return this.calls;
            }

            getCallsOfType(method) {
                return this.calls.filter(call => call.method === method);
            }

            wasMethodCalled(method) {
                return this.calls.some(call => call.method === method);
            }

            getCallCount(method) {
                return this.calls.filter(call => call.method === method).length;
            }

            reset() {
                this.calls = [];
            }
        }

        // Game configuration constants
        const GAME_WIDTH = 1024;
        const GAME_HEIGHT = 768;

        // Game state structure
        const GameState = {
            ship: {
                x: GAME_WIDTH / 2,
                y: GAME_HEIGHT / 2,
                vx: 0,
                vy: 0,
                angle: -Math.PI / 2, // Start pointing up
                radius: 10,
                thrusting: false
            },

            asteroids: [],
            bullets: [],
            particles: [],
            shipDebris: [],

            score: 0,
            lives: 3,
            gameOver: false,
            paused: false,
            shipExploding: false,
            shipExplosionStartTime: 0,
            lastFireTime: 0,
            kidMode: false,

            // Game constants
            SHIP_ACCELERATION: 300,
            ROTATION_SPEED: 5, // radians per second
            BULLET_SPEED: 500,
            MAX_BULLETS: 4,
            ASTEROID_SPAWN_COUNT: 5,

            // Sound system (will be injected based on test/production mode)
            sound: null
        };

        // Input handler
        const keysPressed = {};

        window.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;

            // Handle pause toggle
            if (e.key === 'Escape') {
                GameState.paused = !GameState.paused;
                e.preventDefault();
            }

            // Handle test mode toggle with capital T
            if (e.key === 'T' && !testModeTriggered && !isNodeJS) {
                testModeTriggered = true;
                e.preventDefault();
                // Reload page with test parameter
                window.location.href = window.location.pathname + '?test';
                return;
            }

            // Handle kid mode toggle with capital K
            if (e.key === 'K') {
                GameState.kidMode = !GameState.kidMode;
                e.preventDefault();
            }

            // Prevent arrow key scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        // Renderer
        function render(state) {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions if not already set
            if (canvas.width !== GAME_WIDTH || canvas.height !== GAME_HEIGHT) {
                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;
                // Update CSS variable for game info width
                document.documentElement.style.setProperty('--game-width', GAME_WIDTH + 'px');
            }

            // Clear canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars background
            ctx.fillStyle = '#fff';
            if (!state.stars) {
                state.stars = [];
                for (let i = 0; i < 100; i++) {
                    state.stars.push({
                        x: Math.floor(Math.random() * GAME_WIDTH),
                        y: Math.floor(Math.random() * GAME_HEIGHT)
                    });
                }
            }
            state.stars.forEach(star => {
                ctx.fillRect(star.x, star.y, 1, 1);
            });

            // Draw ship (unless exploding or game over)
            if (!state.shipExploding && !state.gameOver) {
                drawShip(ctx, state.ship);
            }

            // Draw bullets
            ctx.fillStyle = '#0f0';
            state.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw asteroids
            state.asteroids.forEach(asteroid => {
                drawAsteroid(ctx, asteroid);
            });

            // Draw particles
            state.particles.forEach(particle => {
                ctx.fillStyle = `rgba(255, ${150 - particle.life}, 0, ${particle.life / 40})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw ship debris
            state.shipDebris.forEach(debris => {
                drawShipDebris(ctx, debris);
            });

            // Update UI (hide score and lives in kid mode)
            const scoreElement = document.getElementById('scoreValue');
            const livesElement = document.getElementById('livesValue');
            const gameInfoElement = document.querySelector('.game-info');

            if (state.kidMode) {
                gameInfoElement.style.visibility = 'hidden';
            } else {
                gameInfoElement.style.visibility = 'visible';
                scoreElement.textContent = state.score;
                livesElement.textContent = state.lives;
            }

            // Show/hide pause screen
            document.getElementById('pauseScreen').style.display = state.paused ? 'block' : 'none';
        }

        function drawShip(ctx, ship) {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);

            // Draw ship
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();

            // Ship body
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, -8);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.stroke();

            // Thrust flame
            if (ship.thrusting) {
                ctx.strokeStyle = '#ff8800'; // Orange color
                ctx.beginPath();
                ctx.moveTo(-5, -3);
                ctx.lineTo(-15 * Math.random() - 10, 0);
                ctx.lineTo(-5, 3);
                ctx.stroke();
                ctx.strokeStyle = '#fff'; // Reset to white for ship outline
            }

            // Ship center
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawAsteroid(ctx, asteroid) {
            ctx.save();
            ctx.translate(asteroid.x, asteroid.y);
            ctx.rotate(asteroid.angle);

            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const points = asteroid.points;
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                if (i === 0) {
                    ctx.moveTo(p[0], p[1]);
                } else {
                    ctx.lineTo(p[0], p[1]);
                }
            }

            ctx.closePath();
            ctx.stroke();

            // Draw some detail lines
            for (let i = 0; i < asteroid.points.length - 2; i += 3) {
                const p1 = asteroid.points[i];
                const p2 = asteroid.points[(i + 3) % asteroid.points.length];

                ctx.beginPath();
                ctx.moveTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawShipDebris(ctx, debris) {
            ctx.save();
            ctx.translate(debris.x, debris.y);
            ctx.rotate(debris.angle);

            // Fade out as life decreases
            const alpha = Math.max(0, debris.life / 120);
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();

            const points = debris.points;
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                if (i === 0) {
                    ctx.moveTo(p[0], p[1]);
                } else {
                    ctx.lineTo(p[0], p[1]);
                }
            }

            ctx.closePath();
            ctx.stroke();

            ctx.restore();
        }

        // Game state update function
        function updateGameState(state, keysPressed, deltaTime, currentTime) {
            if (state.gameOver || state.paused) return state;

            // Deep copy of state to avoid mutation (excluding non-serializable properties)
            const newState = {
                ship: { ...state.ship },
                asteroids: state.asteroids.map(a => ({ ...a, points: [...a.points] })),
                bullets: state.bullets.map(b => ({ ...b })),
                particles: state.particles.map(p => ({ ...p })),
                shipDebris: state.shipDebris.map(d => ({ ...d, points: [...d.points] })),
                score: state.score,
                lives: state.lives,
                gameOver: state.gameOver,
                paused: state.paused,
                shipExploding: state.shipExploding,
                shipExplosionStartTime: state.shipExplosionStartTime,
                lastFireTime: state.lastFireTime,
                kidMode: state.kidMode,
                stars: state.stars,
                sound: state.sound // Pass through the sound interface
            };

            // Check if ship explosion should end
            if (newState.shipExploding && (currentTime - newState.shipExplosionStartTime) > 2000) {
                // End explosion
                newState.shipExploding = false;
                newState.shipDebris = [];

                // Check if game should end (no lives left)
                if (newState.lives <= 0) {
                    newState.gameOver = true;
                    if (typeof document !== 'undefined') {
                        document.getElementById('finalScore').textContent = newState.score;
                        document.getElementById('gameOverScreen').style.display = 'block';
                    }
                } else {
                    // Respawn ship
                    newState.ship.x = GAME_WIDTH / 2;
                    newState.ship.y = GAME_HEIGHT / 2;
                    newState.ship.vx = 0;
                    newState.ship.vy = 0;
                    newState.ship.angle = -Math.PI / 2;
                }
            }

            // Update ship based on input (only if not exploding)
            if (!newState.shipExploding) {
                if (keysPressed['ArrowLeft']) {
                    newState.ship.angle -= state.ROTATION_SPEED * deltaTime;
                }

                if (keysPressed['ArrowRight']) {
                    newState.ship.angle += state.ROTATION_SPEED * deltaTime;
                }

                if (keysPressed['ArrowUp']) {
                    newState.ship.thrusting = true;

                    // Apply thrust in direction ship is pointing
                    const acceleration = state.SHIP_ACCELERATION * deltaTime;
                    newState.ship.vx += Math.cos(newState.ship.angle) * acceleration;
                    newState.ship.vy += Math.sin(newState.ship.angle) * acceleration;

                    // Play thrust sound occasionally to avoid spam
                    if (Math.random() < 0.1) {
                        newState.sound.playThrust();
                    }
                } else {
                    newState.ship.thrusting = false;
                }

                // Update ship position
                newState.ship.x += newState.ship.vx * deltaTime;
                newState.ship.y += newState.ship.vy * deltaTime;

                // Screen wrapping
                if (newState.ship.x < 0) newState.ship.x = GAME_WIDTH;
                else if (newState.ship.x > GAME_WIDTH) newState.ship.x = 0;

                if (newState.ship.y < 0) newState.ship.y = GAME_HEIGHT;
                else if (newState.ship.y > GAME_HEIGHT) newState.ship.y = 0;

                // Fire bullets (with rate limiting)
                const fireDelay = 200; // milliseconds between shots

                if (keysPressed[' '] && newState.bullets.length < state.MAX_BULLETS &&
                    (currentTime - state.lastFireTime) > fireDelay) {
                    const bullet = {
                        x: newState.ship.x + Math.cos(newState.ship.angle) * 20,
                        y: newState.ship.y + Math.sin(newState.ship.angle) * 20,
                        vx: newState.ship.vx + Math.cos(newState.ship.angle) * state.BULLET_SPEED,
                        vy: newState.ship.vy + Math.sin(newState.ship.angle) * state.BULLET_SPEED,
                        distanceTraveled: 0
                    };

                    newState.bullets.push(bullet);
                    newState.lastFireTime = currentTime;
                    newState.sound.playShoot();
                }
            }

            // Update bullets
            newState.bullets = newState.bullets.filter(bullet => {
                const oldX = bullet.x;
                const oldY = bullet.y;

                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;

                // Track distance traveled
                const dx = bullet.x - oldX;
                const dy = bullet.y - oldY;
                bullet.distanceTraveled += Math.sqrt(dx * dx + dy * dy);

                // Screen wrapping for bullets
                if (bullet.x < 0) bullet.x = GAME_WIDTH;
                else if (bullet.x > GAME_WIDTH) bullet.x = 0;

                if (bullet.y < 0) bullet.y = GAME_HEIGHT;
                else if (bullet.y > GAME_HEIGHT) bullet.y = 0;

                // Remove bullet if it has traveled more than half a screen diagonal
                const maxDistance = Math.sqrt(GAME_WIDTH * GAME_WIDTH + GAME_HEIGHT * GAME_HEIGHT) / 2;
                return bullet.distanceTraveled < maxDistance;
            });

            // Update particles
            newState.particles = newState.particles.filter(particle => {
                particle.x += particle.vx * deltaTime;
                particle.y += particle.vy * deltaTime;

                // Apply gravity to particles
                particle.vx *= 0.98;
                particle.vy *= 0.98;

                return --particle.life > 0;
            });

            // Update ship debris
            newState.shipDebris = newState.shipDebris.filter(debris => {
                debris.x += debris.vx * deltaTime;
                debris.y += debris.vy * deltaTime;
                debris.angle += debris.angularVelocity * deltaTime;

                // Apply drag
                debris.vx *= 0.99;
                debris.vy *= 0.99;
                debris.angularVelocity *= 0.98;

                // Screen wrapping for debris
                if (debris.x < -50) debris.x = GAME_WIDTH + 50;
                else if (debris.x > GAME_WIDTH + 50) debris.x = -50;
                if (debris.y < -50) debris.y = GAME_HEIGHT + 50;
                else if (debris.y > GAME_HEIGHT + 50) debris.y = -50;

                return --debris.life > 0;
            });

            // Update asteroids
            newState.asteroids.forEach(asteroid => {
                asteroid.x += asteroid.vx * deltaTime;
                asteroid.y += asteroid.vy * deltaTime;
                asteroid.angle += asteroid.angularVelocity * deltaTime;

                // Screen wrapping
                if (asteroid.x < -50) asteroid.x = GAME_WIDTH + 50;
                else if (asteroid.x > GAME_WIDTH + 50) asteroid.x = -50;

                if (asteroid.y < -50) asteroid.y = GAME_HEIGHT + 50;
                else if (asteroid.y > GAME_HEIGHT + 50) asteroid.y = -50;
            });

            // Check bullet-asteroid collisions
            for (let i = newState.bullets.length - 1; i >= 0; i--) {
                const bullet = newState.bullets[i];

                for (let j = newState.asteroids.length - 1; j >= 0; j--) {
                    const asteroid = newState.asteroids[j];

                    if (distance(bullet, asteroid) < asteroid.radius + 5) {
                        // Handle asteroid collision (explosion, splitting, etc.)
                        const collisionResult = handleAsteroidCollision(newState, asteroid);
                        newState.sound.playExplosion();

                        // Remove bullet
                        newState.bullets.splice(i, 1);

                        // Add any new asteroids from splitting
                        newState.asteroids.push(...collisionResult.newAsteroids);

                        // Remove the original asteroid
                        if (collisionResult.shouldRemove) {
                            newState.asteroids.splice(j, 1);
                        }

                        // Update score (only if not in kid mode)
                        if (!newState.kidMode) {
                            newState.score += 100;
                        }

                        break;
                    }
                }
            }

            // Check ship-asteroid collisions (only if ship is not already exploding)
            if (!newState.shipExploding) {
                for (let i = newState.asteroids.length - 1; i >= 0; i--) {
                    const asteroid = newState.asteroids[i];
                    if (distance(newState.ship, asteroid) < newState.ship.radius + asteroid.radius) {
                        // Start ship explosion
                        newState.shipExploding = true;
                        newState.shipExplosionStartTime = currentTime;

                        // Create ship debris and explosion particles
                        createShipDebris(newState, newState.ship.x, newState.ship.y, newState.ship.vx, newState.ship.vy);

                        // Handle asteroid collision (explosion, splitting, etc.)
                        const collisionResult = handleAsteroidCollision(newState, asteroid);

                        // Play BOTH explosion sounds together
                        newState.sound.playShipExplosion();
                        newState.sound.playAsteroidExplosion();

                        // Add any new asteroids from splitting
                        newState.asteroids.push(...collisionResult.newAsteroids);

                        // Remove the asteroid that was hit
                        if (collisionResult.shouldRemove) {
                            newState.asteroids.splice(i, 1);
                        }

                        // Lose a life (only if not in kid mode)
                        if (!newState.kidMode) {
                            newState.lives--;
                        }

                        // Don't end game immediately if lives reach 0 - wait for explosion to complete
                        // Game over logic will be handled when ship explosion ends

                        break; // Only process one collision per frame
                    }
                }
            }

            // Spawn new asteroids if needed
            if (newState.asteroids.length === 0) {
                spawnAsteroids(newState, state.ASTEROID_SPAWN_COUNT);
            }

            return newState;
        }

        function createExplosion(state, x, y) {
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 150;

                state.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30 + Math.floor(Math.random() * 20)
                });
            }
        }

        function createShipDebris(state, shipX, shipY, shipVx, shipVy) {
            // Create ship debris pieces based on ship geometry
            const shipPieces = [
                // Front point
                { points: [[15, 0], [5, 0], [0, -3]], mass: 0.8 },
                // Left wing
                { points: [[-10, -8], [-5, 0], [0, -3]], mass: 1.2 },
                // Right wing
                { points: [[-10, 8], [-5, 0], [0, 3]], mass: 1.2 },
                // Center piece
                { points: [[-5, 0], [0, -3], [0, 3]], mass: 0.6 }
            ];

            state.shipDebris = [];

            shipPieces.forEach((piece, i) => {
                const angle = Math.random() * Math.PI * 2;
                const speed = 80 + Math.random() * 120;
                const debris = {
                    points: piece.points.map(p => [...p]), // Deep copy points
                    x: shipX,
                    y: shipY,
                    vx: shipVx + Math.cos(angle) * speed,
                    vy: shipVy + Math.sin(angle) * speed,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 8, // Random spin
                    life: 120, // 2 seconds at 60fps
                    mass: piece.mass
                };
                state.shipDebris.push(debris);
            });

            // Add extra explosion particles for more drama
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 60 + Math.random() * 200;

                state.particles.push({
                    x: shipX,
                    y: shipY,
                    vx: shipVx + Math.cos(angle) * speed,
                    vy: shipVy + Math.sin(angle) * speed,
                    life: 40 + Math.floor(Math.random() * 30)
                });
            }
        }

        function spawnAsteroids(state, count) {
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = Math.random() * GAME_WIDTH;
                    y = Math.random() * GAME_HEIGHT;
                } while (distance({x, y}, state.ship) < 100);

                const asteroid = createAsteroid(x, y);
                state.asteroids.push(asteroid);
            }
        }

        function createAsteroid(x, y) {
            const size = 20 + Math.random() * 30;
            const points = [];
            const segments = 8 + Math.floor(Math.random() * 4); // Moderate segment count

            for (let i = 0; i < segments; i++) {
                // Add some angle jitter to make shapes more irregular
                const baseAngle = (i / segments) * Math.PI * 2;
                const angleJitter = (Math.random() - 0.5) * 0.15; // Reduced angle jitter
                const angle = baseAngle + angleJitter;

                // Moderate radius variation for natural jaggedness
                const radiusVariation = size * (0.6 + Math.random() * 0.5); // Range from 0.6x to 1.1x size

                points.push([
                    Math.cos(angle) * radiusVariation,
                    Math.sin(angle) * radiusVariation
                ]);
            }

            // Add fewer, more subtle spikes
            const spikeCount = Math.floor(Math.random() * 2); // 0-1 extra spikes
            for (let spike = 0; spike < spikeCount; spike++) {
                const insertIndex = Math.floor(Math.random() * points.length);
                const prevPoint = points[insertIndex];
                const nextPoint = points[(insertIndex + 1) % points.length];

                // Create a more subtle spike between two existing points
                const midAngle = Math.atan2(
                    (prevPoint[1] + nextPoint[1]) / 2,
                    (prevPoint[0] + nextPoint[0]) / 2
                );
                const spikeRadius = size * (0.5 + Math.random() * 0.3); // Less extreme spikes

                points.splice(insertIndex + 1, 0, [
                    Math.cos(midAngle) * spikeRadius,
                    Math.sin(midAngle) * spikeRadius
                ]);
            }

            // Generate initial velocities and ensure they're never too close to zero
            const initialVx = (Math.random() - 0.5) * 100;
            const initialVy = (Math.random() - 0.5) * 100;

            return {
                x: x,
                y: y,
                vx: ensureMinimumVelocity(initialVx),
                vy: ensureMinimumVelocity(initialVy),
                radius: size,
                points: points,
                angle: 0,
                angularVelocity: (Math.random() - 0.5) * 2 // radians per second
            };
        }

        function distance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Ensure velocity is never too close to zero to prevent border sticking
        function ensureMinimumVelocity(velocity, minVelocity = 15) {
            const absVel = Math.abs(velocity);
            if (absVel < minVelocity) {
                if (velocity === 0) {
                    // If exactly zero, assign random sign
                    return (Math.random() < 0.5 ? -1 : 1) * minVelocity;
                } else {
                    // Preserve sign but enforce minimum magnitude
                    return (velocity < 0 ? -1 : 1) * minVelocity;
                }
            }
            return velocity;
        }

        // Handle asteroid collision - splitting or destruction
        function handleAsteroidCollision(gameState, asteroid) {
            const result = {
                newAsteroids: [],
                shouldRemove: true
            };

            // Create explosion particles
            createExplosion(gameState, asteroid.x, asteroid.y);

            // Break up asteroid if it's large enough
            if (asteroid.radius > 20) {
                const newRadius = asteroid.radius * 0.6;

                for (let k = 0; k < 2; k++) {
                    const smallAsteroid = createAsteroid(
                        asteroid.x + (Math.random() - 0.5) * 40,
                        asteroid.y + (Math.random() - 0.5) * 40
                    );

                    // Rescale the points from the randomly generated size to the desired smaller size
                    const originalGeneratedRadius = smallAsteroid.radius;
                    const scaleFactor = newRadius / originalGeneratedRadius;

                    smallAsteroid.radius = newRadius;
                    smallAsteroid.points = smallAsteroid.points.map(point => [
                        point[0] * scaleFactor,
                        point[1] * scaleFactor
                    ]);

                    // Velocity inversely proportional to size: smaller asteroids move faster
                    const baseSpeed = 120;
                    const sizeMultiplier = 40 / smallAsteroid.radius;
                    const velocityBoost = baseSpeed * sizeMultiplier;

                    smallAsteroid.vx = ensureMinimumVelocity(asteroid.vx + (Math.random() - 0.5) * velocityBoost);
                    smallAsteroid.vy = ensureMinimumVelocity(asteroid.vy + (Math.random() - 0.5) * velocityBoost);
                    smallAsteroid.angularVelocity = (Math.random() - 0.5) * 4;

                    result.newAsteroids.push(smallAsteroid);
                }
            }

            return result;
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            const newState = updateGameState(GameState, keysPressed, deltaTime, currentTime);
            Object.assign(GameState, newState);
            render(GameState);

            requestAnimationFrame(gameLoop);
        }

        // Game initialization
        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';

            // Initialize sound system
            GameState.sound = new RealSoundInterface();

            // Reset game state
            GameState.ship.x = GAME_WIDTH / 2;
            GameState.ship.y = GAME_HEIGHT / 2;
            GameState.ship.vx = 0;
            GameState.ship.vy = 0;
            GameState.ship.angle = -Math.PI / 2;

            GameState.asteroids = [];
            GameState.bullets = [];
            GameState.particles = [];
            GameState.shipDebris = [];

            GameState.score = 0;
            GameState.lives = 3;
            GameState.gameOver = false;
            GameState.paused = false;
            GameState.shipExploding = false;
            GameState.shipExplosionStartTime = 0;
            GameState.lastFireTime = 0;

            // Spawn initial asteroids
            spawnAsteroids(GameState, 5);
        }

        // Test Suite
        if (isTestMode) {
            // Setup simple test framework for both Node.js and browser
            if (isNodeJS) {
                console.log('Running Asteroids Game Tests in Node.js\n');
                global.describe = (name, fn) => { console.log(`${name}:`); fn(); };
                global.it = (name, fn) => {
                    try {
                        fn();
                        console.log(`  ✓ ${name}`);
                    } catch(e) {
                        console.log(`  ✗ ${name}: ${e.message}`);
                    }
                };
                global.beforeEach = (fn) => fn();
            } else {
                console.log('Running Asteroids Game Tests in Browser\n');

                // Create a test output container for browser display
                const testOutput = document.createElement('div');
                testOutput.className = 'test-output';
                document.body.appendChild(testOutput);

                window.describe = (name, fn) => {
                    const suiteElement = document.createElement('div');
                    suiteElement.className = 'test-suite';
                    suiteElement.textContent = name + ':';
                    testOutput.appendChild(suiteElement);
                    fn();
                };
                window.it = (name, fn) => {
                    const testElement = document.createElement('div');
                    testElement.className = 'test-case';

                    try {
                        fn();
                        testElement.innerHTML = `<span class="test-pass">✓</span> ${name}`;
                        console.log(`  ✓ ${name}`);
                    } catch(e) {
                        testElement.innerHTML = `<span class="test-fail">✗</span> <span class="test-fail-message">${name}: ${e.message}</span>`;
                        console.log(`  ✗ ${name}: ${e.message}`);
                    }

                    testOutput.appendChild(testElement);
                };
                window.beforeEach = (fn) => fn();
            }

            // Hide the game canvas and show test results
            document.getElementById('gameCanvas').style.display = 'none';
            document.querySelector('.game-info').style.display = 'none';

            // Force hide game over screen with !important override
            const gameOverScreen = document.getElementById('gameOverScreen');
            gameOverScreen.style.setProperty('display', 'none', 'important');
            gameOverScreen.style.setProperty('visibility', 'hidden', 'important');

            // Force hide pause screen as well
            const pauseScreen = document.getElementById('pauseScreen');
            pauseScreen.style.setProperty('display', 'none', 'important');
            pauseScreen.style.setProperty('visibility', 'hidden', 'important');

            // Also hide the game elements by setting body style to prevent any game UI from showing
            document.body.style.backgroundColor = '#fff';
            document.body.style.color = '#000';


            // Test Suite Implementation
            describe('Asteroids Game Tests', function() {

                describe('Utility Functions', function() {
                    it('should calculate distance correctly', function() {
                        const obj1 = { x: 0, y: 0 };
                        const obj2 = { x: 3, y: 4 };
                        const result = distance(obj1, obj2);
                        if (Math.abs(result - 5) > 0.001) {
                            throw new Error(`Expected 5, got ${result}`);
                        }
                    });

                    it('should calculate distance for identical objects', function() {
                        const obj1 = { x: 10, y: 20 };
                        const obj2 = { x: 10, y: 20 };
                        const result = distance(obj1, obj2);
                        if (result !== 0) {
                            throw new Error(`Expected 0, got ${result}`);
                        }
                    });

                    it('should calculate distance for negative coordinates', function() {
                        const obj1 = { x: -3, y: -4 };
                        const obj2 = { x: 0, y: 0 };
                        const result = distance(obj1, obj2);
                        if (Math.abs(result - 5) > 0.001) {
                            throw new Error(`Expected 5, got ${result}`);
                        }
                    });
                });

                describe('Asteroid Creation', function() {
                    it('should create asteroid with correct properties', function() {
                        const asteroid = createAsteroid(100, 200);

                        if (asteroid.x !== 100) throw new Error(`Expected x=100, got ${asteroid.x}`);
                        if (asteroid.y !== 200) throw new Error(`Expected y=200, got ${asteroid.y}`);
                        if (asteroid.radius < 20 || asteroid.radius > 50) {
                            throw new Error(`Expected radius between 20-50, got ${asteroid.radius}`);
                        }
                        if (!Array.isArray(asteroid.points)) {
                            throw new Error('Expected points to be an array');
                        }
                        if (asteroid.points.length < 8 || asteroid.points.length > 12) {
                            throw new Error(`Expected 8-12 points, got ${asteroid.points.length}`);
                        }
                        if (typeof asteroid.vx !== 'number' || typeof asteroid.vy !== 'number') {
                            throw new Error('Expected velocity components to be numbers');
                        }
                    });

                    it('should create asteroids with different shapes', function() {
                        const asteroid1 = createAsteroid(0, 0);
                        const asteroid2 = createAsteroid(0, 0);

                        // Check that points are different (randomized)
                        let identical = true;
                        for (let i = 0; i < Math.min(asteroid1.points.length, asteroid2.points.length); i++) {
                            if (asteroid1.points[i][0] !== asteroid2.points[i][0] ||
                                asteroid1.points[i][1] !== asteroid2.points[i][1]) {
                                identical = false;
                                break;
                            }
                        }
                        if (identical && asteroid1.points.length === asteroid2.points.length) {
                            throw new Error('Asteroids should have different randomized shapes');
                        }
                    });

                    it('should enforce minimum velocity to prevent border sticking', function() {
                        // Test many asteroids to ensure none have near-zero velocities
                        for (let i = 0; i < 50; i++) {
                            const asteroid = createAsteroid(100, 200);

                            if (Math.abs(asteroid.vx) < 15) {
                                throw new Error(`Asteroid vx too small: ${asteroid.vx}, should be >= 15 or <= -15`);
                            }
                            if (Math.abs(asteroid.vy) < 15) {
                                throw new Error(`Asteroid vy too small: ${asteroid.vy}, should be >= 15 or <= -15`);
                            }
                        }
                    });
                });

                describe('Minimum Velocity Enforcement', function() {
                    it('should enforce minimum velocity for positive small values', function() {
                        const result = ensureMinimumVelocity(5, 15);
                        if (result !== 15) {
                            throw new Error(`Expected 15, got ${result}`);
                        }
                    });

                    it('should enforce minimum velocity for negative small values', function() {
                        const result = ensureMinimumVelocity(-5, 15);
                        if (result !== -15) {
                            throw new Error(`Expected -15, got ${result}`);
                        }
                    });

                    it('should handle exactly zero velocity with random sign', function() {
                        const result = ensureMinimumVelocity(0, 15);
                        if (Math.abs(result) !== 15) {
                            throw new Error(`Expected absolute value of 15, got ${result}`);
                        }
                        if (result !== 15 && result !== -15) {
                            throw new Error(`Expected 15 or -15, got ${result}`);
                        }
                    });

                    it('should preserve large velocities unchanged', function() {
                        const result1 = ensureMinimumVelocity(50, 15);
                        if (result1 !== 50) {
                            throw new Error(`Expected 50, got ${result1}`);
                        }

                        const result2 = ensureMinimumVelocity(-50, 15);
                        if (result2 !== -50) {
                            throw new Error(`Expected -50, got ${result2}`);
                        }
                    });

                    it('should handle edge case at minimum threshold', function() {
                        const result1 = ensureMinimumVelocity(15, 15);
                        if (result1 !== 15) {
                            throw new Error(`Expected 15, got ${result1}`);
                        }

                        const result2 = ensureMinimumVelocity(-15, 15);
                        if (result2 !== -15) {
                            throw new Error(`Expected -15, got ${result2}`);
                        }
                    });
                });

                describe('Game State Updates', function() {
                    let testState;

                    beforeEach(function() {
                        testState = {
                            ship: {
                                x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, vx: 0, vy: 0,
                                angle: -Math.PI / 2, radius: 10, thrusting: false
                            },
                            asteroids: [],
                            bullets: [],
                            particles: [],
                            shipDebris: [],
                            score: 0, lives: 3, gameOver: false, paused: false,
                            shipExploding: false, shipExplosionStartTime: 0, lastFireTime: 0,
                            SHIP_ACCELERATION: 300, ROTATION_SPEED: 5,
                            BULLET_SPEED: 500, MAX_BULLETS: 4, ASTEROID_SPAWN_COUNT: 5,
                            sound: new MockSoundInterface()
                        };
                    });

                    it('should update ship rotation with left arrow', function() {
                        const keys = { 'ArrowLeft': true };
                        const deltaTime = 0.1;
                        const newState = updateGameState(testState, keys, deltaTime, 0);

                        const expectedAngle = testState.ship.angle - testState.ROTATION_SPEED * deltaTime;
                        if (Math.abs(newState.ship.angle - expectedAngle) > 0.001) {
                            throw new Error(`Expected angle ${expectedAngle}, got ${newState.ship.angle}`);
                        }
                    });

                    it('should update ship rotation with right arrow', function() {
                        const keys = { 'ArrowRight': true };
                        const deltaTime = 0.1;
                        const newState = updateGameState(testState, keys, deltaTime, 0);

                        const expectedAngle = testState.ship.angle + testState.ROTATION_SPEED * deltaTime;
                        if (Math.abs(newState.ship.angle - expectedAngle) > 0.001) {
                            throw new Error(`Expected angle ${expectedAngle}, got ${newState.ship.angle}`);
                        }
                    });

                    it('should apply thrust when up arrow is pressed', function() {
                        const keys = { 'ArrowUp': true };
                        const deltaTime = 0.1;
                        const newState = updateGameState(testState, keys, deltaTime, 0);

                        if (!newState.ship.thrusting) {
                            throw new Error('Ship should be thrusting');
                        }

                        const acceleration = testState.SHIP_ACCELERATION * deltaTime;
                        const expectedVx = Math.cos(testState.ship.angle) * acceleration;
                        const expectedVy = Math.sin(testState.ship.angle) * acceleration;

                        if (Math.abs(newState.ship.vx - expectedVx) > 0.001) {
                            throw new Error(`Expected vx ${expectedVx}, got ${newState.ship.vx}`);
                        }
                        if (Math.abs(newState.ship.vy - expectedVy) > 0.001) {
                            throw new Error(`Expected vy ${expectedVy}, got ${newState.ship.vy}`);
                        }
                    });

                    it('should create bullet when spacebar is pressed', function() {
                        const keys = { ' ': true };
                        const deltaTime = 0.1;
                        const currentTime = 1000;
                        const newState = updateGameState(testState, keys, deltaTime, currentTime);

                        if (newState.bullets.length !== 1) {
                            throw new Error(`Expected 1 bullet, got ${newState.bullets.length}`);
                        }

                        const bullet = newState.bullets[0];
                        if (typeof bullet.x !== 'number' || typeof bullet.y !== 'number') {
                            throw new Error('Bullet should have numeric coordinates');
                        }
                        if (typeof bullet.vx !== 'number' || typeof bullet.vy !== 'number') {
                            throw new Error('Bullet should have numeric velocity');
                        }
                    });

                    it('should fire bullet with correct velocity and direction', function() {
                        // Test with ship pointing up (default angle -π/2)
                        testState.ship.angle = -Math.PI / 2;
                        testState.ship.vx = 10;
                        testState.ship.vy = 5;

                        const keys = { ' ': true };
                        const deltaTime = 0.1;
                        const currentTime = 1000;
                        const newState = updateGameState(testState, keys, deltaTime, currentTime);

                        if (newState.bullets.length !== 1) {
                            throw new Error(`Expected 1 bullet, got ${newState.bullets.length}`);
                        }

                        const bullet = newState.bullets[0];

                        // Expected velocity: ship velocity + bullet speed in ship direction
                        const expectedVx = testState.ship.vx + Math.cos(testState.ship.angle) * testState.BULLET_SPEED;
                        const expectedVy = testState.ship.vy + Math.sin(testState.ship.angle) * testState.BULLET_SPEED;

                        if (Math.abs(bullet.vx - expectedVx) > 0.001) {
                            throw new Error(`Expected bullet vx ${expectedVx}, got ${bullet.vx}`);
                        }
                        if (Math.abs(bullet.vy - expectedVy) > 0.001) {
                            throw new Error(`Expected bullet vy ${expectedVy}, got ${bullet.vy}`);
                        }

                        // Test with ship pointing right (angle 0)
                        testState.ship.angle = 0;
                        testState.ship.vx = 0;
                        testState.ship.vy = 0;
                        testState.bullets = [];
                        testState.lastFireTime = 0;

                        const newState2 = updateGameState(testState, keys, deltaTime, currentTime + 1000);
                        const bullet2 = newState2.bullets[0];

                        const expectedVx2 = Math.cos(0) * testState.BULLET_SPEED; // Should be BULLET_SPEED
                        const expectedVy2 = Math.sin(0) * testState.BULLET_SPEED; // Should be 0

                        if (Math.abs(bullet2.vx - expectedVx2) > 0.001) {
                            throw new Error(`Expected bullet2 vx ${expectedVx2}, got ${bullet2.vx}`);
                        }
                        if (Math.abs(bullet2.vy - expectedVy2) > 0.001) {
                            throw new Error(`Expected bullet2 vy ${expectedVy2}, got ${bullet2.vy}`);
                        }
                    });

                    it('should not fire bullets too rapidly', function() {
                        testState.lastFireTime = 1000;
                        const keys = { ' ': true };
                        const deltaTime = 0.1;
                        const currentTime = 1100; // Only 100ms later, less than 200ms fire delay
                        const newState = updateGameState(testState, keys, deltaTime, currentTime);

                        if (newState.bullets.length !== 0) {
                            throw new Error('Should not fire bullet due to rate limiting');
                        }
                    });

                    it('should limit maximum number of bullets', function() {
                        // Fill up with max bullets
                        for (let i = 0; i < testState.MAX_BULLETS; i++) {
                            testState.bullets.push({ x: 0, y: 0, vx: 0, vy: 0, distanceTraveled: 0 });
                        }

                        const keys = { ' ': true };
                        const deltaTime = 0.1;
                        const currentTime = 1000;
                        const newState = updateGameState(testState, keys, deltaTime, currentTime);

                        if (newState.bullets.length > testState.MAX_BULLETS) {
                            throw new Error(`Should not exceed max bullets (${testState.MAX_BULLETS})`);
                        }
                    });
                });

                describe('Screen Wrapping', function() {
                    let testState;

                    beforeEach(function() {
                        testState = {
                            ship: { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, vx: 0, vy: 0, angle: 0, radius: 10, thrusting: false },
                            asteroids: [], bullets: [], particles: [], shipDebris: [],
                            score: 0, lives: 3, gameOver: false, paused: false,
                            shipExploding: false, shipExplosionStartTime: 0, lastFireTime: 0,
                            SHIP_ACCELERATION: 300, ROTATION_SPEED: 5, BULLET_SPEED: 500, MAX_BULLETS: 4,
                            sound: new MockSoundInterface()
                        };
                    });

                    it('should wrap ship horizontally', function() {
                        testState.ship.x = -10;
                        const newState = updateGameState(testState, {}, 0.1, 0);
                        if (newState.ship.x !== GAME_WIDTH) {
                            throw new Error(`Expected x=${GAME_WIDTH}, got ${newState.ship.x}`);
                        }

                        testState.ship.x = GAME_WIDTH + 10;
                        const newState2 = updateGameState(testState, {}, 0.1, 0);
                        if (newState2.ship.x !== 0) {
                            throw new Error(`Expected x=0, got ${newState2.ship.x}`);
                        }
                    });

                    it('should wrap ship vertically', function() {
                        testState.ship.y = -10;
                        const newState = updateGameState(testState, {}, 0.1, 0);
                        if (newState.ship.y !== GAME_HEIGHT) {
                            throw new Error(`Expected y=${GAME_HEIGHT}, got ${newState.ship.y}`);
                        }

                        testState.ship.y = GAME_HEIGHT + 10;
                        const newState2 = updateGameState(testState, {}, 0.1, 0);
                        if (newState2.ship.y !== 0) {
                            throw new Error(`Expected y=0, got ${newState2.ship.y}`);
                        }
                    });

                    it('should wrap bullets', function() {
                        testState.bullets = [{ x: -10, y: GAME_HEIGHT / 2, vx: 0, vy: 0, distanceTraveled: 0 }];
                        const newState = updateGameState(testState, {}, 0.1, 0);
                        if (newState.bullets[0].x !== GAME_WIDTH) {
                            throw new Error(`Expected bullet x=${GAME_WIDTH}, got ${newState.bullets[0].x}`);
                        }
                    });
                });

                describe('Collision Detection', function() {
                    let testState;

                    beforeEach(function() {
                        testState = {
                            ship: { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, vx: 0, vy: 0, angle: 0, radius: 10, thrusting: false },
                            asteroids: [], bullets: [], particles: [], shipDebris: [],
                            score: 0, lives: 3, gameOver: false, paused: false,
                            shipExploding: false, shipExplosionStartTime: 0, lastFireTime: 0,
                            SHIP_ACCELERATION: 300, ROTATION_SPEED: 5, BULLET_SPEED: 500, MAX_BULLETS: 4,
                            sound: new MockSoundInterface()
                        };
                    });

                    it('should detect bullet-asteroid collision', function() {
                        testState.bullets = [{ x: 100, y: 100, vx: 0, vy: 0, distanceTraveled: 0 }];
                        testState.asteroids = [{ x: 100, y: 100, radius: 20, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];

                        const newState = updateGameState(testState, {}, 0.1, 0);

                        if (newState.bullets.length !== 0) {
                            throw new Error('Bullet should be removed after collision');
                        }
                        if (newState.score === 0) {
                            throw new Error('Score should increase after asteroid hit');
                        }
                    });

                    it('should ensure split asteroids are always smaller than parent', function() {
                        // Test with a large asteroid that should split
                        testState.bullets = [{ x: 100, y: 100, vx: 0, vy: 0, distanceTraveled: 0 }];
                        testState.asteroids = [{ x: 100, y: 100, radius: 40, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];
                        const originalRadius = testState.asteroids[0].radius;

                        const newState = updateGameState(testState, {}, 0.1, 0);

                        // Should have 2 smaller asteroids (split from the original)
                        if (newState.asteroids.length !== 2) {
                            throw new Error(`Expected 2 split asteroids, got ${newState.asteroids.length}`);
                        }

                        // Each split asteroid should be smaller than the original
                        newState.asteroids.forEach((asteroid, i) => {
                            if (asteroid.radius >= originalRadius) {
                                throw new Error(`Split asteroid ${i} radius ${asteroid.radius} should be smaller than original ${originalRadius}`);
                            }
                            if (asteroid.radius <= 0) {
                                throw new Error(`Split asteroid ${i} radius ${asteroid.radius} should be positive`);
                            }
                            // Should be approximately 60% of original
                            const expectedRadius = originalRadius * 0.6;
                            if (Math.abs(asteroid.radius - expectedRadius) > 0.1) {
                                throw new Error(`Split asteroid ${i} radius ${asteroid.radius} should be ~${expectedRadius}`);
                            }
                        });
                    });

                    it('should detect ship-asteroid collision and split large asteroids', function() {
                        // Use a large asteroid that should split when hit by ship
                        testState.asteroids = [{ x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, radius: 30, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];
                        const initialLives = testState.lives;
                        const initialAsteroidCount = testState.asteroids.length;

                        const newState = updateGameState(testState, {}, 0.1, 0);

                        if (newState.lives !== initialLives - 1) {
                            throw new Error('Ship should lose a life after collision');
                        }

                        if (!newState.shipExploding) {
                            throw new Error('Ship should be exploding after collision');
                        }

                        // Large asteroid should split into 2 smaller ones
                        if (newState.asteroids.length !== 2) {
                            throw new Error(`Expected 2 asteroids after split, got ${newState.asteroids.length}`);
                        }

                        // Each smaller asteroid should have smaller radius
                        newState.asteroids.forEach((asteroid, i) => {
                            if (asteroid.radius >= 30) {
                                throw new Error(`Small asteroid ${i} should have smaller radius than original (30), got ${asteroid.radius}`);
                            }
                            if (asteroid.radius < 15) {
                                throw new Error(`Small asteroid ${i} radius too small, got ${asteroid.radius}`);
                            }
                        });
                    });

                    it('should remove small asteroids when hit by ship without splitting', function() {
                        // Use a small asteroid that should not split
                        testState.asteroids = [{ x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, radius: 15, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];
                        const initialLives = testState.lives;

                        const newState = updateGameState(testState, {}, 0.1, 0);

                        if (newState.lives !== initialLives - 1) {
                            throw new Error('Ship should lose a life after collision');
                        }

                        if (!newState.shipExploding) {
                            throw new Error('Ship should be exploding after collision');
                        }

                        // Small asteroid should be removed completely (no split)
                        if (newState.asteroids.length !== 0) {
                            throw new Error(`Expected 0 asteroids after small asteroid hit, got ${newState.asteroids.length}`);
                        }
                    });

                    it('should trigger explosion when lives reach zero but delay game over', function() {
                        testState.lives = 1;
                        testState.asteroids = [{ x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, radius: 20, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];

                        const newState = updateGameState(testState, {}, 0.1, 1000);

                        // Should trigger explosion but not end game immediately
                        if (!newState.shipExploding) {
                            throw new Error('Ship should be exploding when last life is lost');
                        }
                        if (newState.gameOver) {
                            throw new Error('Game should not be over immediately - should wait for explosion');
                        }
                        if (newState.lives !== 0) {
                            throw new Error('Lives should be 0 after collision');
                        }
                    });
                });

                describe('Particle System', function() {
                    it('should create explosion particles', function() {
                        const testState = { particles: [] };
                        createExplosion(testState, 100, 200);

                        if (testState.particles.length !== 20) {
                            throw new Error(`Expected 20 particles, got ${testState.particles.length}`);
                        }

                        testState.particles.forEach((particle, i) => {
                            if (particle.x !== 100 || particle.y !== 200) {
                                throw new Error(`Particle ${i} should start at explosion position`);
                            }
                            if (typeof particle.vx !== 'number' || typeof particle.vy !== 'number') {
                                throw new Error(`Particle ${i} should have numeric velocity`);
                            }
                            if (typeof particle.life !== 'number' || particle.life <= 0) {
                                throw new Error(`Particle ${i} should have positive life value`);
                            }
                        });
                    });
                });

                describe('Asteroid Spawning', function() {
                    it('should spawn asteroids away from ship', function() {
                        const testState = {
                            ship: { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2 },
                            asteroids: []
                        };

                        spawnAsteroids(testState, 3);

                        if (testState.asteroids.length !== 3) {
                            throw new Error(`Expected 3 asteroids, got ${testState.asteroids.length}`);
                        }

                        testState.asteroids.forEach((asteroid, i) => {
                            const dist = distance(asteroid, testState.ship);
                            if (dist < 100) {
                                throw new Error(`Asteroid ${i} spawned too close to ship (distance: ${dist})`);
                            }
                        });
                    });

                    it('should spawn new asteroids when none remain', function() {
                        const testState = {
                            ship: { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, vx: 0, vy: 0, angle: 0, radius: 10, thrusting: false },
                            asteroids: [], bullets: [], particles: [], shipDebris: [],
                            score: 0, lives: 3, gameOver: false, paused: false,
                            shipExploding: false, shipExplosionStartTime: 0, lastFireTime: 0,
                            ASTEROID_SPAWN_COUNT: 5,
                            sound: new MockSoundInterface()
                        };

                        const newState = updateGameState(testState, {}, 0.1, 0);

                        if (newState.asteroids.length !== 5) {
                            throw new Error(`Expected 5 new asteroids, got ${newState.asteroids.length}`);
                        }
                    });
                });

                describe('Sound System', function() {
                    let testState;

                    beforeEach(function() {
                        testState = {
                            ship: { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, vx: 0, vy: 0, angle: -Math.PI / 2, radius: 10, thrusting: false },
                            asteroids: [], bullets: [], particles: [], shipDebris: [],
                            score: 0, lives: 3, gameOver: false, paused: false,
                            shipExploding: false, shipExplosionStartTime: 0, lastFireTime: 0,
                            SHIP_ACCELERATION: 300, ROTATION_SPEED: 5, BULLET_SPEED: 500, MAX_BULLETS: 4,
                            sound: new MockSoundInterface()
                        };
                    });

                    it('should record thrust sound when ship is thrusting', function() {
                        const keys = { 'ArrowUp': true };
                        const deltaTime = 0.1;

                        // Call updateGameState multiple times to increase chance of sound trigger (random chance)
                        for (let i = 0; i < 50; i++) {
                            testState.sound.reset();
                            updateGameState(testState, keys, deltaTime, 0);
                            if (testState.sound.wasMethodCalled('playThrust')) {
                                return; // Test passed - sound was triggered
                            }
                        }
                        throw new Error('Thrust sound should be played when ship is thrusting');
                    });

                    it('should record shoot sound when bullet is fired', function() {
                        const keys = { ' ': true };
                        const deltaTime = 0.1;
                        const currentTime = 1000;

                        updateGameState(testState, keys, deltaTime, currentTime);

                        if (!testState.sound.wasMethodCalled('playShoot')) {
                            throw new Error('Shoot sound should be played when bullet is fired');
                        }
                        if (testState.sound.getCallCount('playShoot') !== 1) {
                            throw new Error(`Expected 1 shoot sound, got ${testState.sound.getCallCount('playShoot')}`);
                        }
                    });

                    it('should record asteroid explosion sound on bullet-asteroid collision', function() {
                        testState.bullets = [{ x: 100, y: 100, vx: 0, vy: 0, distanceTraveled: 0 }];
                        testState.asteroids = [{ x: 100, y: 100, radius: 20, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];

                        updateGameState(testState, {}, 0.1, 0);

                        if (!testState.sound.wasMethodCalled('playAsteroidExplosion')) {
                            throw new Error('Asteroid explosion sound should be played on collision');
                        }

                        // Should NOT trigger ship explosion sound
                        if (testState.sound.wasMethodCalled('playShipExplosion')) {
                            throw new Error('Should use asteroid explosion sound, not ship explosion sound');
                        }
                    });

                    it('should record BOTH explosion sounds on ship-asteroid collision', function() {
                        // Make sure no bullets are present to avoid bullet-asteroid collision
                        testState.bullets = [];
                        testState.asteroids = [{ x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, radius: 30, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];

                        testState.sound.reset(); // Clear any previous calls
                        updateGameState(testState, {}, 0.1, 0);

                        if (!testState.sound.wasMethodCalled('playShipExplosion')) {
                            throw new Error('Ship explosion sound should be played when ship collides with asteroid');
                        }

                        if (!testState.sound.wasMethodCalled('playAsteroidExplosion')) {
                            throw new Error('Asteroid explosion sound should ALSO be played when ship collides with asteroid');
                        }

                        // Both sounds should be called exactly once
                        if (testState.sound.getCallCount('playShipExplosion') !== 1) {
                            throw new Error(`Expected 1 ship explosion sound, got ${testState.sound.getCallCount('playShipExplosion')}`);
                        }
                        if (testState.sound.getCallCount('playAsteroidExplosion') !== 1) {
                            throw new Error(`Expected 1 asteroid explosion sound, got ${testState.sound.getCallCount('playAsteroidExplosion')}`);
                        }
                    });

                    it('should track multiple sound calls correctly', function() {
                        // Fire a bullet
                        const keys = { ' ': true };
                        updateGameState(testState, keys, 0.1, 1000);

                        // Create collision (bullet-asteroid should use asteroid explosion)
                        testState.bullets = [{ x: 100, y: 100, vx: 0, vy: 0, distanceTraveled: 0 }];
                        testState.asteroids = [{ x: 100, y: 100, radius: 20, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];
                        updateGameState(testState, {}, 0.1, 0);

                        const allCalls = testState.sound.getCalls();
                        if (allCalls.length < 2) {
                            throw new Error(`Expected at least 2 sound calls, got ${allCalls.length}`);
                        }

                        if (!testState.sound.wasMethodCalled('playShoot')) {
                            throw new Error('Should have recorded shoot sound');
                        }
                        if (!testState.sound.wasMethodCalled('playAsteroidExplosion')) {
                            throw new Error('Should have recorded asteroid explosion sound');
                        }
                    });

                    it('should trigger ship explosion sound when ship explodes', function() {
                        testState.asteroids = [{ x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, radius: 20, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];

                        updateGameState(testState, {}, 0.1, 1000);

                        if (!testState.sound.wasMethodCalled('playShipExplosion')) {
                            throw new Error('Ship explosion should trigger ship explosion sound');
                        }

                        // Verify it's the ship explosion (should create debris and set explosion state)
                        const newState = updateGameState(testState, {}, 0.1, 1000);
                        if (!newState.shipExploding) {
                            throw new Error('Ship should be in exploding state');
                        }
                        if (newState.shipDebris.length === 0) {
                            throw new Error('Ship explosion should create debris');
                        }
                    });
                });

                describe('Game Over Logic', function() {
                    let testState;

                    beforeEach(function() {
                        testState = {
                            ship: { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, vx: 0, vy: 0, angle: -Math.PI / 2, radius: 10, thrusting: false },
                            asteroids: [], bullets: [], particles: [], shipDebris: [],
                            score: 0, lives: 1, gameOver: false, paused: false, // Only 1 life left
                            shipExploding: false, shipExplosionStartTime: 0, lastFireTime: 0,
                            SHIP_ACCELERATION: 300, ROTATION_SPEED: 5, BULLET_SPEED: 500, MAX_BULLETS: 4,
                            sound: new MockSoundInterface()
                        };
                    });

                    it('should delay game over until ship explosion completes', function() {
                        // Trigger ship explosion on last life
                        testState.asteroids = [{ x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, radius: 20, vx: 0, vy: 0, angle: 0, angularVelocity: 0, points: [] }];

                        const newState1 = updateGameState(testState, {}, 0.1, 1000);

                        // Ship should be exploding but game should NOT be over yet
                        if (!newState1.shipExploding) {
                            throw new Error('Ship should be exploding');
                        }
                        if (newState1.gameOver) {
                            throw new Error('Game should not be over until explosion completes');
                        }
                        if (newState1.lives !== 0) {
                            throw new Error('Lives should be 0 after collision');
                        }

                        // Debug: Check that explosion start time was set correctly
                        if (newState1.shipExplosionStartTime !== 1000) {
                            throw new Error(`Expected explosion start time to be 1000, got ${newState1.shipExplosionStartTime}`);
                        }

                        // During explosion (1 second in), game should still not be over
                        const newState2 = updateGameState(newState1, {}, 0.1, 2000);
                        if (newState2.gameOver) {
                            throw new Error('Game should not be over during explosion');
                        }

                        // After explosion completes (2+ seconds), game should be over
                        // The explosion started at time 1000, so at time 3100 it should be done (3100-1000 = 2100ms > 2000ms)
                        const newState3 = updateGameState(newState2, {}, 0.1, 3100);
                        if (!newState3.gameOver) {
                            throw new Error(`Game should be over after explosion completes. State: exploding=${newState3.shipExploding}, lives=${newState3.lives}, gameOver=${newState3.gameOver}`);
                        }
                        if (newState3.shipExploding) {
                            throw new Error(`Ship should no longer be exploding. Start time: ${newState3.shipExplosionStartTime}, current time: 3100, difference: ${3100 - newState3.shipExplosionStartTime}`);
                        }
                        if (newState3.shipDebris.length > 0) {
                            throw new Error('Ship debris should be cleared after explosion');
                        }
                    });

                    it('should not render ship when game is over', function() {
                        // Test ship draws normally when game is not over
                        const normalState = { shipExploding: false, gameOver: false };
                        const shouldDrawNormal = !normalState.shipExploding && !normalState.gameOver;
                        if (!shouldDrawNormal) {
                            throw new Error('Ship should draw when game is not over and not exploding');
                        }

                        // Test ship does not draw when game is over
                        const gameOverState = { shipExploding: false, gameOver: true };
                        const shouldDrawGameOver = !gameOverState.shipExploding && !gameOverState.gameOver;
                        if (shouldDrawGameOver) {
                            throw new Error('Ship should not be drawn when game is over');
                        }

                        // Test ship does not draw when exploding (existing behavior)
                        const explodingState = { shipExploding: true, gameOver: false };
                        const shouldDrawExploding = !explodingState.shipExploding && !explodingState.gameOver;
                        if (shouldDrawExploding) {
                            throw new Error('Ship should not be drawn when exploding');
                        }

                        // Test ship does not draw when both exploding and game over
                        const bothState = { shipExploding: true, gameOver: true };
                        const shouldDrawBoth = !bothState.shipExploding && !bothState.gameOver;
                        if (shouldDrawBoth) {
                            throw new Error('Ship should not be drawn when both exploding and game over');
                        }
                    });
                });
            });


            // Complete test execution message
            if (isNodeJS) {
                console.log('\nTests completed successfully!');
            } else {
                // Add green completion message to browser output
                const testOutput = document.querySelector('.test-output');
                if (testOutput) {
                    const completionElement = document.createElement('div');
                    completionElement.className = 'test-completion';
                    completionElement.textContent = 'All tests completed!';
                    testOutput.appendChild(completionElement);
                }
                console.log('\nAll tests completed!');
            }
        } else {
            // Start the game normally
            restartGame();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
