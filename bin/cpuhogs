#!/usr/bin/env bash

set -euo pipefail

if [[ "${1:-}" == "--test" ]]; then
	shift || true
	if [[ $# -gt 0 ]]; then
		echo "cpuhogs: --test does not accept additional arguments" >&2
		exit 1
	fi
	test_file="$HOME/dotfiles/bin/test/cpuhogs_test"
	if [[ ! -x "$test_file" ]]; then
		echo "cpuhogs: missing test file $test_file" >&2
		exit 1
	fi
	"$test_file" >/dev/null
	exit $?
fi

AWK_BIN=${CPUHOGS_AWK:-gawk}
if ! command -v "$AWK_BIN" >/dev/null 2>&1; then
	echo "cpuhogs: required awk interpreter '$AWK_BIN' not found" >&2
	exit 1
fi

platform=$(uname -s)
PS_BIN=${CPUHOGS_PS:-ps}
if [[ -z "${CPUHOGS_PS:-}" && "$platform" == "Darwin" && -x /bin/ps ]]; then
	PS_BIN=/bin/ps
fi
if ! command -v "$PS_BIN" >/dev/null 2>&1; then
	echo "cpuhogs: required ps binary '$PS_BIN' not found" >&2
	exit 1
fi

count=15
mode="group"
show_detail=0
alert_threshold=${CPUHOGS_ALERT_THRESHOLD:-10}
peg_threshold=${CPUHOGS_PEG_THRESHOLD:-400}

usage() {
	cat <<'USAGE'
Usage: cpuhogs [-i] [-n COUNT] [-F]

Options:
  -i            Show individual processes instead of aggregating by command.
  -n COUNT      Number of rows to display (default 15).
  -F, --detail  Append detail view for the busiest executable.
  -h, --help    Show this help text.
  -a, --about   Describe this tool.
  --test        Run the cpuhogs test suite (stdout muted) and exit.

Environment:
  CPUHOGS_AWK             awk interpreter to use (default gawk).
  CPUHOGS_PS              ps executable to use (defaults to /bin/ps on macOS).
  CPUHOGS_TOTAL_CORES     Override detected logical CPU count.
  CPUHOGS_ALERT_THRESHOLD Minimum process count to flag in FYI alerts (default 10).
  CPUHOGS_PEG_THRESHOLD   Minimum per-core %CPU to treat as "pegged" (default 400).
  CPUHOGS_*_CMD           Override ps invocations (GROUP, INDIVIDUAL, DETAIL, STATE).
USAGE
}

about() {
	echo "cpuhogs: report top CPU consumers with per-core and whole-system context."
}

while [[ $# -gt 0 ]]; do
	case "$1" in
		-i)
			mode="individual"
			shift
			;;
		-n)
			if [[ $# -lt 2 ]]; then
				echo "cpuhogs: option -n requires an argument" >&2
				exit 1
			fi
			if [[ ! "$2" =~ ^[0-9]+$ ]] || (( $2 <= 0 )); then
				echo "cpuhogs: COUNT must be a positive integer" >&2
				exit 1
			fi
			count="$2"
			shift 2
			;;
		-F|--detail)
			show_detail=1
			shift
			;;
		-h|--help)
			usage
			exit 0
			;;
		-a|--about)
			about
			exit 0
			;;
		--*)
			echo "cpuhogs: invalid option $1" >&2
			usage >&2
			exit 1
			;;
		-*)
			echo "cpuhogs: invalid option $1" >&2
			usage >&2
			exit 1
			;;
		*)
			echo "cpuhogs: unexpected positional argument '$1'" >&2
			usage >&2
			exit 1
			;;
	 esac
done

detect_cpu_cores() {
	local override
	override=${CPUHOGS_TOTAL_CORES:-}
	if [[ -n "$override" ]]; then
		echo "$override"
		return
	fi
	case "$platform" in
		Linux)
			if command -v nproc >/dev/null 2>&1; then
				nproc
				return
			fi
			if [[ -f /proc/cpuinfo ]]; then
				awk '/^processor/ {count++} END {print count}' /proc/cpuinfo
				return
			fi
			;;
		Darwin)
			if command -v sysctl >/dev/null 2>&1; then
				sysctl -n hw.ncpu
				return
			fi
			;;
	esac
	echo "cpuhogs: unable to determine CPU count" >&2
	exit 1
}

total_cores=$(detect_cpu_cores)
if [[ -z "$total_cores" || "$total_cores" == 0 ]]; then
	echo "cpuhogs: invalid CPU count" >&2
	exit 1
fi

run_data_source() {
	local mode="$1"
	local var="CPUHOGS_${mode}_CMD"
	local override=""
	eval "override=\${$var:-}"
	if [[ -n "$override" ]]; then
		bash -c "$override"
		return
	fi
	case "$mode" in
		GROUP)
			"$PS_BIN" axo pcpu=,comm=
			;;
		INDIVIDUAL)
			"$PS_BIN" axo pid=,user=,pcpu=,command=
			;;
		DETAIL)
			"$PS_BIN" axo pcpu=,pid=,command=
			;;
		STATE)
			"$PS_BIN" axo state=,pid=,comm=
			;;
		*)
			echo "cpuhogs: unknown data mode $mode" >&2
			exit 1
			;;
	 esac
}

print_group_view() {
	printf "%-32s %5s %9s %9s\n" "COMMAND" "PROC" "%CPU" "%SYS"
	run_data_source GROUP | "$AWK_BIN" -v limit="$count" -v cores="$total_cores" '
	function base(cmd) {
		if (cmd == "") {
			return "[unknown]";
		}
		sub(".*/", "", cmd);
		return cmd;
	}
	{
		cpu = $1 + 0;
		cmd = substr($0, index($0, $2));
		gsub(/^[[:space:]]+|[[:space:]]+$/, "", cmd);
		exe = (cmd == "") ? "[unknown]" : cmd;
		cpu_map[exe] += cpu;
		count_map[exe] += 1;
	}
	END {
		n = asorti(cpu_map, idx, "@val_num_desc");
		if (limit < 1 || limit > n) {
			limit = n;
		}
		for (i = 1; i <= limit; ++i) {
			exe = idx[i];
			cpu = cpu_map[exe];
			per_sys = (cores > 0) ? cpu / cores : 0;
			printf "%-32s %5d %8.2f %8.2f\n", base(exe), count_map[exe], cpu, per_sys;
		}
	}
	'
}

print_individual_view() {
	printf "%7s %-12s %9s %9s %s\n" "PID" "USER" "%CPU" "%SYS" "COMMAND"
	run_data_source INDIVIDUAL | sort -k3,3nr | "$AWK_BIN" -v limit="$count" -v cores="$total_cores" '
	{
		pid = $1;
		user = $2;
		cpu = $3 + 0;
		cmd = $4;
		for (i = 5; i <= NF; ++i) {
			cmd = cmd " " $i;
		}
		if (++rows <= limit) {
			per_sys = (cores > 0) ? cpu / cores : 0;
			printf "%7s %-12s %8.2f %8.2f %s\n", pid, user, cpu, per_sys, cmd;
		}
	}
	'
}

print_detail_summary() {
	local detail_info detail_exe detail_cpu detail_count
	local comm_file

	detail_info=$(run_data_source GROUP | "$AWK_BIN" '
	{
		cpu = $1 + 0;
		cmd = substr($0, index($0, $2));
		gsub(/^[[:space:]]+|[[:space:]]+$/, "", cmd);
		exe = (cmd == "") ? "[unknown]" : cmd;
		cpu_map[exe] += cpu;
		count_map[exe] += 1;
	}
	END {
		max_exe = "";
		max_cpu = 0;
		for (exe in cpu_map) {
			if (cpu_map[exe] > max_cpu) {
				max_cpu = cpu_map[exe];
				max_exe = exe;
			}
		}
		if (max_exe != "") {
			printf "%s\t%.4f\t%d\n", max_exe, max_cpu, count_map[max_exe];
		}
	}
	')

	if [[ -z "${detail_info:-}" ]]; then
		printf "\nFYI: no multi-process executables detected.\n"
		return
	fi

	detail_exe=${detail_info%%$'\t'*}
	detail_cpu=${detail_info#*$'\t'}
	detail_cpu=${detail_cpu%%$'\t'*}
	detail_count=${detail_info##*$'\t'}

	local detail_sys
	detail_sys=$("$AWK_BIN" -v cpu="$detail_cpu" -v cores="$total_cores" 'BEGIN { if (cores > 0) printf "%.2f", cpu / cores; else printf "0.00" }')

	printf "\nFYI: %s spans %d processes consuming %.2f%% CPU total (%.2f%% of system).\n" \
		"$detail_exe" "$detail_count" "$detail_cpu" "$detail_sys"

	comm_file=$(mktemp --tmpdir cpuhogs-comm.XXXXXX)
	run_data_source STATE >"$comm_file"

	run_data_source DETAIL | sort -k1,1nr | "$AWK_BIN" -v exe="$detail_exe" -v limit="$count" -v cores="$total_cores" -v comm_file="$comm_file" '
	function trim(s) {
		gsub(/^[[:space:]]+|[[:space:]]+$/, "", s);
		return s;
	}
	BEGIN {
		while ((getline < comm_file) > 0) {
			state = $1;
			pid = $2;
			comm = $3;
			for (i = 4; i <= NF; ++i) {
				comm = comm " " $i;
			}
			comm = trim(comm);
			if (comm == "")
				comm = "[unknown]";
			comm_map[pid] = comm;
		}
		close(comm_file);
	}
	{
		cpu = $1 + 0;
		pid = $2;
		cmd = $3;
		for (i = 4; i <= NF; ++i) {
			cmd = cmd " " $i;
		}
		if (comm_map[pid] == exe) {
			if (!printed_header) {
				printf "\n%-7s %9s %9s %s\n", "PID", "%CPU", "%SYS", "COMMAND";
				printed_header = 1;
			}
			if (++rows <= limit) {
				per_sys = (cores > 0) ? cpu / cores : 0;
				printf "%-7s %9.2f %9.2f %s\n", pid, cpu, per_sys, cmd;
			}
		}
	}
	'

	rm -f "$comm_file" 2>/dev/null || true
}

print_state_block() {
	local state="$1"
	local total="$2"
	local details="$3"
	local description="$4"
	if [[ -z "$total" || "$total" == 0 ]]; then
		return
	fi
	printf "  %s processes %s (state %s).\n" "$total" "$description" "$state"
	if [[ -n "$details" ]]; then
		printf '%s\n' "$details" | sort -t $'\t' -k2,2nr | head -n 3 | while IFS=$'\t' read -r cmd cnt; do
			[[ -z "$cmd" ]] && continue
			printf "    %s (%d)\n" "$cmd" "$cnt"
		done
	fi
}

print_fyi() {
	local pegged_info state_raw
	pegged_info=$(run_data_source DETAIL | "$AWK_BIN" -v threshold="$peg_threshold" -v cores="$total_cores" '
	{
		cpu = $1 + 0;
		pid = $2;
		cmd = $3;
		for (i = 4; i <= NF; ++i) {
			cmd = cmd " " $i;
		}
		if (cpu >= threshold) {
			per_sys = (cores > 0) ? cpu / cores : 0;
			printf "%s\t%.2f\t%.2f\t%s\n", pid, cpu, per_sys, cmd;
		}
	}
	')

	state_raw=$(run_data_source STATE | "$AWK_BIN" -v alert="$alert_threshold" '
	{
		state = substr($1,1,1);
		cmd = $3;
		for (i = 4; i <= NF; ++i) {
			cmd = cmd " " $i;
		}
		cmd_counts[cmd] += 1;
		state_counts[state] += 1;
		if (state ~ /[DTZ]/) {
			key = state "\t" cmd;
			detail[key] += 1;
		}
	}
	END {
		for (s in state_counts) {
			printf "STATE\t%s\t%d\n", s, state_counts[s];
		}
		for (k in detail) {
			split(k, parts, "\t");
			printf "DETAIL\t%s\t%s\t%d\n", parts[1], parts[2], detail[k];
		}
		if (alert > 0) {
			for (cmd_name in cmd_counts) {
				if (cmd_counts[cmd_name] > alert) {
					printf "OUTLIER\t%s\t%d\n", cmd_name, cmd_counts[cmd_name];
				}
			}
		}
	}
	')

	if [[ -z "$pegged_info" && -z "$state_raw" ]]; then
		return
	fi

	printf "\nFYI:\n"

	if [[ -n "$pegged_info" ]]; then
		printf "  Pegged processes (>= %.0f%% of a single core):\n" "$peg_threshold"
		while IFS=$'\t' read -r pid per_core per_sys cmd; do
			[[ -z "$pid" ]] && continue
			printf "    PID %s using %.2f%% core / %.2f%% system - %s\n" "$pid" "$per_core" "$per_sys" "$cmd"
		done <<<"$pegged_info"
	fi

	if [[ -n "$state_raw" ]]; then
		local total_D total_T total_Z detail_D detail_T detail_Z outlier_lines
		while IFS=$'\t' read -r kind a b c; do
			case "$kind" in
				STATE)
					case "$a" in
						D) total_D="$b" ;;
						T) total_T="$b" ;;
						Z) total_Z="$b" ;;
					esac
					;;
				DETAIL)
					case "$a" in
						D)
							detail_D+="${b}"$'\t'"${c}"$'\n'
							;;
						T)
							detail_T+="${b}"$'\t'"${c}"$'\n'
							;;
						Z)
							detail_Z+="${b}"$'\t'"${c}"$'\n'
							;;
					esac
					;;
				OUTLIER)
					outlier_lines+="${a}"$'\t'"${b}"$'\n'
					;;
			esac
		done <<<"$state_raw"

		print_state_block "D" "${total_D:-}" "${detail_D:-}" "in uninterruptible sleep"
		print_state_block "T" "${total_T:-}" "${detail_T:-}" "stopped or traced"
		print_state_block "Z" "${total_Z:-}" "${detail_Z:-}" "that are zombies"

		if [[ -n "${outlier_lines:-}" ]]; then
			printf "  Command storms (> %d processes):\n" "$alert_threshold"
			printf '%s\n' "$outlier_lines" | sort -t $'\t' -k2,2nr | while IFS=$'\t' read -r cmd cnt; do
				printf "    %s (%d processes)\n" "$cmd" "$cnt"
			done
		fi
	fi
}

if [[ "$mode" == "group" ]]; then
	print_group_view
else
	print_individual_view
fi

if (( show_detail )); then
	print_detail_summary
fi

print_fyi
