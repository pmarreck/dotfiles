#!/usr/bin/env bash

# dirtree: A simple wrapper around eza for directory trees

show_help() {
	echo "dirtree - Display directory trees using eza"
	echo ""
	echo "Usage: dirtree [OPTIONS] [PATH]"
	echo ""
	echo "Options:"
	echo "  -h, --help         Show this help message"
	echo "  -a, --about        Show detailed description"
	echo "  -d, --depth N      Set maximum depth (default: 2)"
	echo "  --simple           Output a simple, LLM-friendly stateful tree"
	echo "  --llm              Alias for --simple"
	echo "  --decorated        Force decorated eza output (even when piped)"
	echo "  --default X        Persist default state: opened|closed"
	echo "  -o, --open DIR...  Open one or more subdirs (repeat flag to add more)"
	echo "  -c, --close DIR... Close one or more subdirs (repeat flag to add more)"
	echo "  --show PATH...     Force show relative paths; wrap regexes as /pattern/"
	echo "  --hide PATH...     Hide relative paths; wrap regexes as /pattern/ (repeatable)"
	echo "  --sort MODE        Sorting mode: modified|alpha (default: modified)"
	echo "  --asc              Sort ascending"
	echo "  --desc             Sort descending (default)"
	echo "  --show-hidden      Temporarily display paths hidden via config"
	echo "  --test             Run associated tests"
	echo ""
	echo "Use /pattern/ with --open/--close/--show/--hide to add regex rules; other arguments are treated as literals."
	echo "Paths supplied to --show/--hide must be relative (no leading '/')."
	echo ""
	echo "Behavior: By default, when stdout is not a TTY (piped),"
	echo "  colors/icons/hyperlinks are disabled unless --decorated is given."
	echo ""
	echo "Examples:"
	echo "  dirtree                       # Show tree of current directory"
	echo "  dirtree -d 3                  # Set depth to 3 levels"
	echo "  dirtree --sort alpha --asc    # Sorted alphabetically ascending"
}

# Default values
depth=10 # keep it deep but sane
dir="."
simple_mode=false
force_decorated=false
default_state=""
default_state_set=false
default_visibility="shown"
default_visibility_set=false
default_conflict=""
cli_default_state=""
cli_default_visibility=""
open_args=()
close_args=()
show_args=()
hide_args=()
open_regex_args=()
close_regex_args=()
show_regex_args=()
hide_regex_args=()
state_modified=false
sort_mode="modified"
sort_reverse=1  # 1 => descending (default), 0 => ascending
render_sort_field="modified"
render_sort_reverse=1
dir_pending=true
show_hidden=false

STATE_VERSION_LABEL="ver=1.1"
state_version=""
state_needs_migration=false
declare -a state_passthrough_lines=()

# Normalize path to a relative, trimmed form
normalize_rel() {
	local base="$1" p="$2"
	# remove leading ./
	p="${p#./}"
	# strip leading base if absolute within base
	case "$p" in
		"$base"/*) p="${p#"$base"/}" ;;
	esac
	# strip leading slash if any
	p="${p#/}"
	# strip trailing slash
	p="${p%/}"
	printf '%s' "$p"
}

osc8_decode_path() {
	local path="$1" out="" char hex
	local i len=${#path}
	for ((i=0; i<len; i++)); do
		char=${path:i:1}
		if [[ "$char" == '%' && i+2 < len ]]; then
			hex=${path:i+1:2}
			if [[ "$hex" =~ ^[0-9A-Fa-f]{2}$ ]]; then
				printf -v char '\\x%s' "$hex"
				out+=$(printf '%b' "$char")
				((i+=2))
				continue
			fi
		fi
		out+="${path:i:1}"
	done
	printf '%s' "$out"
}

declare -A open_literals
declare -A close_literals
declare -A show_literals
declare -A hide_literals
declare -A open_literal_comments
declare -A close_literal_comments
declare -A show_literal_comments
declare -A hide_literal_comments
declare -A open_regex_comments
declare -A close_regex_comments
declare -A show_regex_comments
declare -A hide_regex_comments
open_regexes=()
close_regexes=()
show_regexes=()
hide_regexes=()

hidden_count_log=""

note_hidden() {
	local kind="$1"
	[[ "$show_hidden" == true ]] && return
	[[ -z "$hidden_count_log" ]] && return
	printf '%s\n' "$kind" >>"$hidden_count_log"
}

process_default_token() {
	local token="$1"
	[[ -z "$token" ]] && return 0
	if [[ -n "$default_conflict" ]]; then
		return 1
	fi
	token=$(printf '%s' "$token" | tr '[:upper:]' '[:lower:]')
	case "$token" in
		open|opened)
			if [[ "$default_state_set" == true && "$default_state" != "opened" ]]; then
				default_conflict="default entries conflict: opened and closed"
				return 1
			fi
			[[ "$token" == "open" ]] && state_needs_migration=true
			default_state="opened"
			default_state_set=true
			;;
		close|closed)
			if [[ "$default_state_set" == true && "$default_state" != "closed" ]]; then
				default_conflict="default entries conflict: opened and closed"
				return 1
			fi
			[[ "$token" == "close" ]] && state_needs_migration=true
			default_state="closed"
			default_state_set=true
			;;
		show|shown)
			if [[ "$default_visibility_set" == true && "$default_visibility" != "shown" ]]; then
				default_conflict="default entries conflict: shown and hidden"
				return 1
			fi
			[[ "$token" == "show" ]] && state_needs_migration=true
			default_visibility="shown"
			default_visibility_set=true
			;;
		hide|hidden)
			if [[ "$default_visibility_set" == true && "$default_visibility" != "hidden" ]]; then
				default_conflict="default entries conflict: shown and hidden"
				return 1
			fi
			[[ "$token" == "hide" ]] && state_needs_migration=true
			default_visibility="hidden"
			default_visibility_set=true
			;;
		*)
			default_conflict="default entries conflict: unknown entry '$token'"
			return 1
			;;
	esac
	return 0
}

report_hidden_counts() {
	[[ "$show_hidden" == true ]] && return
	[[ -z "$hidden_count_log" ]] && return
	[[ ! -f "$hidden_count_log" ]] && return
	local dir_count=0 file_count=0
	if [[ -s "$hidden_count_log" ]]; then
		dir_count=$(grep -c '^dir$' "$hidden_count_log" || true)
		file_count=$(grep -c '^file$' "$hidden_count_log" || true)
	fi
	if (( dir_count == 0 && file_count == 0 )); then
		return
	fi
	local parts=()
	local msg=""
	if (( dir_count > 0 )); then
		if (( dir_count == 1 )); then
			parts+=("1 directory")
		else
			parts+=("${dir_count} directories")
		fi
	fi
	if (( file_count > 0 )); then
		if (( file_count == 1 )); then
			parts+=("1 file")
		else
			parts+=("${file_count} files")
		fi
	fi
	if (( ${#parts[@]} == 2 )); then
		msg="${parts[0]} and ${parts[1]}"
	else
		msg="${parts[0]}"
	fi
	local total=$((dir_count + file_count))
	if (( total == 1 )); then
		msg+=" is hidden."
	else
		msg+=" are hidden."
	fi
	if [[ "$simple_mode" == true ]]; then
		printf '\n%s\n' "$msg" >&2
	else
		printf '\n\033[2;3m%s\033[0m\n' "$msg" >&2
	fi
}

open_match_type="none"
open_match_pattern=""
close_match_type="none"
close_match_pattern=""
show_match_type="none"
show_match_pattern=""
hide_match_type="none"
hide_match_pattern=""

append_unique_regex() {
	local -n array_ref="$1"
	local pattern="$2"
	[[ -z "$pattern" ]] && return
	for existing in "${array_ref[@]}"; do
		if [[ "$existing" == "$pattern" ]]; then
			return
		fi
	done
	array_ref+=("$pattern")
}

load_literal_list() {
	local base="$1" list="$2" literal_name="$3" regex_name="$4"
	local -n literals_ref="$literal_name"
	local -n regexes_ref="$regex_name"
	IFS=';' read -r -a arr <<< "$list"
	for entry in "${arr[@]}"; do
		[[ -z "$entry" ]] && continue
		local norm
		norm=$(normalize_rel "$base" "$entry")
		[[ -n "$norm" ]] && literals_ref["$norm"]=1
	done
}

load_regex_list() {
	local list="$1" regex_name="$2"
	local -n regexes_ref="$regex_name"
	IFS=';' read -r -a arr <<< "$list"
	for entry in "${arr[@]}"; do
		[[ -z "$entry" ]] && continue
		append_unique_regex regexes_ref "$entry"
	done
}

load_hide_list() {
	local base="$1" list="$2" pattern
	IFS=';' read -r -a arr <<< "$list"
	for entry in "${arr[@]}"; do
		[[ -z "$entry" ]] && continue
		if [[ "$entry" == /* && "$entry" == */ ]]; then
			if (( ${#entry} <= 2 )); then
				continue
			fi
			pattern="${entry:1:-1}"
			append_unique_regex hide_regexes "$pattern"
			continue
		fi
		local norm
		norm=$(normalize_rel "$base" "$entry")
		[[ -n "$norm" ]] && hide_literals["$norm"]=1
	done
}

load_show_list() {
	local base="$1" list="$2" pattern
	IFS=';' read -r -a arr <<< "$list"
	for entry in "${arr[@]}"; do
		[[ -z "$entry" ]] && continue
		if [[ "$entry" == /* && "$entry" == */ ]]; then
			if (( ${#entry} <= 2 )); then
				continue
			fi
			pattern="${entry:1:-1}"
			append_unique_regex show_regexes "$pattern"
			continue
		fi
		local norm
		norm=$(normalize_rel "$base" "$entry")
		[[ -n "$norm" ]] && show_literals["$norm"]=1
	done
}

strip_leading_space_tabs() {
	local value="$1"
	if [[ "$value" =~ ^[[:space:]]*(.*)$ ]]; then
		printf '%s' "${BASH_REMATCH[1]}"
	else
		printf '%s' "$value"
	fi
}

strip_trailing_space_tabs() {
	local value="$1"
	while [[ -n "$value" ]]; do
		local last="${value: -1}"
		if [[ "$last" == ' ' || "$last" == $'\t' ]]; then
			value="${value::-1}"
		else
			break
		fi
	done
	printf '%s' "$value"
}

split_inline_items() {
	local content="$1"
	local ref_name="$2"
	local -n arr_ref="$ref_name"
	arr_ref=()
	content=$(strip_leading_space_tabs "$content")
	content=$(strip_trailing_space_tabs "$content")
	[[ -z "$content" ]] && return
	local sentinel=$'\x1f'
	content="${content//\\ /$sentinel}"
	local -a parts=()
	read -r -a parts <<< "$content"
	for part in "${parts[@]}"; do
		arr_ref+=("${part//$sentinel/ }")
	done
}

parse_inline_default() {
	local content="$1"
	local -a tokens=()
	split_inline_items "$content" tokens
	for token in "${tokens[@]}"; do
		process_default_token "$token"
	done
}

parse_inline_collection() {
	local base="$1" key="$2" content="$3"
	local -a tokens=()
	split_inline_items "$content" tokens
	local token pattern norm
	for token in "${tokens[@]}"; do
		[[ -z "$token" ]] && continue
		if [[ "$token" == /* && "$token" == */ && ${#token} -gt 2 ]]; then
			pattern="${token:1:-1}"
			case "$key" in
				open) append_unique_regex open_regexes "$pattern" ;;
				close) append_unique_regex close_regexes "$pattern" ;;
				show) append_unique_regex show_regexes "$pattern" ;;
				hide) append_unique_regex hide_regexes "$pattern" ;;
			esac
			continue
		fi
		norm=$(normalize_rel "$base" "$token")
		[[ -z "$norm" ]] && continue
		case "$key" in
			open) open_literals["$norm"]=1 ;;
			close) close_literals["$norm"]=1 ;;
			show) show_literals["$norm"]=1 ;;
			hide) hide_literals["$norm"]=1 ;;
		esac
	done
}

read_state() {
	local base="$1"
	local state_file="$base/.dirtree-state"
	default_state=""
	default_state_set=false
	default_visibility="shown"
	default_visibility_set=false
	default_conflict=""
	open_literals=()
	close_literals=()
	show_literals=()
	hide_literals=()
	open_regexes=()
	close_regexes=()
	show_regexes=()
	hide_regexes=()
	state_version="ver=1.0"
	state_needs_migration=false
	state_passthrough_lines=()
	[[ ! -f "$state_file" ]] && return

	local -a __state_lines=()
	mapfile -t __state_lines < "$state_file"
	local format="undetermined"
	local idx=0
	local count=${#__state_lines[@]}
	local current_array=""
	local collecting_unknown=0
	local -a unknown_buffer=()
	local array_comment_buffer=""

	while (( idx < count )); do
		local raw="${__state_lines[$idx]}"
		local line="${raw%$'\r'}"

		if [[ -n "$current_array" ]]; then
			if (( collecting_unknown )); then
				unknown_buffer+=("$raw")
				if [[ "${line//[[:space:]]/}" == "]" ]]; then
					state_passthrough_lines+=("${unknown_buffer[@]}")
					unknown_buffer=()
					collecting_unknown=0
					current_array=""
				fi
				((idx++))
				continue
			fi

			if [[ "${line//[[:space:]]/}" == "]" ]]; then
				current_array=""
				array_comment_buffer=""
				((idx++))
				continue
			fi

			if [[ "$line" =~ ^[[:space:]]*# ]]; then
				case "$current_array" in
					default|open|close|show|hide)
						array_comment_buffer+="$raw\n"
						;;
					*) ;;
				esac
				((idx++))
				continue
			fi

			local entry
			entry=$(strip_leading_space_tabs "$line")
			entry=$(strip_trailing_space_tabs "$entry")
			[[ -z "$entry" ]] && { ((idx++)); continue; }

			if [[ "$entry" == /* && "$entry" == */ && ${#entry} -ge 2 ]]; then
				entry="${entry:1:-1}"
				case "$current_array" in
					open)
						append_unique_regex open_regexes "$entry"
						[[ -n "$array_comment_buffer" ]] && open_regex_comments["/$entry/"]="$array_comment_buffer"
						;;
					close)
						append_unique_regex close_regexes "$entry"
						[[ -n "$array_comment_buffer" ]] && close_regex_comments["/$entry/"]="$array_comment_buffer"
						;;
					show)
						append_unique_regex show_regexes "$entry"
						[[ -n "$array_comment_buffer" ]] && show_regex_comments["/$entry/"]="$array_comment_buffer"
						;;
					hide)
						append_unique_regex hide_regexes "$entry"
						[[ -n "$array_comment_buffer" ]] && hide_regex_comments["/$entry/"]="$array_comment_buffer"
						;;
				esac
				array_comment_buffer=""
			else
				local norm
				norm=$(normalize_rel "$base" "$entry")
				[[ -z "$norm" ]] && { ((idx++)); continue; }
				case "$current_array" in
					open)
						open_literals["$norm"]=1
						[[ -n "$array_comment_buffer" ]] && open_literal_comments["$norm"]="$array_comment_buffer"
						;;
					close)
						close_literals["$norm"]=1
						[[ -n "$array_comment_buffer" ]] && close_literal_comments["$norm"]="$array_comment_buffer"
						;;
					show)
						show_literals["$norm"]=1
						[[ -n "$array_comment_buffer" ]] && show_literal_comments["$norm"]="$array_comment_buffer"
						;;
					hide)
						hide_literals["$norm"]=1
						[[ -n "$array_comment_buffer" ]] && hide_literal_comments["$norm"]="$array_comment_buffer"
						;;
				esac
				array_comment_buffer=""
			fi

			((idx++))
			continue
		fi

		if [[ "$format" == "undetermined" ]]; then
			local no_ws="${line//[[:space:]]/}"
			if [[ -z "$no_ws" ]]; then
				((idx++))
				continue
			fi
			if [[ "$line" =~ ^[[:space:]]*# ]]; then
				state_passthrough_lines+=("$raw")
				((idx++))
				continue
			fi
			if [[ "$line" =~ ^ver[[:space:]]*=[[:space:]]*([0-9.]+)$ ]]; then
				state_version="ver=${BASH_REMATCH[1]}"
				format="inima"
				((idx++))
				continue
			fi
			if [[ "$line" =~ ^ver([0-9.]+)$ ]]; then
				state_version="ver=${BASH_REMATCH[1]}"
				format="inima"
				state_needs_migration=true
				((idx++))
				continue
			fi
			format="legacy"
		fi

		if [[ "$format" == "legacy" ]]; then
		case "$line" in
			default=*)
				local legacy_value="${line#default=}"
				legacy_value=${legacy_value//;/ }
				for token in $legacy_value; do
					process_default_token "$token"
				 done
				;;
				open_regex=*) load_regex_list "${line#open_regex=}" open_regexes ;;
				close_regex=*) load_regex_list "${line#close_regex=}" close_regexes ;;
				show_regex=*) load_regex_list "${line#show_regex=}" show_regexes ;;
				hide_regex=*) load_regex_list "${line#hide_regex=}" hide_regexes ;;
				open=*) load_literal_list "$base" "${line#open=}" open_literals open_regexes ;;
				close=*) load_literal_list "$base" "${line#close=}" close_literals close_regexes ;;
				show=*) load_show_list "$base" "${line#show=}" ;;
				hide=*) load_hide_list "$base" "${line#hide=}" ;;
				*) state_passthrough_lines+=("$raw") ;;
			esac
			((idx++))
			continue
		fi

		if [[ "$line" =~ ^[[:space:]]*# ]]; then
			state_passthrough_lines+=("$raw")
			((idx++))
			continue
		fi
		if [[ -z "${line//[[:space:]]/}" ]]; then
			((idx++))
			continue
		fi

		if [[ "$line" =~ ^([A-Za-z0-9_]+)[[:space:]]*=(.*)$ ]]; then
			local key="${BASH_REMATCH[1]}"
			local value="${BASH_REMATCH[2]}"
			if [[ ${value:0:1} == " " ]]; then
				value="${value:1}"
			fi
			local compact="${value//[[:space:]]/}"
			case "$key" in
				default)
					value=$(strip_trailing_space_tabs "$(strip_leading_space_tabs "$value")")
					if [[ "$compact" == "[" ]]; then
						current_array="default"
						collecting_unknown=0
						array_comment_buffer=""
					elif [[ "$value" =~ ^\[[^][]*\]$ ]]; then
						local inner="${value:1:-1}"
						parse_inline_default "$inner"
						state_needs_migration=true
					else
						value=${value//;/ }
						for token in $value; do
							process_default_token "$token"
						done
					fi
					;;
				open|close|show|hide)
					value=$(strip_trailing_space_tabs "$(strip_leading_space_tabs "$value")")
					if [[ "$compact" == "[" ]]; then
						current_array="$key"
						collecting_unknown=0
						array_comment_buffer=""
					elif [[ "$value" =~ ^\[[^][]*\]$ ]]; then
						local inner="${value:1:-1}"
						parse_inline_collection "$base" "$key" "$inner"
						state_needs_migration=true
					else
						state_passthrough_lines+=("$raw")
					fi
					;;
				*)
					if [[ "$compact" == "[" ]]; then
						current_array="$key"
						collecting_unknown=1
						unknown_buffer=("$raw")
					else
						state_passthrough_lines+=("$raw")
					fi
					;;
			esac
		else
			state_passthrough_lines+=("$raw")
		fi
		((idx++))
	done

	if [[ -n "$default_conflict" ]]; then
		echo "Error: $default_conflict" >&2
		exit 1
	fi

	if [[ "$format" == "legacy" ]]; then
		state_needs_migration=true
	else
		[[ "$state_version" != "$STATE_VERSION_LABEL" ]] && state_needs_migration=true
	fi
}

persist_state() {
	local target_dir="$1"; shift
	local state_file="$target_dir/.dirtree-state"
	local tmp_file
	tmp_file=$(mktemp "${state_file}.XXXXXX")

	{
		echo "$STATE_VERSION_LABEL"
		local wrote_block=false
		local default_entries=()
		if [[ "$default_state_set" == true ]]; then
			default_entries+=("$default_state")
		fi
		if [[ "$default_visibility_set" == true ]]; then
			default_entries+=("$default_visibility")
		fi
		if (( ${#default_entries[@]} == 0 )) && [[ -n "$default_state" ]]; then
			default_entries+=("$default_state")
		fi
		if (( ${#default_entries[@]} == 1 )); then
			echo "default=${default_entries[0]}"
			wrote_block=true
		elif (( ${#default_entries[@]} > 1 )); then
			echo "default=["
			for entry in "${default_entries[@]}"; do
				printf '\t%s\n' "$entry"
			done
			echo "]"
			wrote_block=true
		fi

		local -a entries=()
		local key

		entries=()
		for key in "${!open_literals[@]}"; do
			entries+=("$key")
		done
		for key in "${open_regexes[@]}"; do
			entries+=("/$key/")
		done
		if (( ${#entries[@]} > 0 )); then
			IFS=$'\n' entries=($(printf '%s\n' "${entries[@]}" | sort))
			if [[ "$wrote_block" == true ]]; then
				echo
			fi
			echo "open=["
			for key in "${entries[@]}"; do
				if [[ ${key:0:1} == "/" && ${key: -1} == "/" ]]; then
					if [[ -n "${open_regex_comments[$key]:-}" ]]; then
						printf '%s' "${open_regex_comments[$key]}"
					fi
				else
					if [[ -n "${open_literal_comments[$key]:-}" ]]; then
						printf '%s' "${open_literal_comments[$key]}"
					fi
				fi
				printf '\t%s\n' "$key"
			done
			echo "]"
			wrote_block=true
		fi

		entries=()
		for key in "${!close_literals[@]}"; do
			entries+=("$key")
		done
		for key in "${close_regexes[@]}"; do
			entries+=("/$key/")
		done
		if (( ${#entries[@]} > 0 )); then
			IFS=$'\n' entries=($(printf '%s\n' "${entries[@]}" | sort))
			if [[ "$wrote_block" == true ]]; then
				echo
			fi
			echo "close=["
			for key in "${entries[@]}"; do
				if [[ ${key:0:1} == "/" && ${key: -1} == "/" ]]; then
					if [[ -n "${close_regex_comments[$key]:-}" ]]; then
						printf '%s' "${close_regex_comments[$key]}"
					fi
				else
					if [[ -n "${close_literal_comments[$key]:-}" ]]; then
						printf '%s' "${close_literal_comments[$key]}"
					fi
				fi
				printf '\t%s\n' "$key"
			done
			echo "]"
			wrote_block=true
		fi

		entries=()
		for key in "${!show_literals[@]}"; do
			entries+=("$key")
		done
		for key in "${show_regexes[@]}"; do
			entries+=("/$key/")
		done
		if (( ${#entries[@]} > 0 )); then
			IFS=$'\n' entries=($(printf '%s\n' "${entries[@]}" | sort))
			if [[ "$wrote_block" == true ]]; then
				echo
			fi
			echo "show=["
			for key in "${entries[@]}"; do
				if [[ ${key:0:1} == "/" && ${key: -1} == "/" ]]; then
					if [[ -n "${show_regex_comments[$key]:-}" ]]; then
						printf '%s' "${show_regex_comments[$key]}"
					fi
				else
					if [[ -n "${show_literal_comments[$key]:-}" ]]; then
						printf '%s' "${show_literal_comments[$key]}"
					fi
				fi
				printf '\t%s\n' "$key"
			done
			echo "]"
			wrote_block=true
		fi

		entries=()
		for key in "${!hide_literals[@]}"; do
			entries+=("$key")
		done
		for key in "${hide_regexes[@]}"; do
			entries+=("/$key/")
		done
		if (( ${#entries[@]} > 0 )); then
			IFS=$'\n' entries=($(printf '%s\n' "${entries[@]}" | sort))
			if [[ "$wrote_block" == true ]]; then
				echo
			fi
			echo "hide=["
			for key in "${entries[@]}"; do
				if [[ ${key:0:1} == "/" && ${key: -1} == "/" ]]; then
					if [[ -n "${hide_regex_comments[$key]:-}" ]]; then
						printf '%s' "${hide_regex_comments[$key]}"
					fi
				else
					if [[ -n "${hide_literal_comments[$key]:-}" ]]; then
						printf '%s' "${hide_literal_comments[$key]}"
					fi
				fi
				printf '\t%s\n' "$key"
			done
			echo "]"
			wrote_block=true
		fi

		if (( ${#state_passthrough_lines[@]} > 0 )); then
			if [[ "$wrote_block" == true ]]; then
				echo
			fi
			printf '%s\n' "${state_passthrough_lines[@]}"
		fi
	} >"$tmp_file"

	mv -f "$tmp_file" "$state_file"
	state_needs_migration=false
}


dir_has_children() {
	local d=${1:-.}
	find "$d" -mindepth 1 -maxdepth 1 -print -quit >/dev/null 2>&1
}

path_state() {
	local rel="$1"
	open_match_type="none"
	open_match_pattern=""
	close_match_type="none"
	close_match_pattern=""
	show_match_type="none"
	show_match_pattern=""
	hide_match_type="none"
	hide_match_pattern=""

	if [[ -n "$rel" && -n "${open_literals[$rel]:-}" ]]; then
		open_match_type="literal"
		open_match_pattern="$rel"
	else
		for pattern in "${open_regexes[@]}"; do
			[[ -z "$pattern" ]] && continue
			if [[ "$rel" =~ $pattern ]]; then
				open_match_type="regex"
				open_match_pattern="$pattern"
				break
			fi
		done
	fi

	if [[ -n "$rel" && -n "${close_literals[$rel]:-}" ]]; then
		close_match_type="literal"
		close_match_pattern="$rel"
	else
		for pattern in "${close_regexes[@]}"; do
			[[ -z "$pattern" ]] && continue
			if [[ "$rel" =~ $pattern ]]; then
				close_match_type="regex"
				close_match_pattern="$pattern"
				break
			fi
		done
	fi

	if [[ -n "$rel" && -n "${show_literals[$rel]:-}" ]]; then
		show_match_type="literal"
		show_match_pattern="$rel"
	else
		for pattern in "${show_regexes[@]}"; do
			[[ -z "$pattern" ]] && continue
			if [[ "$rel" =~ $pattern ]]; then
				show_match_type="regex"
				show_match_pattern="$pattern"
				break
			fi
		done
	fi

	if [[ -n "$rel" && -n "${hide_literals[$rel]:-}" ]]; then
		hide_match_type="literal"
		hide_match_pattern="$rel"
	else
		for pattern in "${hide_regexes[@]}"; do
			[[ -z "$pattern" ]] && continue
			if [[ "$rel" =~ $pattern ]]; then
				hide_match_type="regex"
				hide_match_pattern="$pattern"
				break
			fi
		done
	fi
}

evaluate_path() {
	local rel="$1" parent_closed="$2"
	path_state "$rel"
	path_hidden=0

	local open_type="$open_match_type"
	local close_type="$close_match_type"
	local open_pat="$open_match_pattern"
	local close_pat="$close_match_pattern"
	local show_type="$show_match_type"
	local hide_type="$hide_match_type"
	local show_pat="$show_match_pattern"
	local hide_pat="$hide_match_pattern"

	if [[ "$show_hidden" == true ]]; then
		hide_type="none"
		hide_pat=""
	fi

	if [[ "$open_type" != "none" && "$close_type" != "none" ]]; then
		if [[ "$open_type" == "literal" && "$close_type" == "regex" ]]; then
			close_type="none"
			close_pat=""
		elif [[ "$open_type" == "regex" && "$close_type" == "literal" ]]; then
			open_type="none"
			open_pat=""
		else
			echo "Error: path '$rel' matches both open and close patterns" >&2
			[[ -n "$open_pat" ]] && echo "  open pattern: $open_pat" >&2
			[[ -n "$close_pat" ]] && echo "  close pattern: $close_pat" >&2
			exit 1
		fi
	fi

	if [[ "$show_type" != "none" && "$hide_type" != "none" ]]; then
		if [[ "$show_type" == "literal" && "$hide_type" == "regex" ]]; then
			hide_type="none"
			hide_pat=""
		elif [[ "$show_type" == "regex" && "$hide_type" == "literal" ]]; then
			show_type="none"
			show_pat=""
		else
			echo "Error: path '$rel' matches both show and hide patterns" >&2
			[[ -n "$show_pat" ]] && echo "  show pattern: $show_pat" >&2
			[[ -n "$hide_pat" ]] && echo "  hide pattern: $hide_pat" >&2
			exit 1
		fi
	fi

	if [[ "$show_hidden" == true ]]; then
		path_hidden=0
	elif [[ "$hide_type" != "none" ]]; then
		path_hidden=1
	elif [[ "$show_type" != "none" ]]; then
		path_hidden=0
	else
		path_hidden=0
	fi

	if [[ "$parent_closed" == "1" ]]; then
		path_closed=1
	elif [[ "$close_type" != "none" ]]; then
		path_closed=1
	elif [[ "$open_type" != "none" ]]; then
		path_closed=0
	elif [[ "$default_state" == "closed" ]]; then
		path_closed=1
	else
		path_closed=0
	fi
}

# Recursively print a simple tree (used for --simple mode)
print_simple_tree() {
	local base="$1" rel="$2" prefix="$3" depth_left="$4" parent_closed="$5"
	local abs
	if [[ -z "$rel" ]]; then abs="$base"; else abs="$base/$rel"; fi

	# List children sorted by name (including dotfiles, excluding . and ..)
	shopt -s dotglob nullglob
	local children=("$abs"/*)
	shopt -u dotglob
	# Convert to relative names
	local names=()
	local c
	for c in "${children[@]}"; do
		local name
		name=$(basename "$c")
		names+=("$name")
	done
	IFS=$'\n' names=($(printf '%s\n' "${names[@]}" | sort))
	unset IFS

	local count=${#names[@]}
	local i
	for ((i=0; i<count; i++)); do
		local name="${names[$i]}"
		local child_rel
		if [[ -n "$rel" ]]; then child_rel="$rel/$name"; else child_rel="$name"; fi
		local child_abs="$abs/$name"
		local is_last=$(( i == count-1 ))
		local connector="├── "
		local next_prefix="$prefix│   "
		if [[ $is_last -eq 1 ]]; then
			connector="└── "
			next_prefix="$prefix    "
		fi
		if [[ -d "$child_abs" ]]; then
			evaluate_path "$child_rel" "$parent_closed"
			if [[ $path_hidden -eq 1 ]]; then
				note_hidden dir
				continue
			fi
			local marker="/"
			local show_star=""
			if [[ $path_closed -eq 1 || $depth_left -le 1 ]]; then
				if dir_has_children "$child_abs"; then show_star="*"; fi
			fi
			echo "${prefix}${connector}${name}${marker}${show_star}"
			if [[ $path_closed -eq 0 && $depth_left -gt 1 ]]; then
				print_simple_tree "$base" "$child_rel" "$next_prefix" $((depth_left-1)) 0
			fi
		else
			evaluate_path "$child_rel" "$parent_closed"
			if [[ $path_hidden -eq 1 ]]; then
				note_hidden file
				continue
			fi
			echo "${prefix}${connector}${name}"
		fi
	done
}

# Append markers while preserving trailing ANSI resets and OSC8 terminators
append_with_marker() {
	local line="$1" marker="$2"
	local osc_close=$'\e]8;;'
	local st=$'\e\\'
	local trailing_hyper=""
	if [[ "$line" == *"$osc_close$st" ]]; then
		trailing_hyper="$osc_close$st"
		line="${line%$osc_close$st}"
	elif [[ "$line" == *"$st" ]]; then
		trailing_hyper="$st"
		line="${line%$st}"
	fi
	local trailing_color=""
	while [[ "$line" =~ (.*)(\x1b\[[0-9;]*m)$ ]]; do
		line="${BASH_REMATCH[1]}"
		trailing_color="${BASH_REMATCH[2]}${trailing_color}"
	done
	printf '%s' "${line}${marker}${trailing_color}${trailing_hyper}"
}

# Recursively render decorated output without traversing closed subtrees
render_dir() {
	local rel="$1" depth_left="$2" parent_closed="$3" prefix="$4"
	local abs
	if [[ -z "$rel" ]]; then abs="$abs_dir"; else abs="$abs_dir/$rel"; fi
	local eza_args=(--hyperlink --icons="${eza_icons}" --color="${eza_color}" --git --sort "${render_sort_field}" --all -1)
	if [[ "$render_sort_reverse" -eq 1 ]]; then
		eza_args+=(--reverse)
	fi
	local hp=$'\e]8;;file://'
	local st=$'\e\\'
	local lines=()
	local rels=()
	local targets=()
	local isdirs=()
	while IFS= read -r line; do
		local decoded_target=""
		if [[ "$line" == *"$hp"* ]]; then
			local rest="${line#*"$hp"}"
			local target="${rest%%"$st"*}"
			decoded_target=$(osc8_decode_path "$target")
		fi
		lines+=("$line")
		if [[ -n "$decoded_target" ]]; then
			local child_rel
			child_rel=$(normalize_rel "$abs_dir" "$decoded_target")
			rels+=("$child_rel")
			targets+=("$decoded_target")
			local is_dir_val=0
			if [[ -d "$decoded_target" ]]; then
				is_dir_val=1
			fi
			isdirs+=("$is_dir_val")
		else
			rels+=("")
			targets+=("")
			isdirs+=(0)
		fi
	done < <(eza "${eza_args[@]}" "$abs")

	local count=${#lines[@]}
	local -a visible_indices=()
	local -a cached_closed=()
	local idx
	for ((idx=0; idx<count; idx++)); do
		local child_rel="${rels[$idx]}"
		local target="${targets[$idx]}"
		if [[ -z "$child_rel" ]]; then
			rels[$idx]="$child_rel"
			if [[ -n "$target" ]]; then
				targets[$idx]="$target"
			else
				if [[ -n "$child_rel" ]]; then
					targets[$idx]="$abs/$child_rel"
				else
					targets[$idx]="$abs"
				fi
			fi
		fi
		if [[ -n "$child_rel" && "$child_rel" != "." && "$child_rel" != ".." ]]; then
			evaluate_path "$child_rel" "$parent_closed"
			cached_closed[$idx]=$path_closed
			if [[ $path_hidden -eq 1 ]]; then
				if [[ "${isdirs[$idx]}" -eq 1 ]]; then
					note_hidden dir
				else
					note_hidden file
				fi
				continue
			fi
		else
			cached_closed[$idx]=0
		fi
		visible_indices+=("$idx")
	done

	local visible_count=${#visible_indices[@]}
	local pos
	for ((pos=0; pos<visible_count; pos++)); do
		idx=${visible_indices[$pos]}
		local line="${lines[$idx]}"
		local child_rel="${rels[$idx]}"
		local target="${targets[$idx]}"
		local is_dir="${isdirs[$idx]}"
		local path_closed_val=${cached_closed[$idx]:-0}
		if [[ -z "$target" && -n "$child_rel" ]]; then
			target="$abs/$child_rel"
		fi
		local is_last=0
		if (( pos == visible_count-1 )); then
			is_last=1
		fi
		local connector="├── "
		local next_prefix="${prefix}│   "
		if (( is_last )); then
			connector="└── "
			next_prefix="${prefix}    "
		fi
		if [[ -n "$child_rel" && "$child_rel" != "." && "$child_rel" != ".." && "$is_dir" -eq 1 ]]; then
			local marker="/"
			if (( path_closed_val == 1 )); then
				if [[ -n "$target" ]] && dir_has_children "$target"; then
					marker="/*"
				fi
			fi
			line=$(append_with_marker "$line" "$marker")
			printf '%s%s%s\n' "$prefix" "$connector" "$line"
			if (( path_closed_val == 0 && depth_left > 1 )); then
				render_dir "$child_rel" $((depth_left-1)) "$path_closed_val" "$next_prefix"
			fi
		else
			printf '%s%s%s\n' "$prefix" "$connector" "$line"
		fi
	done
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
	case "$1" in
		-h|--help)
			show_help
			exit 0
			;;
		-a|--about)
			echo "Stateful eza tree (icons/colors/links); --simple for LLMs; persists .dirtree-state (default/open/close/show/hide); regex via /pattern/; literals must be relative; env: DIRTREE_{SIMPLE,DECORATED,AUTO_SIMPLE}."
			exit 0
			;;
		-d|--depth)
			shift
			if [[ -n "$1" && "$1" =~ ^[0-9]+$ ]]; then
				depth="$1"
			else
				echo "Error: --depth requires a numeric argument" >&2
				exit 1
			fi
			;;
		--simple)
			simple_mode=true
			;;
		--llm)
			simple_mode=true
			;;
		--decorated)
			force_decorated=true
			;;
			--default)
				shift
				collected=()
				while [[ $# -gt 0 && "$1" != --* && "$1" != -* ]]; do
					if [[ "$dir_pending" == true && $# -eq 1 && ${#collected[@]} -gt 0 ]]; then
						local_candidate="${1,,}"
						case "$local_candidate" in
							open|opened|close|closed|show|shown|hide|hidden) ;;
							*) break ;;
						esac
					fi
					collected+=("$1")
					shift
				done
				if [[ ${#collected[@]} -eq 0 ]]; then
					echo "Error: --default requires at least one value" >&2
					exit 1
				fi
				for token in "${collected[@]}"; do
					local_token="${token,,}"
					case "$local_token" in
						open|opened)
							if [[ -n "$cli_default_state" && "$cli_default_state" != "opened" ]]; then
								echo "Error: --default state conflict between '$cli_default_state' and '$token'" >&2
								exit 1
							fi
							cli_default_state="opened"
							;;
						close|closed)
							if [[ -n "$cli_default_state" && "$cli_default_state" != "closed" ]]; then
								echo "Error: --default state conflict between '$cli_default_state' and '$token'" >&2
								exit 1
							fi
							cli_default_state="closed"
							;;
						show|shown)
							if [[ -n "$cli_default_visibility" && "$cli_default_visibility" != "shown" ]]; then
								echo "Error: --default visibility conflict between '$cli_default_visibility' and '$token'" >&2
								exit 1
							fi
							cli_default_visibility="shown"
							;;
						hide|hidden)
							if [[ -n "$cli_default_visibility" && "$cli_default_visibility" != "hidden" ]]; then
								echo "Error: --default visibility conflict between '$cli_default_visibility' and '$token'" >&2
								exit 1
							fi
							cli_default_visibility="hidden"
							;;
						*)
							echo "Error: --default accepts opened/closed/shown/hidden" >&2
							exit 1
							;;
						esac
					done
				state_modified=true
				unset collected
				continue
				;;
			--sort)
				shift
				case "$1" in
					alpha|modified) sort_mode="$1" ;;
					*) echo "Error: --sort requires 'modified' or 'alpha'" >&2; exit 1 ;;
				esac
				;;
			--asc)
				sort_reverse=0
				;;
			--desc)
				sort_reverse=1
				;;
			--show-hidden)
				show_hidden=true
				;;
			-o|--open)
				shift
				collected=()
				while [[ $# -gt 0 && "$1" != --* && "$1" != -* ]]; do
					if [[ "$dir_pending" == true && $# -eq 1 && ${#collected[@]} -gt 0 ]]; then
						break
					fi
					collected+=("$1")
					shift
				done
				if [[ ${#collected[@]} -eq 0 ]]; then
					echo "Error: --open requires at least one directory" >&2
					exit 1
				fi
		for entry in "${collected[@]}"; do
			if [[ "$entry" == /* && "$entry" == */ ]]; then
				if (( ${#entry} <= 2 )); then
					echo "Error: --open regex pattern must not be empty" >&2
					exit 1
				fi
				pattern_val="${entry:1:-1}"
						open_regex_args+=("$pattern_val")
					else
						open_args+=("$entry")
					fi
					done
				state_modified=true
				unset collected
				continue
				;;
			-c|--close)
				shift
				collected=()
				while [[ $# -gt 0 && "$1" != --* && "$1" != -* ]]; do
					if [[ "$dir_pending" == true && $# -eq 1 && ${#collected[@]} -gt 0 ]]; then
						break
					fi
					collected+=("$1")
					shift
				done
				if [[ ${#collected[@]} -eq 0 ]]; then
					echo "Error: --close requires at least one directory" >&2
					exit 1
				fi
		for entry in "${collected[@]}"; do
			if [[ "$entry" == /* && "$entry" == */ ]]; then
				if (( ${#entry} <= 2 )); then
					echo "Error: --close regex pattern must not be empty" >&2
					exit 1
				fi
				pattern_val="${entry:1:-1}"
						close_regex_args+=("$pattern_val")
					else
						close_args+=("$entry")
					fi
					done
				state_modified=true
				unset collected
				continue
				;;
			--show)
				shift
				collected=()
				while [[ $# -gt 0 && "$1" != --* && "$1" != -* ]]; do
					if [[ "$dir_pending" == true && $# -eq 1 && ${#collected[@]} -gt 0 ]]; then
						break
					fi
					collected+=("$1")
					shift
					done
				if [[ ${#collected[@]} -eq 0 ]]; then
					echo "Error: --show requires at least one path" >&2
					exit 1
				fi
		for entry in "${collected[@]}"; do
			if [[ "$entry" == /* && "$entry" == */ ]]; then
				if (( ${#entry} <= 2 )); then
					echo "Error: --show regex pattern must not be empty" >&2
					exit 1
				fi
						pattern_val="${entry:1:-1}"
						show_regex_args+=("$pattern_val")
					else
						if [[ "$entry" == /* ]]; then
							echo "Error: --show paths must be relative (no leading '/'): $entry" >&2
							exit 1
						fi
						show_args+=("$entry")
					fi
					done
				state_modified=true
				unset collected
				continue
				;;
			--hide)
				shift
				collected=()
				while [[ $# -gt 0 && "$1" != --* && "$1" != -* ]]; do
					if [[ "$dir_pending" == true && $# -eq 1 && ${#collected[@]} -gt 0 ]]; then
						break
					fi
					collected+=("$1")
					shift
				done
				if [[ ${#collected[@]} -eq 0 ]]; then
					echo "Error: --hide requires at least one path" >&2
					exit 1
				fi
		for entry in "${collected[@]}"; do
			if [[ "$entry" == /* && "$entry" == */ ]]; then
				if (( ${#entry} <= 2 )); then
					echo "Error: --hide regex pattern must not be empty" >&2
					exit 1
				fi
						pattern_val="${entry:1:-1}"
						hide_regex_args+=("$pattern_val")
					else
						if [[ "$entry" == /* ]]; then
							echo "Error: --hide paths must be relative (no leading '/'): $entry" >&2
							exit 1
						fi
						hide_args+=("$entry")
					fi
					done
				state_modified=true
				unset collected
				continue
				;;
		--test)
			if [[ -x "$(dirname "$0")/test/dirtree_test" ]]; then
				"$(dirname "$0")/test/dirtree_test" >/dev/null
			else
				echo "Error: dirtree_test not found or not executable." >&2
				exit 1
			fi
			exit $?
			;;
		-*)
			echo "Unknown option: $1" >&2
			exit 1
			;;
		*)
			# This is the directory argument
			dir="$1"
			dir_pending=false
			break
			;;
	esac
	shift
done

# Validate directory exists
if [[ ! -d "$dir" ]]; then
	echo "Error: '$dir' is not a directory" >&2
	exit 1
fi

# Absolute path for rendering
abs_dir=$(cd "$dir" && pwd -P)

# Load and possibly update state
read_state "$dir"

# Apply CLI default after loading persisted state so it isn't overwritten
if [[ -n "$cli_default_state" ]]; then
	default_state="$cli_default_state"
	default_state_set=true
fi
if [[ -n "$cli_default_visibility" ]]; then
	default_visibility="$cli_default_visibility"
	default_visibility_set=true
fi

# Apply CLI open/close mutations if any
for pattern in "${open_regex_args[@]}"; do
	append_unique_regex open_regexes "$pattern"
done
for pattern in "${close_regex_args[@]}"; do
	append_unique_regex close_regexes "$pattern"
done
for pattern in "${show_regex_args[@]}"; do
	append_unique_regex show_regexes "$pattern"
done
for pattern in "${hide_regex_args[@]}"; do
	append_unique_regex hide_regexes "$pattern"
done

for p in "${open_args[@]}"; do
	p=$(normalize_rel "$dir" "$p")
	[[ -z "$p" ]] && continue
	if [[ -d "$dir/$p" ]]; then
		open_literals["$p"]=1
		unset 'close_literals[$p]'
	else
		echo "Warning: open target not a directory: $p" >&2
	fi
done
for p in "${close_args[@]}"; do
	p=$(normalize_rel "$dir" "$p")
	[[ -z "$p" ]] && continue
	if [[ -d "$dir/$p" ]]; then
		close_literals["$p"]=1
		unset 'open_literals[$p]'
	else
		echo "Warning: close target not a directory: $p" >&2
	fi
done
for p in "${show_args[@]}"; do
	p=$(normalize_rel "$dir" "$p")
	[[ -z "$p" ]] && continue
	show_literals["$p"]=1
	unset 'hide_literals[$p]'
done
for p in "${hide_args[@]}"; do
	p=$(normalize_rel "$dir" "$p")
	[[ -z "$p" ]] && continue
	hide_literals["$p"]=1
	unset 'show_literals[$p]'
done

if [[ "$state_modified" == true || "$state_needs_migration" == true ]]; then
	persist_state "$dir"
fi

case "$sort_mode" in
	alpha) render_sort_field="name" ;;
	*) render_sort_field="modified" ;;
esac
render_sort_reverse="$sort_reverse"

# Determine mode if not explicitly forced
if [[ "$force_decorated" == false ]]; then
	if [[ "$simple_mode" != true ]]; then
		if [[ -n "${DIRTREE_SIMPLE:-}" ]]; then
			simple_mode=true
		elif [[ -n "${DIRTREE_DECORATED:-}" ]]; then
			simple_mode=false
		elif [[ -n "${DIRTREE_AUTO_SIMPLE:-}" ]]; then
			# Auto: enable simple when stdout is not a TTY
			if [[ ! -t 1 ]]; then
				simple_mode=true
			fi
		fi
	fi
fi

hidden_count_log=$(mktemp)

if [[ "$simple_mode" == true ]]; then
	# Print stateful simple tree without leading top-level connectors or root line
	status=0
	(
		set -o pipefail
		{
			print_simple_tree "$dir" "" "" "$depth" 0
		} |
		{
			ESC=$'\e'
			sed -E "s/^(${ESC}\\[[0-9;]*m)*(├──|└──)[[:space:]]+//; s/^(${ESC}\\[[0-9;]*m)*│[[:space:]][[:space:]][[:space:]]//"
		}
	) || status=$?
	report_hidden_counts
	if [[ -n "$hidden_count_log" ]]; then
		rm -f "$hidden_count_log"
		hidden_count_log=""
	fi
	exit $status
fi

# For decorated mode, ensure eza is available
if ! command -v eza >/dev/null 2>&1; then
	if [[ -n "$hidden_count_log" ]]; then
		rm -f "$hidden_count_log"
		hidden_count_log=""
	fi
	echo "Error: eza is not installed. Please install eza first." >&2
	exit 1
fi

# Decide eza presentation based on TTY. When stdout is not a TTY (e.g. piped to
# a pager like `more`), disable color/icons/hyperlinks to avoid line wrapping or
# truncation issues in basic pagers.
eza_color="always"
eza_icons="always"
strip_osc8=false
if [[ ! -t 1 && "$force_decorated" == false && "$simple_mode" != true ]]; then
	eza_color="never"
	eza_icons="never"
	strip_osc8=true
fi

# Run renderer with optional OSC8 stripping
status=0
if $strip_osc8; then
	(
		set -o pipefail
		ESC=$'\e'
		render_dir "" "$depth" 0 "" | sed -E "s/${ESC}]8;;[^${ESC}]*${ESC}\\\\//g"
	) || status=$?
else
	render_dir "" "$depth" 0 ""
	status=$?
fi

report_hidden_counts
if [[ -n "$hidden_count_log" ]]; then
	rm -f "$hidden_count_log"
	hidden_count_log=""
fi

exit $status
