#!/usr/bin/env bash

confirm() {
	[ -n "${EDIT}" ] && unset EDIT && edit_function "${FUNCNAME[0]}" "$BASH_SOURCE" && return
	if [[ "$1" == "-h" || "$1" == "--help" ]]; then
		echo "Usage: confirm"
		echo
		echo "The idea here is to use this as a pipe in situations where you want to confirm before running code,"
		echo "like so:"
		echo " echo \"some code\" | confirm | ssh user@host"
		echo "or"
		echo " curl \"some URL with raw code\" | confirm | bash"
		return 0
	fi

	[ -n "${EDIT}" ] && unset EDIT && edit_function "${FUNCNAME[0]}" "$BASH_SOURCE" && return
	tmpfile=$(mktemp --tmpdir)
	# use tee to split stdin to stderr and the temporary file
	tee "$tmpfile" >&2
	echo >&2
	# Prompt the user.
	>&2 read -p "Do you want to pass this code along? [Y/n] " response < /dev/tty
	case "$response" in
		[nN]*)
			echo "Operation cancelled." >&2
			rm "$tmpfile"
			return 1
			;;
		*)
			echo "Proceeding..." >&2
			cat "$tmpfile"
			rm "$tmpfile"
			;;
	esac
}

# Run the function, passing along any args, if this file was run directly (such as via sudo) instead of as an include
# Sometimes, $0 contains a leading dash to indicate an interactive (or is it login?) shell,
# which is apparently an old convention (which also broke the basename call on OS X)
_me=$(basename "${0##\-}")
if [ "$_me" = "confirm" ]; then
	# Run the function if this script is executed directly
	if ! (return 0 2>/dev/null); then
		# Check if we are running tests
		if [ "$1" = "--test" ]; then
			# Run tests from the test file
			exec "$HOME/dotfiles/bin/test/$(basename "${0##\-}")_test"
		else
			# If called directly, pass all arguments to the function
			$_me "$@"
		fi
	fi
fi
