#!/usr/bin/env bash

_encrypt_expand_path() {
	local path="$1"
	if [[ -z "$path" ]]; then
		return
	fi
	case "$path" in
		~)
			printf '%s\n' "$HOME"
			;;
		~/|~/*)
			printf '%s/%s\n' "$HOME" "${path#~/}"
			;;
		*)
			printf '%s\n' "$path"
			;;
	esac
}

_encrypt_boolean() {
	local val="$1"
	if [[ -z "$val" ]]; then
		return 1
	fi
	case "${val,,}" in
		1|true|yes|y)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

_test_encrypt_decrypt() {
	local test_string="This is a test string with special chars: !@#\$%^&*()_+"
	local test_password="testpassword123"
	local temp_file
	temp_file=$(mktemp --tmpdir)

	echo -e "\n${ANSI}${TXTYLW}Running encryption/decryption test...${ANSI}${TXTRST}"

	# Test string encryption/decryption (symmetric)
	echo -e "${ANSI}${TXTYLW}Test 1: Symmetric string encryption/decryption${ANSI}${TXTRST}"
	local encrypted
	local decrypted

	encrypted=$(echo -n "$test_string" | encrypt -i - -o - -p "$test_password" 2>/dev/null | base64)
	if [[ $? -ne 0 ]]; then
		echo -e "${ANSI}${TXTRED}✗ Symmetric encryption failed${ANSI}${TXTRST}"
		rm -f "$temp_file"
		return 1
	fi

	decrypted=$(echo -n "$encrypted" | base64 -d | decrypt -i - -o - -p "$test_password" 2>/dev/null)
	if [[ $? -ne 0 ]]; then
		echo -e "${ANSI}${TXTRED}✗ Symmetric decryption failed${ANSI}${TXTRST}"
		rm -f "$temp_file"
		return 1
	fi

	if [[ "$decrypted" == "$test_string" ]]; then
		echo -e "${ANSI}${TXTGRN}✓ Symmetric string encryption/decryption test passed${ANSI}${TXTRST}"
	else
		echo -e "${ANSI}${TXTRED}✗ Symmetric string encryption/decryption test failed${ANSI}${TXTRST}"
		echo "Expected: $test_string"
		echo "Got: $decrypted"
		rm -f "$temp_file"
		return 1
	fi

	# Test file encryption/decryption (symmetric)
	echo -e "${ANSI}${TXTYLW}Test 2: Symmetric file encryption/decryption${ANSI}${TXTRST}"
	echo -n "$test_string" > "$temp_file"

	encrypt -i "$temp_file" -o "$temp_file.gpg" -p "$test_password" >/dev/null 2>&1
	if [[ $? -ne 0 ]]; then
		echo -e "${ANSI}${TXTRED}✗ Symmetric file encryption failed${ANSI}${TXTRST}"
		rm -f "$temp_file" "$temp_file.gpg"
		return 1
	fi

	decrypted=$(decrypt -i "$temp_file.gpg" -o - -p "$test_password" 2>/dev/null)
	if [[ $? -ne 0 ]]; then
		echo -e "${ANSI}${TXTRED}✗ Symmetric file decryption failed${ANSI}${TXTRST}"
		rm -f "$temp_file" "$temp_file.gpg"
		return 1
	fi

	if [[ "$decrypted" == "$test_string" ]]; then
		echo -e "${ANSI}${TXTGRN}✓ Symmetric file encryption/decryption test passed${ANSI}${TXTRST}"
	else
		echo -e "${ANSI}${TXTRED}✗ Symmetric file encryption/decryption test failed${ANSI}${TXTRST}"
		echo "Expected: $test_string"
		echo "Got: $decrypted"
		rm -f "$temp_file" "$temp_file.gpg"
		return 1
	fi

	# Test asymmetric encryption/decryption via rage
	echo -e "${ANSI}${TXTYLW}Test 3: Asymmetric (rage) round-trip${ANSI}${TXTRST}"
	local key_dir
	key_dir=$(mktemp --tmpdir -d encrypt_test_keys.XXXXXX)
	local key_path="$key_dir/testkey"
	if ! ssh-keygen -t ed25519 -N "" -f "$key_path" >/dev/null 2>&1; then
		echo -e "${ANSI}${TXTRED}✗ Failed to create temporary test key${ANSI}${TXTRST}"
		rm -rf "$key_dir" "$temp_file" "$temp_file.gpg"
		return 1
	fi

	local asym_encrypted
	asym_encrypted=$(ENCRYPT_IDENTITY="$key_path" ENCRYPT_ASSUME_YES=1 encrypt --asymmetric -s "$test_string" -o - 2>/dev/null | base64)
	if [[ $? -ne 0 ]]; then
		echo -e "${ANSI}${TXTRED}✗ Asymmetric encryption failed${ANSI}${TXTRST}"
		rm -rf "$key_dir"
		rm -f "$temp_file" "$temp_file.gpg"
		return 1
	fi

	local asym_decrypted
	asym_decrypted=$(echo -n "$asym_encrypted" | base64 -d | DECRYPT_IDENTITY="$key_path" DECRYPT_ASSUME_YES=1 decrypt --asymmetric -i - -o - 2>/dev/null)
	if [[ $? -ne 0 ]]; then
		echo -e "${ANSI}${TXTRED}✗ Asymmetric decryption failed${ANSI}${TXTRST}"
		rm -rf "$key_dir"
		rm -f "$temp_file" "$temp_file.gpg"
		return 1
	fi

	if [[ "$asym_decrypted" == "$test_string" ]]; then
		echo -e "${ANSI}${TXTGRN}✓ Asymmetric encryption/decryption test passed${ANSI}${TXTRST}"
	else
		echo -e "${ANSI}${TXTRED}✗ Asymmetric encryption/decryption test failed${ANSI}${TXTRST}"
		echo "Expected: $test_string"
		echo "Got: $asym_decrypted"
		rm -rf "$key_dir"
		rm -f "$temp_file" "$temp_file.gpg"
		return 1
	fi

	rm -rf "$key_dir"
	rm -f "$temp_file" "$temp_file.gpg"
	echo -e "${ANSI}${TXTGRN}All tests passed successfully!${ANSI}${TXTRST}"
	return 0
}

encrypt() {
	[ -n "${EDIT}" ] && unset EDIT && edit_function "${FUNCNAME[0]}" "$BASH_SOURCE" && return

	# Check for test mode early
	if [[ "$1" == "--test" ]]; then
		_test_encrypt_decrypt
		return $?
	fi

	local input_file=""
	local output_file=""
	local input_string=""
	local password=""
	local passthrough_args=()
	local use_stdin=false
	local use_stdout=false
	local use_string=false
	local use_password=false
	local mode="symmetric"
	local default_identity="$HOME/.ssh/id_ed25519"
	local identity_path="${ENCRYPT_IDENTITY:-${ENCRYPT_PRIVATE_KEY:-}}"
	local identity_explicit=false
	[[ -n "$identity_path" ]] && identity_explicit=true
	local recipient_spec="${ENCRYPT_RECIPIENT:-}"
	local assume_yes_env="${ENCRYPT_ASSUME_YES:-}"
	local assume_yes=false
	_encrypt_boolean "$assume_yes_env" && assume_yes=true

	# Show help if no arguments
	if [[ $# -eq 0 ]]; then
		encrypt --help
		return
	fi

	while [[ $# -gt 0 ]]; do
		case "$1" in
			-h|--help)
				echo 'Usage: encrypt [-i input|-] [-o output|-] [-- <additional gpg/rage options>]'
				echo '       encrypt -s "string" [-o output|-] [-- <additional options>]'
				echo '       encrypt --asymmetric [options]'
				echo '       encrypt --test'
				echo "This function is defined in ${BASH_SOURCE[0]}"
				echo 'Options:'
				echo '  -i, --input <file>     Input file to encrypt (use - for stdin)'
				echo '  -s, --string <text>    Text string to encrypt'
				echo '  -o, --output <file>    Output file (use - for stdout)'
				echo '  -p, --password <pw>    Passphrase for symmetric GnuPG mode'
				echo '  --asymmetric           Use rage public-key mode (default is symmetric)'
				echo '  --symmetric            Force GnuPG symmetric mode'
				echo '  --identity <path>      Private key/identity for asymmetric mode (default ~/.ssh/id_ed25519)'
				echo '  --recipient <value>    Recipient (ssh public key, age1..., or recipients file) for asymmetric mode'
				echo '  -y, --yes              Skip confirmation when using default identity'
				echo '  --                     Pass remaining args directly to gpg (symmetric) or rage (asymmetric)'
				echo 'Environment:'
				echo '  ENCRYPT_IDENTITY / ENCRYPT_PRIVATE_KEY   Default identity path for asymmetric mode'
				echo '  ENCRYPT_RECIPIENT                        Default recipient (string or path)'
				echo '  ENCRYPT_ASSUME_YES                       If truthy, skip confirmation prompt'
				echo 'Examples:'
				echo '  encrypt -i secret.txt                      # Symmetric encrypts to secret.txt.gpg'
				echo '  encrypt --asymmetric -i secret.txt         # Encrypts with rage to secret.txt.age'
				echo '  encrypt --asymmetric -s "secret" -o out.age -y'
				echo '  ENCRYPT_IDENTITY=~/.ssh/other encrypt --asymmetric -i file'
				return
				;;
			-i|--input)
				if [[ $# -lt 2 ]]; then
					echo "Error: -i/--input option requires a file or -" >&2
					return 1
				fi
				input_file="$2"
				if [[ "$input_file" == "-" ]]; then
					use_stdin=true
					input_file=""
				fi
				shift 2
				;;
			-s|--string)
				if [[ $# -lt 2 ]]; then
					echo "Error: -s/--string option requires a text string" >&2
					return 1
				fi
				input_string="$2"
				use_string=true
				shift 2
				;;
			-o|--output)
				if [[ $# -lt 2 ]]; then
					echo "Error: -o/--output option requires a file or -" >&2
					return 1
				fi
				output_file="$2"
				if [[ "$output_file" == "-" ]]; then
					use_stdout=true
					output_file=""
				fi
				shift 2
				;;
			-p|--password)
				if [[ $# -lt 2 ]]; then
					echo "Error: -p/--password option requires a password" >&2
					return 1
				fi
				password="$2"
				use_password=true
				shift 2
				;;
			--asymmetric|--rage|--public-key|--age)
				mode="asymmetric"
				shift
				;;
			--symmetric)
				mode="symmetric"
				shift
				;;
			--identity)
				if [[ $# -lt 2 ]]; then
					echo "Error: --identity requires a path" >&2
					return 1
				fi
				identity_path="$2"
				identity_explicit=true
				shift 2
				;;
			--recipient)
				if [[ $# -lt 2 ]]; then
					echo "Error: --recipient requires a value or path" >&2
					return 1
				fi
				recipient_spec="$2"
				shift 2
				;;
			-y|--yes|--assume-yes|--no-confirm)
				assume_yes=true
				shift
				;;
			--)
				shift
				passthrough_args+=("$@")
				break
				;;
			*)
				if [[ -z "$input_file" && ! "$1" =~ ^- ]]; then
					input_file="$1"
				else
					passthrough_args+=("$1")
				fi
				shift
				;;
		esac
	done

	if [[ "$mode" != "symmetric" ]]; then
		mode="asymmetric"
	fi

	if [[ "$mode" == "symmetric" && -n "$recipient_spec" ]]; then
		echo "Error: --recipient is only valid in asymmetric mode" >&2
		return 1
	fi

	if [[ "$mode" == "asymmetric" && "$use_password" == true ]]; then
		echo "Error: --password is not supported in asymmetric mode" >&2
		return 1
	fi

	local cmd=()
	local cleanup_recipient_file=""

	if [[ "$mode" == "symmetric" ]]; then
		needs gpg "please install gnupg for symmetric encryption"
		cmd=(gpg --symmetric -z 9 --require-secmem --cipher-algo AES256 --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-mode 3 --s2k-count 65000000 --compress-algo BZIP2)
		if [[ "$use_password" == true ]]; then
			cmd+=(--batch --passphrase "$password")
		fi
		if [[ -n "$output_file" ]]; then
			cmd+=(-o "$output_file")
		fi
	else
		needs rage "install rage (age) for asymmetric mode"
		local identity_src="$identity_path"
		if [[ -z "$identity_src" ]]; then
			identity_src="$default_identity"
		fi
		identity_src=$(_encrypt_expand_path "$identity_src")
		if [[ ! -f "$identity_src" ]]; then
			echo "Error: identity file not found at $identity_src" >&2
			return 1
		fi
		local prompt_needed=false
		if [[ "$identity_explicit" == false ]]; then
			prompt_needed=true
		fi
		if [[ "$prompt_needed" == true && "$assume_yes" == false ]]; then
			if [[ -t 0 || -t 1 || -t 2 ]]; then
				local reply=""
				if ! read -r -p "Use $identity_src for asymmetric encryption? [Y/n] " reply </dev/tty; then
					echo "Error: unable to read confirmation" >&2
					return 1
				fi
				case "${reply,,}" in
					""|y|yes)
						;;
					*)
						echo "Aborted at user request." >&2
						return 1
						;;
				esac
			else
				echo "Refusing to use default identity without confirmation; re-run with --yes or ENCRYPT_ASSUME_YES=1" >&2
				return 1
			fi
		fi

		local -a recipient_flags=()
		local recipient_display=""
		if [[ -n "$recipient_spec" ]]; then
			local expanded_recipient="$recipient_spec"
			expanded_recipient=$(_encrypt_expand_path "$expanded_recipient")
			if [[ -f "$expanded_recipient" ]]; then
				recipient_flags=(-R "$expanded_recipient")
				recipient_display="recipients file: $expanded_recipient"
			else
				recipient_flags=(-r "$recipient_spec")
				recipient_display="recipient supplied via --recipient"
			fi
		else
			local pub_path="${identity_src}.pub"
			if [[ -f "$pub_path" ]]; then
				recipient_flags=(-R "$pub_path")
				recipient_display="public key file: $pub_path"
			else
				needs ssh-keygen "ssh-keygen is required to derive a public key from $identity_src"
				local derived_key
				if ! derived_key=$(ssh-keygen -y -f "$identity_src" 2>/dev/null); then
					echo "Error: could not derive public key from $identity_src" >&2
					return 1
				fi
				cleanup_recipient_file=$(mktemp --tmpdir encrypt_recipient.XXXXXX)
				printf '%s\n' "$derived_key" > "$cleanup_recipient_file"
				recipient_flags=(-R "$cleanup_recipient_file")
				recipient_display="derived recipient written to $cleanup_recipient_file"
			fi
		fi

		if [[ ${#recipient_flags[@]} -eq 0 ]]; then
			echo "Error: no recipient available for asymmetric mode" >&2
			[[ -n "$cleanup_recipient_file" ]] && rm -f "$cleanup_recipient_file"
			return 1
		fi

		cmd=(rage --encrypt)
		cmd+=("${recipient_flags[@]}")
		if [[ -z "$output_file" && "$use_stdout" == false && "$use_stdin" == false && "$use_string" == false && -n "$input_file" ]]; then
			output_file="${input_file}.age"
		fi
		if [[ -n "$output_file" ]]; then
			cmd+=(-o "$output_file")
		fi
		if [[ -n "$recipient_display" ]]; then
			>&2 echo -e "${ANSI}${TXTYLW}Using ${recipient_display}${ANSI}${TXTRST}"
		fi
		>&2 echo -e "${ANSI}${TXTYLW}Identity: $identity_src${ANSI}${TXTRST}"
	fi

	if [[ ${#passthrough_args[@]} -gt 0 ]]; then
		cmd+=("${passthrough_args[@]}")
	fi

	if [[ -n "$input_file" && "$use_stdin" == false && "$use_string" == false ]]; then
		cmd+=("$input_file")
	fi

	local cmd_display=("${cmd[@]}")
	if [[ "$mode" == "symmetric" && "$use_password" == true ]]; then
		for i in "${!cmd_display[@]}"; do
			if [[ "${cmd_display[$i]}" == "--passphrase" ]]; then
				cmd_display[$((i+1))]="******"
			fi
		done
	fi
	>&2 echo -e "${ANSI}${TXTYLW}${cmd_display[*]}${ANSI}${TXTRST}"

	local exit_code=0
	if [[ "$use_string" == true ]]; then
		echo -n "$input_string" | "${cmd[@]}"
		exit_code=$?
	elif [[ "$use_stdin" == true ]]; then
		"${cmd[@]}"
		exit_code=$?
	else
		"${cmd[@]}"
		exit_code=$?
	fi

	if [[ -n "$cleanup_recipient_file" ]]; then
		rm -f "$cleanup_recipient_file"
	fi

	return $exit_code
}

if ! (return 0 2>/dev/null); then
	if [ "$1" = "--test" ]; then
		. "$HOME/dotfiles/bin/test/$(basename "${0##\-}")_test"
	else
		$(basename "${0##\-}") "$@"
	fi
fi
