#!/usr/bin/env bash

# Enable strict mode- disabled for now pending future effort because it silently broke things
# set -euo pipefail

IFS=$'\n\t'

# Get number of CPU cores based on OS
get_cpu_cores() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sysctl -n hw.ncpu
    else
        nproc
    fi
}

# Set number of par2 threads, allowing override via environment variable
: "${NUM_PAR2_THREADS:=$(get_cpu_cores)}"

# Par2 redundancy percentage (5 means 5% extra data for recovery)
PAR2_REDUNDANCY=${PAR2_REDUNDANCY:-5}

# Warn if redundancy is set too high
if ((PAR2_REDUNDANCY > 20)); then
    echo "Warning: PAR2_REDUNDANCY is set to ${PAR2_REDUNDANCY}%. This tool is designed for protecting against small corruptions (bitrot, sector failures) and not for full file recovery. Consider using a lower value (5-20%) to save space." >&2
fi

check_dependencies() {
	local dependencies=(gtouch gstat sed)
	local missing=()
	for dep in "${dependencies[@]}"
	do
		if ! command -v "$dep" &> /dev/null
		then
			missing+=("$dep")
		fi
	done
	if ! sed --help | grep -q "GNU sed"
	then
		missing+=("GNU sed")
	fi
	if [[ "${#missing[@]}" > 0 ]]
	then
		printf "Missing dependencies: %s\n" "${missing[*]}"
		exit 1
	fi
}

check_dependencies

# Utility function to sanitize filenames for par2
sanitize_filename() {
	local filename="$1"
	# Replace wildcards, question marks, and other problematic characters with underscores
	echo "$filename" | sed -E 's/[*?]/_/g; s/:/_/g; s/\\/_/g'
}

# Utility function to get corresponding par2 path
get_par2_path() {
	local orig_path="$1"
	local base_dir=$(dirname "$orig_path")
	local base_name=$(basename "$orig_path")
	local sanitized_name=$(sanitize_filename "$base_name")
	local par2_path="${base_dir}/.${sanitized_name}.par2"
	echo "$par2_path"
}

get_abs_directory() {
	local directory="$1"
	local abs_directory
	# Check if directory exists	
	# resolve it to an absolute path
	abs_directory=$(readlink -f "$directory")
	if [[ ! -d "$abs_directory" ]]; then
		echo "Error: Directory '$directory' does not exist" >&2
		return 1
	fi
	echo "$abs_directory"
}

remove_par2_files_for_file() {
	local file="$1"
	local dir_path=$(dirname "$file")
	local basefilename=$(basename "$file")
	local sanitized_name=$(sanitize_filename "$basefilename")
	local files=()
	# trying to glob while preserving spaces in paths is disgusting in Bash /shrug
	shopt -s nullglob
	files=("$dir_path/.$sanitized_name"*.par2)
	for file in "${files[@]}"; do
		rm -f "$file" 2>/dev/null
	done
	shopt -u nullglob
}

# Calculate optimal block size for par2 based on file size
calculate_block_size() {
	local file_size="$1"
	local k=$(echo "scale=6; $file_size/1024" | bc)  # Convert to KB
	
	# Calculate block size percentage using double exponential decay:
	# 1.2: Base percentage (asymptotic minimum)
	# 2.0 * e^(-0.001 * k): Slow decay term for gradual reduction from 1MB to 10MB
	# 21 * e^(-0.3 * k): Fast decay term for steep initial drop from 1KB to 100KB (increased from 20)
	local percent=$(echo "scale=6; 1.2 + 2.0 * e(-0.001 * $k) + 21 * e(-0.3 * $k)" | bc -l)
	
	# Calculate block size in bytes
	local block_size=$(echo "scale=0; ($file_size * $percent) / 100" | bc)
	
	# Ensure minimum block size of 4 and round up to nearest multiple of 4
	if [ "$block_size" -lt 4 ]; then
		block_size=4
	fi
	# Round up to nearest multiple of 4
	echo $(( (block_size + 3) & ~3 ))
}

# Process a single file for par2 operations
process_single_file() {
	local file="$1"
	local operation="$2"  # create, verify, repair, clear, update, stats
	local par2_file
	local file_size_bytes
	local block_size_bytes
	local par2_output
	local file_time
	local par2_time
	
	# Skip if file doesn't exist or is a par2 file
	if [[ ! -f "$file" ]] || [[ "$file" == *.par2 ]] || [[ "$file" == .*.par2 ]]; then
		return 0
	fi

	par2_file=$(get_par2_path "$file")
	
	case "$operation" in
		create)
			if [[ -f "$par2_file" ]]; then
				# Get absolute path for consistent output
				local abs_file
				abs_file=$(readlink -f "$file")
				echo "$abs_file - Exists"
				debug "Skipping $file: par2 file already exists"
				return 0
			fi
			
			debug "Creating par2 for file: $file"
			debug "Par2 file will be: $par2_file"
			
			# Get directory of file
			local file_dir
			file_dir=$(dirname "$file")
			
			file_size_bytes=$(gstat -c %s "$file")
			block_size_bytes=$(calculate_block_size "$file_size_bytes")
			
			debug "Processing file: $file"
			debug "File size: $file_size_bytes bytes, Block size: $block_size_bytes bytes"
			
			debug "PAR2 command: par2 create -s$block_size_bytes -r$PAR2_REDUNDANCY -n1 -T\"$NUM_PAR2_THREADS\" \"$par2_file\" \"$file\""
			
			# Get absolute path for consistent output
			local abs_file
			abs_file=$(readlink -f "$file")
			echo -n "$abs_file"
			
			if ! par2_output=$(par2 create -s"$block_size_bytes" -r"$PAR2_REDUNDANCY" -n1 -T"$NUM_PAR2_THREADS" "$par2_file" "$file" 2>&1); then
				echo -e "\nError creating par2 for $abs_file" >&2
				debug "Detailed error output: $par2_output"
				return 1
			fi
			echo " - Done."
			debug "PAR2 output: $par2_output"
			debug "Par2 file created: $(ls -l "$par2_file")"
			;;
			
		verify)
			[[ ! -f "$par2_file" ]] && return 0
			debug "Verifying file: $file"
			debug "Using par2 file: $par2_file"
			debug "PAR2 command: par2 verify \"$par2_file\""
			if ! par2_output=$(par2 verify "$par2_file" 2>&1); then
				echo "Verification failed for $(readlink -f "$file")" >&2
				debug "Detailed error output: $par2_output"
				return 1
			fi
			debug "PAR2 output: $par2_output"
			;;
			
		repair)
			[[ ! -f "$par2_file" ]] && return 0
			debug "Repairing file: $file"
			debug "Using par2 file: $par2_file"
			debug "File exists: $(ls -l "$file")"
			debug "Par2 file exists: $(ls -l "$par2_file")"
			debug "Directory contents before repair: $(ls -la "$(dirname "$file")")"
			debug "File content before repair: $(cat "$file")"
			debug "Par2 file content (hex): $(xxd -p "$par2_file" | head -n 1)"
			
			debug "PAR2 command: par2 repair -q \"$par2_file\""
			if ! par2_output=$(par2 repair -q "$par2_file" 2>&1); then
				echo "Repair failed for $(readlink -f "$file")" >&2
				debug "Detailed error output: $par2_output"
				return 1
			fi
			debug "PAR2 output: $par2_output"
			debug "Directory contents after repair: $(ls -la "$(dirname "$file")")"
			debug "File content after repair: $(cat "$file")"
			;;
			
		clear)
			remove_par2_files_for_file "$file"
			;;
			
		update)
			if [[ ! -f "$par2_file" ]]; then
				process_single_file "$file" create
				return $?
			fi
			
			file_time=$(gstat -c %Y "$file")
			par2_time=$(gstat -c %Y "$par2_file")
			
			debug "Comparing times for $file"
			debug "Par2 file: $par2_file"
			debug "par2_time=$par2_time file_time=$file_time"
			
			if (( file_time > par2_time )); then
				debug "File is newer, regenerating"
				remove_par2_files_for_file "$file"
				process_single_file "$file" create
				return $?
			fi
			;;
			
		stats)
			local file_size_bytes=$(gstat -c %s "$file")
			if [[ -f "$par2_file" ]]; then
				echo "$file_size_bytes:covered"
			else
				echo "$file_size_bytes:uncovered"
			fi
			;;
	esac
	return 0
}

# Create par2 files recursively
create_par2s() {
	local target="$1"
	
	if [[ -f "$target" ]]; then
		process_single_file "$target" create
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | while read -r file; do
		process_single_file "$file" create
	done
}

# Update par2 files
update_par2s() {
	local target="$1"
	
	if [[ -f "$target" ]]; then
		process_single_file "$target" update
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	echo "Scanning for par2 files in $target..."
	
	# Count total par2 files for progress indication
	local total_par2_files
	total_par2_files=$(find "$target" -type f -name ".*.par2" | wc -l | tr -d ' ')
	echo "Found $total_par2_files par2 files to check"
	
	# First, remove orphaned par2 files and their associated volume files
	local processed_files=0
	find "$target" -type f -name ".*.par2" | while read -r par2_file; do
		processed_files=$((processed_files + 1))
		if ((processed_files % 100 == 0)); then
			echo "Checking par2 files... ($processed_files/$total_par2_files)"
		fi
		
		local par2_dir
		par2_dir=$(dirname "$par2_file")
		local par2_base
		par2_base=$(basename "$par2_file")
		local orig_base
		
		# Extract the base name (without .par2 or .volX+Y)
		if [[ "$par2_base" =~ \.vol ]]; then
			orig_base="${par2_base%%.vol*}"
		else
			orig_base="${par2_base%.par2}"
		fi
		orig_base="${orig_base#.}"  # Remove leading dot
		
		# Check if the original file exists
		if [[ ! -f "$par2_dir/$orig_base" ]]; then
			# Only process each set once (when we find the first file)
			if [[ ! -f "$par2_dir/.$orig_base.par2" ]] || [[ "$par2_file" == "$par2_dir/.$orig_base.par2" ]]; then
				echo "Removing orphaned par2 file: $par2_file"
				rm "$par2_dir/.$orig_base.par2" "$par2_dir/.$orig_base.vol"* 2>/dev/null || true
			fi
		fi
	done
	
	echo "Par2 file check complete"
	echo "Scanning for files needing par2 updates..."
	
	# Count total files for progress indication
	local total_files
	total_files=$(find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | wc -l | tr -d ' ')
	echo "Found $total_files files to process"
	
	# Then update/create par2 files as needed
	processed_files=0
	find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | while read -r file; do
		processed_files=$((processed_files + 1))
		if ((processed_files % 100 == 0)); then
			echo "Processing files... ($processed_files/$total_files)"
		fi
		process_single_file "$file" update
	done
	
	echo "Update complete"
}

# Verify par2 files recursively
verify_par2s() {
	local target="$1"
	local exit_code=0
	
	if [[ -f "$target" ]]; then
		process_single_file "$target" verify
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | while read -r file; do
		if ! process_single_file "$file" verify; then
			exit_code=1
		fi
	done
	
	return $exit_code
}

# Repair files using par2
repair_par2s() {
	local target="$1"
	local exit_code=0
	
	debug "Attempting repair on target: $target"
	
	if [[ -f "$target" ]]; then
		debug "Target is a file, calling process_single_file"
		process_single_file "$target" repair
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	debug "Target is a directory, processing files recursively"
	find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | while read -r file; do
		debug "Processing file in directory: $file"
		if ! process_single_file "$file" repair; then
			exit_code=1
		fi
	done
	
	return $exit_code
}

# Clear all par2 files
clear_par2s() {
	local target="$1"
	
	if [[ -f "$target" ]]; then
		process_single_file "$target" clear
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	find "$target" -type f -name "*.par2" | while read -r par2_file; do
		echo "Removing: $par2_file"
		rm "$par2_file"
	done
}

# Calculate par2 coverage statistics
stats_par2s() {
	local target="$1"
	local covered_bytes=0
	local uncovered_bytes=0
	local coverage_percent=0
	local stats_output=""
	
	if [[ -f "$target" ]]; then
		stats_output=$(process_single_file "$target" stats)
		IFS=: read -r bytes status <<< "$stats_output"
		if [[ "$status" == "covered" ]]; then
			covered_bytes=$((covered_bytes + bytes))
		else
			uncovered_bytes=$((uncovered_bytes + bytes))
		fi
	elif [[ -d "$target" ]]; then
		local file_count=0
		while IFS= read -r file; do
			((file_count++))
			stats_output=$(process_single_file "$file" stats)
			IFS=: read -r bytes status <<< "$stats_output"
			if [[ "$status" == "covered" ]]; then
				covered_bytes=$((covered_bytes + bytes))
			else
				uncovered_bytes=$((uncovered_bytes + bytes))
			fi
		done < <(find "$target" -type f -not -name "*.par2" -not -name ".*.par2")
		
		# If no files were found, still output stats with zeros
		if [[ $file_count -eq 0 ]]; then
			echo "Total bytes: 0"
			echo "Covered bytes: 0"
			echo "Uncovered bytes: 0"
			echo "Coverage: 100.00%"
			return 0
		fi
	else
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	local total_bytes=$((covered_bytes + uncovered_bytes))
	if [[ $total_bytes -gt 0 ]]; then
		coverage_percent=$(echo "scale=2; ($covered_bytes * 100) / $total_bytes" | bc)
	else
		coverage_percent="100.00"
	fi
	
	# Output statistics
	echo "Total bytes: $total_bytes"
	echo "Covered bytes: $covered_bytes"
	echo "Uncovered bytes: $uncovered_bytes"
	echo "Coverage: ${coverage_percent}%"
}

# Debug output function
debug() {
	[ -n "${DEBUG}" ] && echo "DEBUG: $*" >&2
}

# Test output function
test_error() {
	echo "TEST ERROR: $*" >&2
	return 1
}

# Print usage information
show_help() {
	local cmd_name
	cmd_name=$(basename "$0")
	cat >&2 <<EOF
${cmd_name} - Create and manage file redundancy at the directory level

Usage: $cmd_name <command> [<file_or_directory>]

Commands:
  help     Display this help message
  create   Create par2 files for all files in directory or a single file
  update   Update par2 files for modified files in directory or a single file
  verify   Verify all par2 files in directory or a single file
  repair   Repair any corrupted files in directory or a single file
  clear    Remove all par2 files in directory or for a single file
  stats    Show par2 coverage statistics for directory or a single file
  test     Run test suite

par2 by default works at the individual file level and allows you to specify
a percentage of repairable redundancy (5% by default). This means that up to 5%
of the file's content can be corrupted before the file is considered beyond repair.
This extra information is written into par2 files which add about 5% to the total
space used.

${cmd_name} applies this at the directory level, across every file, recursively.
The par2 files are created as hidden files (prefixed with .) in the same
directory as the source files. Each set of par2 files includes a fixed 5% redundancy.
Block size is calculated as a percentage of the original file size using
a double exponential decay formula (previously empirically determined):
  1.2 + 2.0 * e^(-0.001 * k) + 21 * e^(-0.3 * k)
where k is the file size in kilobytes (KB). With 5% redundancy, this provides
optimal block sizes:
  ~18-21% of file size for 1KB files
    (note that small files are inefficient with par2 currently,
    regardless of block size)
  ~4-7% of file size for 10KB files
  ~3-5% of file size for 50-100KB files
  ~1.2-2% of file size for 1MB files
  ~1.2% of file size for 10MB+ files
  The block size is always rounded up to the nearest multiple of 4 bytes
  (per par2 requirements).

Environment Variables:
  NUM_PAR2_THREADS  Number of threads to use for par2 operations
                    Defaults to the number of CPU cores if not set
                    Example: NUM_PAR2_THREADS=4 ./par2_dir create /path/to/dir
  PAR2_REDUNDANCY   Par2 redundancy percentage (5 means roughly 5% extra data for recovery)
                    Defaults to 5 if not set
                    Example: PAR2_REDUNDANCY=10 ./par2_dir create /path/to/dir

Dependencies:
par2, of course (the Nix package I used is par2cmdline-turbo).
The GNU (not BSD which is the Mac default!) versions of stat, touch and sed
are currently required. You can install these via homebrew or your distro's
package manager (although in the case of Linux, these are likely the default).
It is assumed that these tools are available in the PATH via gstat, gtouch
and sed. (On Nix[OS]/nix-darwin, the coreutils-prefixed package provides this,
in case you don't want to shadow the BSD versions, which I recommend.)
EOF
}

test_suite() {
	test_dir=$(mktemp -d)
	test_fails=0
	debug "Testing in directory: $test_dir"
	debug "Testing with $NUM_PAR2_THREADS threads"
	
	# Test 1: Create par2 files for directory
	debug "Testing directory creation..."
	if ! create_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "create_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 2: Verify par2 files for directory
	debug "Testing directory verification..."
	if ! verify_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "verify_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 3: Update par2 files for directory
	debug "Testing directory update..."
	if ! update_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "update_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 4: Repair par2 files for directory
	debug "Testing directory repair..."
	if ! repair_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	
	# Test 5: Clear par2 files for directory
	debug "Testing directory clear..."
	if ! clear_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "clear_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 6: Stats for directory
	debug "Testing directory stats..."
	local stats_output
	stats_output=$(stats_par2s "$test_dir")
	if ! echo "$stats_output" | grep -q "Coverage: 100.00%"; then
		test_error "stats_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 7: Create par2 files for non-existent directory
	debug "Testing non-existent directory creation..."
	if create_par2s "/non/existent/directory" >/dev/null 2>&1; then
		test_error "create_par2s should fail on non-existent directory"
		((test_fails++))
	fi
	
	# Test 8: Single file operations
	debug "Testing single file operations..."
	
	# Create a test file
	echo "This is a test file for single file operations" > "$test_dir/single.txt"
	
	# Test create on single file
	if ! create_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed on single file"
		((test_fails++))
	fi
	
	# Verify par2 file was created
	if [[ ! -f "$test_dir/.single.txt.par2" ]]; then
		test_error "Par2 file not created for single file"
		((test_fails++))
	fi
	
	# Test verify on single file
	if ! verify_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "verify_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test repair on single file
	debug "Starting repair test"
	# First clear any existing par2 files
	debug "Clearing existing par2 files"
	if ! clear_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed before repair test"
		((test_fails++))
	fi
	# Create par2 file for original content
	debug "Creating par2 file for original content"
	if ! create_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before repair test"
		((test_fails++))
	fi
	debug "Checking if par2 file exists: $(ls -la "$test_dir/.single.txt.par2" 2>/dev/null || echo "not found")"
	# Then corrupt the file
	debug "Corrupting file"
	sed -i 's/test/tXst/' "$test_dir/single.txt"
	debug "Corrupted file content: $(cat "$test_dir/single.txt")"
	debug "Attempting repair"
	if ! repair_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	debug "Checking repaired file content: $(cat "$test_dir/single.txt")"
	# Verify file was repaired
	if ! grep -q "This is a test file for single file operations" "$test_dir/single.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	fi
	if ! verify_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "Verification failed after repair"
		((test_fails++))
	else
		debug "Repair of $test_dir/single.txt succeeded, demonstrating par2's resilience to corruption"
	fi
	
	# Test update on single file
	echo "Modified content" > "$test_dir/single.txt"
	if ! update_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "update_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test stats on single file
	local single_stats
	single_stats=$(stats_par2s "$test_dir/single.txt")
	if ! echo "$single_stats" | grep -q "Coverage: 100.00%"; then
		test_error "stats_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test clear on single file
	if ! clear_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed on single file"
		((test_fails++))
	fi
	
	# Verify par2 file was removed
	if [[ -f "$test_dir/.single.txt.par2" ]]; then
		test_error "Par2 file not removed for single file"
		((test_fails++))
	fi
	
	# Test with filename containing special characters
	debug "Testing filename with special characters..."
	echo "This is a test file with special characters" > "$test_dir/test*file?.txt"
	
	# Test create on file with special characters
	if ! create_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Verify par2 file was created with sanitized name
	if [[ ! -f "$test_dir/.test_file_.txt.par2" ]]; then
		test_error "Par2 file not created for file with special characters"
		((test_fails++))
	fi
	
	# Test verify on file with special characters
	if ! verify_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "verify_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Test repair on file with special characters
	# First clear any existing par2 files
	if ! clear_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed before repair test"
		((test_fails++))
	fi
	# Create par2 file for original content
	if ! create_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before repair test"
		((test_fails++))
	fi
	# Then corrupt the file
	sed -i 's/characters/characXers/' "$test_dir/test*file?.txt"
	if ! repair_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "repair_par2s failed on file with special characters"
		((test_fails++))
	fi
	# Verify file was repaired
	if ! grep -q "This is a test file with special characters" "$test_dir/test*file?.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	fi
	
	# Test clear on file with special characters
	if ! clear_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Verify par2 file was removed
	if [[ -f "$test_dir/.test_file_.txt.par2" ]]; then
		test_error "Par2 file not removed for file with special characters"
		((test_fails++))
	fi
	
	# Test high redundancy warning
	debug "Testing high redundancy warning..."
	local warning_output
	warning_output=$(PAR2_REDUNDANCY=100 "$0" create "$test_dir/single.txt" 2>&1)
	if ! echo "$warning_output" | grep -q "Warning: PAR2_REDUNDANCY is set to 100%"; then
		test_error "High redundancy warning not shown"
		((test_fails++))
	fi
	
	# Test normal redundancy (no warning)
	debug "Testing normal redundancy..."
	warning_output=$(PAR2_REDUNDANCY=5 "$0" create "$test_dir/single.txt" 2>&1)
	if echo "$warning_output" | grep -q "Warning: PAR2_REDUNDANCY"; then
		test_error "Warning shown for normal redundancy"
		((test_fails++))
	fi
	
	# Test corrupted par2 data
	debug "Testing corrupted par2 data..."
	# Create a test file
	echo "This is a test file for par2 corruption test" > "$test_dir/corrupt_test.txt"
	# Create par2 file
	if ! create_par2s "$test_dir/corrupt_test.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before par2 corruption test"
		((test_fails++))
	fi
	# Corrupt the par2 file using dd to change a single byte in the middle
	local par2_size
	par2_size=$(gstat -c %s "$test_dir/.corrupt_test.txt.par2")
	local corrupt_pos=$((par2_size / 2))
	debug "Corrupting par2 file at position $corrupt_pos"
	printf 'X' | dd of="$test_dir/.corrupt_test.txt.par2" bs=1 seek="$corrupt_pos" count=1 conv=notrunc 2>/dev/null
	# Now corrupt the original file
	sed -i 's/test/tXst/' "$test_dir/corrupt_test.txt"
	# Try to repair - this should succeed due to par2's built-in redundancy
	if ! repair_par2s "$test_dir/corrupt_test.txt" >/dev/null 2>&1; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	# Verify file was repaired
	if ! grep -q "This is a test file for par2 corruption test" "$test_dir/corrupt_test.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	else
		debug "Repair succeeded, demonstrating par2's resilience to corruption"
	fi
	
	# Test corrupted par2 data with intact original file
	debug "Testing corrupted par2 data with intact original file..."
	# Create a fresh test file
	echo "This is another test file for par2 corruption test" > "$test_dir/corrupt_test2.txt"
	# Create par2 file
	if ! create_par2s "$test_dir/corrupt_test2.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before second par2 corruption test"
		((test_fails++))
	fi
	# Save original content for comparison
	local original_content
	original_content=$(cat "$test_dir/corrupt_test2.txt")
	# Corrupt the par2 file
	par2_size=$(gstat -c %s "$test_dir/.corrupt_test2.txt.par2")
	corrupt_pos=$((par2_size / 2))
	debug "Corrupting second par2 file at position $corrupt_pos"
	printf 'X' | dd of="$test_dir/.corrupt_test2.txt.par2" bs=1 seek="$corrupt_pos" count=1 conv=notrunc 2>/dev/null
	# Verify should succeed due to par2's built-in redundancy
	if ! verify_par2s "$test_dir/corrupt_test2.txt" >/dev/null 2>&1; then
		test_error "verify_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	# Check that original file is unchanged
	if [[ "$(cat "$test_dir/corrupt_test2.txt")" != "$original_content" ]]; then
		test_error "Original file was modified during verify"
		((test_fails++))
	fi
	debug "Verify succeeded, demonstrating par2's resilience to corruption"
	
	# Test update command with orphaned par2 files
	debug "Testing update command with orphaned par2 files"
	# Create test files in a subdirectory
	local update_test_dir="$test_dir/update_test"
	mkdir -p "$update_test_dir/subdir"
	echo "test file 1" > "$update_test_dir/file1.txt"
	echo "test file 2" > "$update_test_dir/file2.txt"
	echo "test file 3" > "$update_test_dir/subdir/file3.txt"
	
	# Create initial par2 files
	create_par2s "$update_test_dir"
	
	# Manually create volume-based par2 files to simulate legacy par2 files
	cp "$update_test_dir/.file2.txt.par2" "$update_test_dir/.file2.txt.vol0+1.par2"
	cp "$update_test_dir/.file2.txt.par2" "$update_test_dir/.file2.txt.vol0+2.par2"
	cp "$update_test_dir/.file1.txt.par2" "$update_test_dir/.file1.txt.vol0+1.par2"
	
	# Remove one of the source files to create an orphaned par2 set
	rm "$update_test_dir/file2.txt"
	
	# Run update
	update_par2s "$update_test_dir"
	
	# Verify entire par2 set for file2.txt was removed
	if [[ -f "$update_test_dir/.file2.txt.par2" ]] || \
	   [[ -f "$update_test_dir/.file2.txt.vol0+1.par2" ]] || \
	   [[ -f "$update_test_dir/.file2.txt.vol0+2.par2" ]]; then
		test_error "Orphaned par2 set was not completely removed"
		return 1
	fi
	
	# Verify par2 set for file1.txt still exists completely
	if [[ ! -f "$update_test_dir/.file1.txt.par2" ]] || \
	   [[ ! -f "$update_test_dir/.file1.txt.vol0+1.par2" ]]; then
		test_error "Valid par2 set was incorrectly removed"
		return 1
	fi
	
	# Verify regular par2 file for file3.txt still exists
	if [[ ! -f "$update_test_dir/subdir/.file3.txt.par2" ]]; then
		test_error "Valid par2 file was incorrectly removed"
		return 1
	fi
	
	if ((test_fails > 0)); then
		echo "Tests failed: $test_fails"
		return 1
	fi
	echo "All tests passed"
	return 0
}

# Main execution (if script is run directly)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	
	command="$1"
	directory="$2"

	ensure_target_arg_provided() {
		if [[ -z "$1" ]]; then
			echo -ne "Error: File or directory argument is required\n\n" >&2
			show_help
			exit 2
		fi
	}
	
	case "$command" in
		help|-h|--help)
			show_help
			exit 0
			;;
		test)
			test_suite
			exit $?
			;;
		create|update|verify|repair|clear|stats)
			ensure_target_arg_provided "$@"
			"${command}_par2s" "$2"
			exit $?
			;;
		*)
			echo "Error: Unknown command '$command'" >&2
			show_help
			exit 1
			;;
	esac
fi
