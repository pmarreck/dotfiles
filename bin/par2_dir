#!/usr/bin/env bash

# Enable strict mode- disabled for now pending future effort because it silently broke things
# set -euo pipefail

IFS=$'\n\t'

# Get number of CPU cores based on OS
get_cpu_cores() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sysctl -n hw.ncpu
    else
        nproc
    fi
}

# Set number of par2 threads, allowing override via environment variable
: "${NUM_PAR2_THREADS:=$(get_cpu_cores)}"

check_dependencies() {
	local dependencies=(gtouch gstat sed)
	local missing=()
	for dep in "${dependencies[@]}"
	do
		if ! command -v "$dep" &> /dev/null
		then
			missing+=("$dep")
		fi
	done
	if ! sed --help | grep -q "GNU sed"
	then
		missing+=("GNU sed")
	fi
	if [[ "${#missing[@]}" > 0 ]]
	then
		printf "Missing dependencies: %s\n" "${missing[*]}"
		exit 1
	fi
}

check_dependencies

# Utility function to get corresponding par2 path
get_par2_path() {
	local orig_path="$1"
	local base_dir=$(dirname "$orig_path")
	local base_name=$(basename "$orig_path")
	local par2_path="${base_dir}/.${base_name}.par2"
	echo "$par2_path"
}

get_abs_directory() {
	local directory="$1"
	local abs_directory
	# Check if directory exists	
	# resolve it to an absolute path
	abs_directory=$(readlink -f "$directory")
	if [[ ! -d "$abs_directory" ]]; then
		echo "Error: Directory '$directory' does not exist" >&2
		return 1
	fi
	echo "$abs_directory"
}

remove_par2_files_for_file() {
	local file="$1"
	local dir_path=$(dirname "$file")
	local basefilename=$(basename "$file")
	local files=()
	# trying to glob while preserving spaces in paths is disgusting in Bash /shrug
	shopt -s nullglob
	files=($dir_path/.${basefilename}*.par2)
	for file in "${files[@]}"; do
		rm -f "$file" 2>/dev/null
	done
}

# Calculate optimal block size for par2 based on file size
calculate_block_size() {
	local file_size="$1"
	local k=$(echo "scale=6; $file_size/1024" | bc)  # Convert to KB
	
	# Calculate block size percentage using double exponential decay:
	# 1.2: Base percentage (asymptotic minimum)
	# 2.0 * e^(-0.001 * k): Slow decay term for gradual reduction from 1MB to 10MB
	# 21 * e^(-0.3 * k): Fast decay term for steep initial drop from 1KB to 100KB (increased from 20)
	local percent=$(echo "scale=6; 1.2 + 2.0 * e(-0.001 * $k) + 21 * e(-0.3 * $k)" | bc -l)
	
	# Calculate block size in bytes
	local block_size=$(echo "scale=0; ($file_size * $percent) / 100" | bc)
	
	# Ensure minimum block size of 4 and round up to nearest multiple of 4
	if [ "$block_size" -lt 4 ]; then
		block_size=4
	fi
	# Round up to nearest multiple of 4
	echo $(( (block_size + 3) & ~3 ))
}

# Create par2 files recursively
create_par2s() {
	local src_dir="$1"
	local quiet="${2:-false}"  # Optional parameter for quiet mode
	
	[[ "$quiet" != "true" ]] && echo "Creating par2 files..." >&2
	
	local retcode=0

	# Ensure source directory exists and is absolute
	src_dir=$(get_abs_directory "$src_dir")
	retcode=$?
	if [[ $retcode -ne 0 ]]; then
		echo "Error: Failed to get absolute path for '$src_dir', or it does not exist" >&2
		return $retcode
	fi
	
	# Process all files recursively
	find "$src_dir" -type f -print0 | while IFS= read -r -d $'\0' file; do
		# Skip if file is hidden or a par2 file
		[[ $(basename "$file") =~ ^\. ]] && continue
		[[ "$file" =~ \.par2$ ]] && continue
		
		# Skip empty files
		if [ ! -s "$file" ]; then
			[[ "$quiet" != "true" ]] && echo "Skipping empty file: '$file'" >&2
			continue
		fi
		
		# Calculate optimal block size based on file size
		local file_size_bytes block_size_bytes
		file_size_bytes=$(gstat -c %s "$file")
		block_size_bytes=$(calculate_block_size "$file_size_bytes")
		
		# Generate par2 files with a period prefix and .par2 extension to make them hidden
		local par2_file="$(get_par2_path "$file")"

		# Skip if par2 file already exists and is not older than source file
		if [[ -f "$par2_file" ]] && ! [[ "$par2_file" -ot "$file" ]]; then
			[[ "$quiet" != "true" ]] && echo "Skipping '$file' - par2 file already exists" >&2
			continue
		fi
		
		# Remove any existing par2 files before creating new ones
		remove_par2_files_for_file "$file"
		
		# Debugging output
		debug "Processing file: $file"
		debug "File size: $file_size_bytes bytes, Block size: $block_size_bytes bytes"
		debug "PAR2 command: par2 create -s$block_size_bytes -r5 -n1 -T\"$NUM_PAR2_THREADS\" \"$par2_file\" \"$file\""
		par2_output=$(par2 create -s$block_size_bytes -r5 -n1 -T"$NUM_PAR2_THREADS" "$par2_file" "$file" 2>&1)
		# Capture detailed error output
		retcode=$?
		if [[ $retcode -ne 0 ]]; then
			echo "Warning: Failed to create par2 for '$file'. Return code: $retcode. Error: $par2_output" >&2
			debug "Detailed error output: $par2_output"
		else
			# Set modification time to match original
			gtouch -r "$file" "$par2_file"
			[[ "$quiet" != "true" ]] && printf "." >&2
		fi
		debug "PAR2 output: $par2_output"
	done
	[[ "$quiet" != "true" ]] && echo >&2
	return $retcode
}

# Update par2 files in a directory
update_par2s() {
	local src_dir="$1"
	
	echo "Updating par2 files..." >&2
	
	local retcode=0
	# Ensure source directory exists and is absolute
	src_dir=$(get_abs_directory "$src_dir")
	retcode=$?
	if [[ $retcode -ne 0 ]]; then
		echo "Error: Failed to get absolute path for '$src_dir', or it does not exist" >&2
		return $retcode
	fi
	
	# 1. Create par2 files for files without them (quietly)
	while IFS= read -r -d $'\0' file; do
		basefilename=$(basename "$file")
		# Skip if file is hidden or a par2 file
		[[ "$basefilename" =~ ^\. ]] && continue
		[[ "$basefilename" =~ \.par2$ ]] && continue
		
		# Skip empty files
		[ ! -s "$file" ] && continue
		
		par2_file="$(get_par2_path "$file")"
		
		# Only create if par2 doesn't exist
		if [[ ! -f "$par2_file" ]]; then
			# Calculate optimal block size based on file size
			local file_size_bytes block_size_bytes
			file_size_bytes=$(gstat -c %s "$file")
			block_size_bytes=$(calculate_block_size "$file_size_bytes")
			
			# Use the same parameters as create_par2s
			par2_output=$(par2 create -s$block_size_bytes -r5 -n1 -T"$NUM_PAR2_THREADS" "$par2_file" "$file" 2>&1)
			if [[ $? -eq 0 ]]; then
				gtouch -r "$file" "$par2_file"
				printf "." >&2
			else
				echo "Warning: Failed to create par2 for '$file'. Error: $par2_output" >&2
				retcode=1
			fi
		fi
	done < <(find "$src_dir" -type f -print0)

	# 2. Regenerate par2 files for modified files
	while IFS= read -r -d $'\0' file; do
		basefilename=$(basename "$file")
		# Skip if file is hidden or a par2 file
		[[ "$basefilename" =~ ^\. ]] && continue
		[[ "$basefilename" =~ \.par2$ ]] && continue
		
		# Skip empty files
		[ ! -s "$file" ] && continue
		
		par2_file="$(get_par2_path "$file")"

		# get dirname of file
		dir_path=$(dirname "$file")
		
		# If par2 file exists and is older than source, regenerate it
		if [[ -f "$par2_file" ]]; then
			local par2_time file_time
			par2_time=$(gstat -c %Y "$par2_file")
			file_time=$(gstat -c %Y "$file")
			debug "Comparing times for $file"
			debug "Par2 file: $par2_file"
			debug "par2_time=$par2_time file_time=$file_time"
			if (( file_time > par2_time )); then
				debug "File is newer, regenerating"
				echo "Regenerating par2 for modified file: '$file'" >&2
				remove_par2_files_for_file "$file"
				# Calculate optimal block size based on file size
				local file_size_bytes block_size_bytes
				file_size_bytes=$(gstat -c %s "$file")
				block_size_bytes=$(calculate_block_size "$file_size_bytes")
				
				debug "File size: $file_size_bytes bytes, Block size: $block_size_bytes bytes"
				# Use the same parameters as create_par2s
				par2_output=$(par2 create -s$block_size_bytes -r5 -n1 -T"$NUM_PAR2_THREADS" "$par2_file" "$file" 2>&1)
				if [[ $? -eq 0 ]]; then
					gtouch -r "$file" "$par2_file"
					printf "." >&2
				else
					echo "Warning: Failed to regenerate par2 for '$file'. Error: $par2_output" >&2
					retcode=1
				fi
			fi
		fi
	done < <(find "$src_dir" -type f -print0)
	
	# 3. Remove orphaned par2 files
	find "$src_dir" -type f -name ".*.par2" -print0 | while IFS= read -r -d $'\0' par2_file; do
		# Extract the original filename by removing the leading dot and trailing .par2
		local base_par2=$(basename "$par2_file")
		if [[ $base_par2 =~ ^\.(.+)\.vol[0-9]+\+[0-9]+\.par2$ ]] || [[ $base_par2 =~ ^\.(.+)\.par2$ ]]; then
			local orig_file="${BASH_REMATCH[1]}"
			local dir_path=$(dirname "$par2_file")
			if [[ ! -f "$dir_path/$orig_file" ]]; then
				echo "Removing orphaned par2 file: '$par2_file'" >&2
				rm -f "$par2_file"
				# Also remove any associated volume files
				rm -f "${par2_file%.*}".vol*.par2 2>/dev/null
			fi
		fi
	done
	echo >&2
	return $retcode
}

# Verify par2 files recursively
verify_par2s() {
	local src_dir="$1"
	
	local retcode=0
	# Ensure source directory exists and is absolute
	src_dir=$(get_abs_directory "$src_dir")
	retcode=$?
	if [[ $retcode -ne 0 ]]; then
		echo "Error: Failed to get absolute path for '$src_dir', or it does not exist" >&2
		return $retcode
	fi
	
	# Process all files recursively
	find "$src_dir" -type f -print0 | while IFS= read -r -d $'\0' file; do
		# Skip hidden and par2 files
		[[ $(basename "$file") =~ ^\. ]] && continue
		[[ "$file" =~ \.par2$ ]] && continue
		
		local par2_file="$(get_par2_path "$file")"
		
		# Check if par2 exists
		if [[ ! -f "$par2_file" ]]; then
			echo "Warning: No par2 file found for '$file'" >&2
			continue
		fi
		
		# Check modification times
		if [[ "$file" -nt "$par2_file" ]]; then
			echo "Warning: File '$file' has been modified since par2 creation" >&2
			continue
		fi
		
		# Verify par2
		if ! par2 verify -q "$par2_file" >/dev/null 2>&1; then
			echo "Error: Verification failed for '$file'" >&2
		else
			printf "." >&2
		fi
	done
	echo >&2
}

# Repair files using par2
repair_par2s() {
	local src_dir="$1"
	
	local retcode=0
	# Ensure source directory exists and is absolute
	src_dir=$(get_abs_directory "$src_dir")
	retcode=$?
	if [[ $retcode -ne 0 ]]; then
		echo "Error: Failed to get absolute path for '$src_dir', or it does not exist" >&2
		return $retcode
	fi
	
	# Process all files recursively
	find "$src_dir" -type f -print0 | while IFS= read -r -d $'\0' file; do
		# Skip hidden and par2 files
		[[ $(basename "$file") =~ ^\. ]] && continue
		[[ "$file" =~ \.par2$ ]] && continue
		
		# Skip empty files
		if [ ! -s "$file" ]; then
			continue
		fi
		
		local par2_file="$(get_par2_path "$file")"
		
		# Check if par2 exists
		if [[ ! -f "$par2_file" ]]; then
			echo "Warning: No par2 file found for '$file'" >&2
			continue
		fi
		
		# Check modification times
		if [[ "$file" -nt "$par2_file" ]]; then
			echo "Warning: File '$file' has been modified since par2 creation" >&2
			continue
		fi
		
		# Attempt repair if verification fails
		if ! par2 verify -q "$par2_file" >/dev/null 2>&1; then
			echo "Attempting repair of '$file'..." >&2
			local par2_output
			par2_output=$(par2 repair "$par2_file" 2>&1)
			local repair_code=$?
			if [[ $repair_code -eq 0 ]]; then
				echo "Successfully repaired '$file'" >&2
				# Update modification time of par2 file to match repaired file
				gtouch -r "$file" "$par2_file"
			else
				echo "Failed to repair '$file'. Error: $par2_output" >&2
				retcode=1
			fi
		fi
	done
	return $retcode
}

# Clear all par2 files in a directory
clear_par2s() {
	local src_dir="$1"
	
	echo "Clearing par2 files..." >&2
	
	local retcode=0
	# Ensure source directory exists and is absolute
	src_dir=$(get_abs_directory "$src_dir")
	retcode=$?
	if [[ $retcode -ne 0 ]]; then
		echo "Error: Failed to get absolute path for '$src_dir', or it does not exist" >&2
		return $retcode
	fi
	
	# Find and remove all par2 files (including volume files)
	find "$src_dir" -type f -name ".*.par2" -print0 | while IFS= read -r -d $'\0' par2_file; do
		echo "Removing: $par2_file" >&2
		rm -f "$par2_file"
	done
}

# Calculate par2 coverage statistics for a directory
stats_par2s() {
	local src_dir="$1"
	local quiet="${2:-false}"
	
	[[ "$quiet" != "true" ]] && echo "Calculating par2 coverage statistics..." >&2
	
	# Ensure source directory exists and is absolute
	src_dir=$(get_abs_directory "$src_dir")
	local retcode=$?
	if [[ $retcode -ne 0 ]]; then
		echo "Error: Failed to get absolute path for '$src_dir', or it does not exist" >&2
		return $retcode
	fi
	
	local covered_bytes=0
	local uncovered_bytes=0
	
	# Find all regular files (excluding hidden files)
	while IFS= read -r -d '' file; do
		local basename
		basename=$(basename "$file")
		
		# Skip par2 files
		[[ "$basename" =~ ^[.].+[.]par2$ ]] && continue
		
		# Skip other hidden files
		[[ "$basename" =~ ^[.] ]] && continue
		
		local file_size
		file_size=$(gstat -c %s "$file")
		
		# Check if file has par2 coverage
		local par2_file
		par2_file=$(get_par2_path "$file")
		if [[ -f "$par2_file" ]]; then
			((covered_bytes += file_size))
		else
			((uncovered_bytes += file_size))
		fi
	done < <(find "$src_dir" -type f -print0)
	
	# Calculate coverage percentage
	local coverage_percent=0
	local total_bytes=$((covered_bytes + uncovered_bytes))
	if [[ $total_bytes -gt 0 ]]; then
		coverage_percent=$(echo "scale=2; ($covered_bytes * 100) / $total_bytes" | bc)
	fi
	
	# Output statistics
	echo "Total data size: $total_bytes bytes"
	echo "Protected data: $covered_bytes bytes"
	echo "Unprotected data: $uncovered_bytes bytes"
	echo "Coverage: ${coverage_percent}%"
	
	return 0
}

test() {
	local test_dir
	test_dir=$(mktemp -d "/tmp/par2_test.$$_XXXXXX") || exit 1
	local empty_dir
	empty_dir=$(mktemp -d "/tmp/par2_empty.$$_XXXXXX") || exit 1

	local test_fails=0
	
	# Ensure cleanup on exit
	trap 'rm -rf "$test_dir" "$empty_dir"' EXIT

	debug "Testing block size calculations..."
	
	# Test cases: [size_bytes, expected_min_percent, expected_max_percent]
	declare -a test_cases=(
		"1024:18:21"      # 1KB: ~20%
		"10240:4:7"       # 10KB: ~6%
		"51200:3:5"       # 50KB: ~4%
		"102400:3:5"      # 100KB: ~4%
		"1048576:1.2:2"   # 1MB: ~1.5%
		"10485760:1.2:1.3" # 10MB: ~1.2%
	)
	
	for test_case in "${test_cases[@]}"; do
		IFS=: read -r size min_percent max_percent <<< "$test_case"
		
		block_size=$(calculate_block_size "$size")
		actual_percent=$(echo "scale=4; $block_size * 100 / $size" | bc)
		
		if (( $(echo "$actual_percent < $min_percent" | bc) )) || \
		   (( $(echo "$actual_percent > $max_percent" | bc) )); then
			test_error "Block size calculation failed for ${size} bytes"
			debug "  Expected: between ${min_percent}% and ${max_percent}%"
			debug "  Got: ${actual_percent}%"
			((test_fails++))
		else
			debug "✓ ${size} bytes: ${actual_percent}% (expected ${min_percent}%-${max_percent}%)"
		fi
		
		# Verify block size is multiple of 4
		if (( block_size % 4 != 0 )); then
			test_error "Block size $block_size is not a multiple of 4"
			((test_fails++))
		fi
	done

	debug "Running par2_dir tests..."

	# Test 1: Non-existent directory
	if verify_par2s /tmp/nonexistent_directory 2>/dev/null; then
		test_error "verify_par2s should fail on non-existent directory"	
		((test_fails++))
	fi

	# Test 2: Empty directory
	if ! verify_par2s "$empty_dir" >/dev/null 2>&1; then
		test_error "verify_par2s should succeed on empty directory"
		((test_fails++))
	fi

	# Create test directory structure
	mkdir "$test_dir/testsubdirectory"
	echo "Hello World! This is a test file with enough content to ensure that a single character change is less than 5% of the total content. Testing par2 functionality." > "$test_dir/test.txt"
	echo "This is a test file with more content." > "$test_dir/testsubdirectory/test2.txt"
	
	# Test 3: Initial create
	if ! create_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "create_par2s failed on initial creation"
		((test_fails++))
	fi
	
	# Test 4: Idempotent create - capture stderr to verify skip message
	local skip_output
	skip_output=$(create_par2s "$test_dir" 2>&1)
	if ! echo "$skip_output" | grep -q "Skipping.*test.txt.*par2 file already exists"; then
		test_error "create_par2s should indicate skipping existing par2 files"
		((test_fails++))
	fi
	
	# Test 5: Update functionality
	# 5a. Create an orphaned par2 file
	touch "$test_dir/.orphaned_file.par2"
	
	# 5b. Modify a file and update its timestamp
	local par2_time
	par2_time=$(gstat -c %Y "$test_dir/.test.txt.par2")
	echo "Modified content" > "$test_dir/test.txt"
	# Set timestamp to 1 second later than original
	gtouch -d "@$((par2_time + 1))" "$test_dir/test.txt"
	
	# Debug: Check modification times
	debug "par2 time: $(gstat -c %Y "$test_dir/.test.txt.par2")"
	debug "file time: $(gstat -c %Y "$test_dir/test.txt")"
	
	# 5c. Create a new file without par2
	echo "New file" > "$test_dir/new_file.txt"
	
	# Run update and capture output
	local update_output
	update_output=$(update_par2s "$test_dir" 2>&1)
	
	# Verify orphaned par2 was removed
	if [[ -f "$test_dir/.orphaned_file.par2" ]]; then
		test_error "update_par2s should remove orphaned par2 files"
		((test_fails++))
	fi
	
	# Verify modified file's par2 was regenerated by checking both the message and the timestamp
	if ! echo "$update_output" | grep -q "Regenerating par2 for modified file:.*test.txt"; then
		debug "Expected regeneration message for test.txt"
		debug "Got output: $update_output"
		test_error "update_par2s should regenerate par2 for modified files"
		((test_fails++))
	fi
	
	# Also verify the par2 file was actually regenerated by checking its timestamp
	local new_par2_time
	new_par2_time=$(gstat -c %Y "$test_dir/.test.txt.par2")
	if (( new_par2_time <= par2_time )); then
		debug "Original par2 time: $par2_time"
		debug "New par2 time: $new_par2_time"
		test_error "par2 file was not actually regenerated (timestamp not updated)"
		((test_fails++))
	fi
	
	# Verify new file has par2
	if [[ ! -f "$test_dir/.new_file.txt.par2" ]]; then
		test_error "update_par2s should create par2 for new files"
		((test_fails++))
	fi
	
	# Reset test.txt for repair test
	echo "Hello World! This is a test file with enough content to ensure that a single character change is less than 5% of the total content. Testing par2 functionality." > "$test_dir/test.txt"
	create_par2s "$test_dir" >/dev/null 2>&1
	
	# check for existence of hidden par2 files
	if [[ ! -f "$test_dir/.test.txt.par2" ]]; then
		test_error ".test.txt.par2 not found"
		((test_fails++))
	fi
	if [[ ! -f "$test_dir/testsubdirectory/.test2.txt.par2" ]]; then
		test_error "testsubdirectory/.test2.txt.par2 not found"
		((test_fails++))
	fi
	
	# Use gstat for GNU compatibility
	local orig_mod_time_test
	orig_mod_time_test=$(gstat -c %Y "$test_dir/test.txt")
	
	# Save original content
	local orig_content
	orig_content=$(cat "$test_dir/test.txt")
	
	# Mutilate a file by changing a single character using GNU sed
	sed -i 's/World/Wxrld/' "$test_dir/test.txt"
	# Set timestamp to 1 second later than original
	gtouch -d "@$((orig_mod_time_test + 1))" "$test_dir/test.txt"
	
	# Remove existing par2 file
	remove_par2_files_for_file "$test_dir/test.txt"
	
	# Regenerate par2 file for the modified content
	create_par2s "$test_dir" >/dev/null 2>&1
	
	# Now restore the original content (simulating corruption)
	echo "$orig_content" > "$test_dir/test.txt"
	# Keep the same timestamp as the modified version
	gtouch -d "@$((orig_mod_time_test + 1))" "$test_dir/test.txt"
	
	# Attempt repair
	repair_par2s "$test_dir" >/dev/null 2>&1
	
	# Verify file contents - should match the modified version
	if ! diff <(echo "Hello Wxrld! This is a test file with enough content to ensure that a single character change is less than 5% of the total content. Testing par2 functionality.") "$test_dir/test.txt"; then
		test_error "Repair failed: test.txt contents do not match modified"
		((test_fails++))
	fi
	
	# Test 6: Clear functionality
	# First verify we have par2 files
	if [[ ! -f "$test_dir/.test.txt.par2" ]] || [[ ! -f "$test_dir/testsubdirectory/.test2.txt.par2" ]]; then
		test_error "setup for clear test failed - par2 files not found"
		((test_fails++))
	fi
	
	# Run clear and capture output
	local clear_output
	clear_output=$(clear_par2s "$test_dir" 2>&1)
	
	# Verify output shows files being removed
	if ! echo "$clear_output" | grep -q "Removing:.*\.par2"; then
		test_error "clear_par2s should show which files it's removing"
		((test_fails++))
	fi
	
	# Verify all par2 files are gone
	if find "$test_dir" -type f -name ".*.par2" | grep -q .; then
		test_error "clear_par2s should remove all par2 files"
		((test_fails++))
	fi
	
	# Test 7: Stats functionality
	debug "Testing stats functionality..."
	
	# Create test files with known sizes
	echo "This is a 100-byte file" > "$test_dir/file1.txt"
	dd if=/dev/zero bs=1000 count=1 of="$test_dir/file2.txt" 2>/dev/null
	
	# Create par2 files
	create_par2s "$test_dir" >/dev/null 2>&1
	
	# Get stats output
	local stats_output
	stats_output=$(stats_par2s "$test_dir" 2>&1)
	
	# Extract coverage percentage from output
	local coverage_percent
	coverage_percent=$(echo "$stats_output" | grep -o 'Coverage: [0-9.]*%' | cut -d' ' -f2 | tr -d '%')
	
	# Verify coverage is a number between 0 and 100
	if ! [[ "$coverage_percent" =~ ^[0-9]+(\.[0-9]+)?$ ]] || \
	   (( $(echo "$coverage_percent > 100" | bc) )) || \
	   (( $(echo "$coverage_percent < 0" | bc) )); then
		test_error "Stats coverage percentage ($coverage_percent) should be between 0 and 100"
		((test_fails++))
	else
		debug "✓ Stats test passed (coverage: $coverage_percent%)"
	fi

	if ((test_fails > 0)); then
		echo -e "\033[0;31mFAIL: Tests failed: $test_fails\033[0m" >&2
		return $test_fails
	else
		echo -e "\033[0;32mPASS: All tests passed\033[0m" >&2
		return 0
	fi
}

# Debug output function
debug() {
	[ -n "${DEBUG}" ] && echo "DEBUG: $*" >&2
}

# Test output function
test_error() {
	echo "TEST ERROR: $*" >&2
	return 1
}

# Print usage information
show_help() {
	local cmd_name
	cmd_name=$(basename "$0")
	cat >&2 <<EOF
${cmd_name} - Create and manage file redundancy at the directory level

Usage: $cmd_name <command> [<directory>]

Commands:
  help     Display this help message
  create   Create par2 files for all files in directory
  update   Update par2 files for modified files in directory
  verify   Verify all par2 files in directory
  repair   Repair any corrupted files in directory using par2
  clear    Remove all par2 files in directory
  stats    Show par2 coverage statistics for directory
  test     Run test suite

par2 by default works at the individual file level and allows you to specify
a percentage of repairable redundancy (5% by default). This means that up to 5%
of the file's content can be corrupted before the file is considered beyond repair.
This extra information is written into par2 files which add about 5% to the total
space used.

${cmd_name} applies this at the directory level, across every file, recursively.
The par2 files are created as hidden files (prefixed with .) in the same
directory as the source files. Each set of par2 files includes a fixed 5% redundancy.
Block size is calculated as a percentage of the original file size using
a double exponential decay formula (previously empirically determined):
  1.2 + 2.0 * e^(-0.001 * k) + 21 * e^(-0.3 * k)
where k is the file size in kilobytes (KB). With 5% redundancy, this provides
optimal block sizes:
  ~18-21% of file size for 1KB files
    (note that small files are inefficient with par2 currently,
    regardless of block size)
  ~4-7% of file size for 10KB files
  ~3-5% of file size for 50-100KB files
  ~1.2-2% of file size for 1MB files
  ~1.2% of file size for 10MB+ files
  The block size is always rounded up to the nearest multiple of 4 bytes
  (per par2 requirements).

The par2 files are created as hidden files (prefixed with .) in the same
directory as the source files. Each set of par2 files includes 5% redundancy
with a block size of approx. BlockSize = 10.5 * (FileSize^0.63)
and an appropriate number of recovery blocks computed by par2.

Dependencies:
par2, of course (the Nix package I used is par2cmdline-turbo).
The GNU (not BSD which is the Mac default!) versions of stat, touch and sed
are currently required. You can install these via homebrew or your distro's
package manager (although in the case of Linux, these are likely the default).
It is assumed that these tools are available in the PATH via gstat, gtouch
and sed. (On Nix[OS]/nix-darwin, the coreutils-prefixed package provides this, 
in case you don't want to shadow the BSD versions, which I recommend.)
EOF
}

# Main execution (if script is run directly)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	
	command="$1"
	directory="$2"

	ensure_directory_arg_provided() {
		if [[ -z "$1" ]]; then
			echo -ne "Error: Directory argument is required\n\n" >&2
			show_help
			exit 2
		fi
	}
	
	case "$command" in
		help|-h|--help)
			show_help
			exit 0
			;;
		test)
			test
			exit $?
			;;
		create|update|verify|repair|clear|stats)
			ensure_directory_arg_provided "$@"
			"${command}_par2s" "$2"
			exit $?
			;;
		*)
			echo "Error: Unknown command '$command'" >&2
			show_help
			exit 1
			;;
	esac
fi
