#!/usr/bin/env bash

# Enable strict mode- disabled for now pending future effort because it silently broke things
# set -euo pipefail

IFS=$'\n\t'

# Get number of CPU cores based on OS
get_cpu_cores() {
	if [[ "$OSTYPE" == "darwin"* ]]; then
		sysctl -n hw.ncpu
	else
		nproc
	fi
}

# Set number of par2 threads, allowing override via environment variable
: "${NUM_PAR2_THREADS:=$(get_cpu_cores)}"
PAR2_REDUNDANCY=${PAR2_REDUNDANCY:-5}
PROTECT_DOTFILES=${PROTECT_DOTFILES:-0}

# Warn if redundancy is set too high
if ((PAR2_REDUNDANCY > 20)); then
	echo "Warning: PAR2_REDUNDANCY is set to ${PAR2_REDUNDANCY}%. This tool is designed for protecting against small corruptions (bitrot, sector failures, intermittent transmission failures) and not for full file recovery. Consider using a lower value (1-20%, default 5%) to save space." >&2
fi

check_dependencies() {
	local missing=()
	# warn if Bash version is less than 4
	if [[ "${BASH_VERSINFO[0]}" -lt 4 ]] || ! $(bash --version | grep -q "^GNU "); then
		missing+=("GNU bash 4 or newer")
	fi
	# warn if AWK is not frawk or gnu awk
	if ! [[ "$AWK" == *"frawk"* || $($AWK --version 2>/dev/null | grep -q "^GNU ") ]]; then
		missing+=("frawk or GNU awk")
	fi
	# warn if not gnu touch
	if ! $TOUCH --help | grep -q "^GNU "; then
		missing+=("GNU touch")
	fi
	# warn if not gnu stat
	if ! $STAT --help | grep -q "^GNU "; then
		missing+=("GNU stat")
	fi
	# warn if not gnu sed
	if ! $SED --help | grep -q "^GNU "; then
		missing+=("GNU sed")
	fi
	# warn if par2 missing
	if [ -z "$PAR2" ]; then
		missing+=("par2")
	fi
	if [[ "${#missing[@]}" > 0 ]]; then
		cat >&2 <<EOF
Missing dependencies:
${missing[*]}
Please install par2 and the GNU versions of touch, stat, sed and awk using your package manager.
If you are on a BSD/macOS, 'coreutils-prefixed' will allow these not to shadow the BSD versions
(by prefixing them with 'g').
EOF
		exit 1
	fi
}

# Set AWK to the best available awk implementation
setup_awk() {
	local which_awk=$(command -v awk)
	command -v gawk >/dev/null 2>&1 && which_awk=$(command -v gawk)
	command -v frawk >/dev/null 2>&1 && which_awk=$(command -v frawk)
	debug "Using awk implementation: $which_awk"
	echo "$which_awk"
}

export AWK=${AWK:-$(setup_awk)}
export TOUCH=${TOUCH:-$(command -v gtouch || command -v touch)}
export STAT=${STAT:-$(command -v gstat || command -v stat)}
export SED=${SED:-$(command -v gsed || command -v sed)}
export PAR2=${PAR2:-$(command -v par2)}
check_dependencies

# Utility function to sanitize filenames for par2
sanitize_filename() {
	local filename="$1"
	# Replace wildcards, question marks, and other problematic characters with underscores
	echo "$filename" | $SED -E 's/[*?]/_/g; s/:/_/g; s/\\/_/g'
}

# Check if we're on macOS
is_macos() {
	[[ "$OSTYPE" == "darwin"* ]]
}

# Check if a file has a resource fork
has_resource_fork() {
	local file="$1"
	local result
	# Check named resource fork path (only on macOS)
	if is_macos; then
		# Check if resource fork exists and is not empty
		# The stat command here is expected to be GNU stat
		[[ -f "${file}/..namedfork/rsrc" && $($STAT -c%s "${file}/..namedfork/rsrc") -gt 0 ]]
		result=$?
		if [[ $result -eq 0 ]]; then
			debug "File $file has a resource fork that is also not empty"
		else
			debug "File $file does not have a resource fork or it is empty"
		fi
		return $result
	else
		return 1
	fi
}

# Utility function to get corresponding par2 path
get_par2_path() {
	local orig_path="$1"
	local base_dir=$(dirname "$orig_path")
	local base_name=$(basename "$orig_path")
	local sanitized_name=$(sanitize_filename "$base_name")
	local par2_path="${base_dir}/.${sanitized_name}.par2"
	echo "$par2_path"
}

# Get the path to a file's resource fork
get_resource_fork_path() {
	if is_macos && [[ -f "${1}/..namedfork/rsrc" ]]; then
		echo "${1}/..namedfork/rsrc"
	else
		return 1
	fi
}

# Get par2 path for resource fork
get_resource_fork_par2_path() {
	local file="$1"
	local base_dir=$(dirname "$file")
	local base_name=$(basename "$file")
	local sanitized_name=$(sanitize_filename "$base_name")
	echo "${base_dir}/.${sanitized_name}.rsrc.par2"
}

# Get path to the temporary location for a file's resource fork
get_temp_resource_fork_path() {
	local file="$1"
	local base_dir=$(dirname "$file")
	local base_name=$(basename "$file")
	local sanitized_name=$(sanitize_filename "$base_name")
	echo "${base_dir}/.${sanitized_name}.rsrc"
}

get_abs_directory() {
	local directory="$1"
	local abs_directory
	# Check if directory exists	
	# resolve it to an absolute path
	abs_directory=$(readlink -f "$directory")
	if [[ ! -d "$abs_directory" ]]; then
		echo "Error: Directory '$directory' does not exist" >&2
		return 1
	fi
	echo "$abs_directory"
}

remove_par2_files_for_file() {
	local file="$1"
	local dir_path=$(dirname "$file")
	local basefilename=$(basename "$file")
	local sanitized_name=$(sanitize_filename "$basefilename")
	local files=()
	# trying to glob while preserving spaces in paths is disgusting in Bash /shrug
	shopt -s nullglob
	files=("$dir_path/.$sanitized_name"*.par2)
	for file in "${files[@]}"; do
		rm -f "$file" 2>/dev/null
	done
	shopt -u nullglob
}

# Calculate optimal block size for par2 based on file size
calculate_block_size() {
	local file_size="$1"
	local block_size
	
	# Calculate everything in one awk invocation:
	# - Convert to KB
	# - Calculate percentage using double exponential decay
	# - Calculate block size
	# - Enforce minimum of 4 bytes
	# - Round up to nearest multiple of 4
	read -r block_size < <($AWK -v size="$file_size" '
		BEGIN {
			# Convert to KB
			k = size / 1024
			
			# Calculate percentage using double exponential decay:
			# 1.2: Base percentage (asymptotic minimum)
			# 2.0 * exp(-0.001 * k): Slow decay term for gradual reduction from 1MB to 10MB
			# 21 * exp(-0.3 * k): Fast decay term for steep initial drop from 1KB to 100KB
			percent = 1.2 + 2.0 * exp(-0.001 * k) + 21 * exp(-0.3 * k)
			
			# Calculate block size in bytes
			block_size = int((size * percent) / 100)
			
			# Ensure minimum block size of 4
			if (block_size < 4) block_size = 4
			
			# Round up to nearest multiple of 4
			block_size = int((block_size + 3) / 4) * 4
			
			print block_size
		}
	')
	
	echo "$block_size"
}

# Function to check if a file should be processed
should_process_file() {
	local file="$1"
	local basename
	basename=$(basename "$file")
	
	# Skip if file doesn't exist or is a par2 file
	if [[ ! -f "$file" ]] || [[ "$basename" == *.par2 ]]; then
		return 1
	fi

	# Skip dotfiles unless PROTECT_DOTFILES is enabled
	if [[ "$PROTECT_DOTFILES" != "1" && "$basename" == .* ]]; then
		return 1
	fi
	
	return 0
}

# Process a single file for par2 operations
process_single_file() {
	local file="$1"
	if ! should_process_file "$file"; then
		return 0
	fi
	local operation="$2"
	local file_dir
	file_dir=$(dirname "$file")
	local base_name
	base_name=$(basename "$file")
	local par2_file
	par2_file=$(get_par2_path "$file")
	local has_rf=false

	if has_resource_fork "$file"; then
		local resource_fork_path
		resource_fork_path=$(get_resource_fork_path "$file")
		local resource_fork_par2_file
		resource_fork_par2_file=$(get_resource_fork_par2_path "$file")
		local temp_resource_fork_path
		temp_resource_fork_path=$(get_temp_resource_fork_path "$file")
		has_rf=true
	fi

	case "$operation" in
		create)
			if [[ -f "$par2_file" ]]; then
				debug "Skipping $file: its par2 file already exists"
				return 0
			fi

			debug "Par2 file will be: $par2_file"
			debug "Processing file: $file"
			local file_size=0
			file_size=$($STAT -c%s "$file") # NOTE: this is expected to be GNU stat!
			local block_size=0
			block_size=$(calculate_block_size "$file_size")
			debug "File size: $file_size bytes, Block size: $block_size bytes"
			debug "PAR2 command: $PAR2 create -s$block_size -r$PAR2_REDUNDANCY -n1 -T\"$NUM_PAR2_THREADS\" \"$par2_file\" \"$file\""

			if ! $PAR2 create -s"$block_size" -r"$PAR2_REDUNDANCY" -n1 -T"$NUM_PAR2_THREADS" "$par2_file" "$file" >/dev/null; then
				echo -e "\nError creating par2 for $file" >&2
				return 1
			fi
			debug "Par2 file created: $(ls -l "$par2_file")"

			if $has_rf; then
				debug "Creating par2 for resource fork: $resource_fork_path"
				debug "Resource fork par2 file will be: $resource_fork_par2_file"
				# Since par2 doesn't support resource forks, 
				# we need to create a temporary file to hold the resource fork
				cat "$resource_fork_path" > "$temp_resource_fork_path"
				debug "Created temporary file to hold resource fork: $temp_resource_fork_path"
				local rf_size
				rf_size=$($STAT -c%s "$resource_fork_path") # NOTE: this is expected to be GNU stat!
				local rf_block_size
				rf_block_size=$(calculate_block_size "$rf_size")
				if ! $PAR2 create -s"$rf_block_size" -r"$PAR2_REDUNDANCY" -n1 -T"$NUM_PAR2_THREADS" "$resource_fork_par2_file" "$temp_resource_fork_path" >/dev/null; then
					echo -e "\nError creating par2 for resource fork of $file of length $rf_size" >&2
					rm "$temp_resource_fork_path"
					return 1
				fi
				rm "$temp_resource_fork_path"
				debug "Par2 file created: $resource_fork_par2_file"
			fi

			echo " - Done."
			;;

		verify)
			[[ ! -f "$par2_file" ]] && return 0
			debug "Verifying file: $file"
			debug "Using par2 file: $par2_file"
			debug "PAR2 command: $PAR2 verify \"$par2_file\""
			if ! $PAR2 verify "$par2_file" >/dev/null; then
				echo "Verification failed for $(readlink -f "$file")" >&2
				return 1
			fi

			if $has_rf; then
				# Since par2 doesn't support resource forks, 
				# we need to create a temporary file to hold the resource fork
				cat "$resource_fork_path" > "$temp_resource_fork_path"
				debug "Created temporary file to hold resource fork: $temp_resource_fork_path"
				debug "Verifying resource fork"
				if ! $PAR2 verify "$temp_resource_fork_path" >/dev/null; then
					echo "Resource fork verification failed for $(readlink -f "$file")" >&2
					rm "$temp_resource_fork_path"
					return 1
				fi
				debug "Resource fork verification successful"
				rm "$temp_resource_fork_path"
			fi
			;;

		repair)
			[[ ! -f "$par2_file" ]] && return 0
			debug "Repairing file: $file"
			debug "Using par2 file: $par2_file"
			debug "File exists: $(ls -l "$file")"
			debug "Par2 file exists: $(ls -l "$par2_file")"
			debug "Directory contents before repair: $(ls -la "$file_dir")"
			debug "File content before repair: $(cat "$file")"
			debug "Par2 file content (hex): $(xxd -p -l 30 "$par2_file")"
			debug "PAR2 command: $PAR2 repair -q \"$par2_file\" \"$file\""

			if $has_rf; then
				# Since par2 doesn't support resource forks, 
				# we need to create a temporary file to hold the resource fork
				cat "$resource_fork_path" > "$temp_resource_fork_path"
				debug "cat $resource_fork_path > $temp_resource_fork_path"
				debug "Created temporary file to hold resource fork: $temp_resource_fork_path"
			fi
			# PAR2's repair obliterates any resource forks. Hence the logic here.
			if ! $PAR2 repair -q "$par2_file" "$file"; then
				echo -e "\nError repairing $file" >&2
				$has_rf && rm "$temp_resource_fork_path"
				return 1
			fi
			debug "$(if $has_rf; then echo "Data fork of f"; else echo "F"; fi)ile repaired: $(ls -l "$file")"
			if $has_rf; then
				debug "Repairing resource fork"
				debug "PAR2 command: $PAR2 repair -q \"$resource_fork_par2_file\" \"$temp_resource_fork_path\""
				if ! $PAR2 repair -q "$resource_fork_par2_file" "$temp_resource_fork_path"; then
					debug "Resource fork repair failed for $file"
					debug "Detailed error output: $($PAR2 repair "$resource_fork_par2_file" "$temp_resource_fork_path" 2>&1)"
					rm "$temp_resource_fork_path"
					return 1
				fi
				debug "Resource fork repaired in temporary location: $(ls -l "$temp_resource_fork_path")"
				debug "Copying temporary resource fork back to: $resource_fork_path"
				cat "$temp_resource_fork_path" > "$resource_fork_path"
				rm "$temp_resource_fork_path"
			fi

			debug "Directory contents after repair: $(ls -la "$file_dir")"
			debug "File content after repair: $(cat "$file")"
			echo " - Done."
			;;

		clear)
			remove_par2_files_for_file "$file"

			if $has_rf; then
				remove_par2_files_for_file "$(get_resource_fork_path "$file")"
			fi
			;;

		update)
			if [[ ! -f "$par2_file" ]]; then
				process_single_file "$file" create
				return $?
			fi

			local file_time
			file_time=$($STAT -c%Y "$file") # NOTE: this is expected to be GNU stat!
			local par2_time
			par2_time=$($STAT -c%Y "$par2_file") # NOTE: this is expected to be GNU stat!

			local needs_update=0
			if (( file_time > par2_time )); then
				needs_update=1
			fi

			# Check resource fork if present
			if $has_rf; then
				if [[ -f "$resource_fork_par2_file" ]]; then
					local rsrc_time
					rsrc_time=$($STAT -c%Y "$resource_fork_path") # NOTE: this is expected to be GNU stat!
					local rsrc_par2_time
					rsrc_par2_time=$($STAT -c%Y "$resource_fork_par2_file") # NOTE: this is expected to be GNU stat!
					if (( rsrc_time > rsrc_par2_time )); then
						needs_update=1
					fi
				else
					needs_update=1
				fi
			fi

			if [[ $needs_update -eq 1 ]]; then
				debug "File or resource fork is newer, regenerating"
				process_single_file "$file" clear
				process_single_file "$file" create
				return $?
			fi
			;;

		stats)
			local total_size=0
			total_size=$($STAT -c%s "$file") # NOTE: this is expected to be GNU stat!

			if $has_rf; then
				local rsrc_size
				rsrc_size=$($STAT -c%s "$resource_fork_path") # NOTE: this is expected to be GNU stat!
				((total_size += rsrc_size))
			fi

			if [[ -f "$par2_file" ]] && ( ! $has_rf || [[ -f "$resource_fork_par2_file" ]] ); then
				echo "$total_size:covered"
			else
				echo "$total_size:uncovered"
			fi
			;;

		*)
			echo "Error: Unknown operation: $operation"
			return 1
			;;
	esac

	return 0
}

# Create par2 files recursively
create_par2s() {
	local target="$1"

	debug "Attempting create on target: $target"
	
	if [[ -f "$target" ]]; then
		debug "Target is a file, calling process_single_file $target create"
		process_single_file "$target" create
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	find "$target" -type f -not -name "*.par2" | while read -r file; do
		debug "Creating protection for $file in directory: $target"
		process_single_file "$file" create
	done
}

# Update par2 files
update_par2s() {
	local target="$1"

	debug "Attempting update on target: $target"
	
	if [[ -f "$target" ]]; then
		if should_process_file "$target"; then
			debug "Target is a file, calling process_single_file $target update"
			process_single_file "$target" update
			return $?
		else
			debug "Target $target is a file, but should not be processed, skipping"
			return 0
		fi
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	echo "Scanning for par2 files in $target..."
	
	# Count total par2 files that are not resource fork par2 filesfor progress indication
	local total_par2_files par2_files
	par2_files=$(find "$target" -type f -not -name ".*.rsrc.par2" -name ".*.par2" )
	total_par2_files=$(echo "$par2_files" | wc -l | tr -d ' ')
	echo "Found $total_par2_files par2 files to check"
	
	# First, remove orphaned par2 files and their associated volume files
	local processed_files=0
	local par2_dir par2_base orig_base
	echo "$par2_files" | while read -r par2_file; do
		processed_files=$((processed_files + 1))
		if ((processed_files % 100 == 0)); then
			echo "Checking par2 files... ($processed_files/$total_par2_files)"
		fi
		
		par2_dir=$(dirname "$par2_file")
		par2_base=$(basename "$par2_file")
		
		# Extract the base name (without .par2 or .volX+Y)
		if [[ "$par2_base" =~ \.vol ]]; then
			orig_base="${par2_base%%.vol*}"
		else
			orig_base="${par2_base%.par2}"
		fi
		orig_base="${orig_base#.}"  # Remove leading dot
		
		# Skip if this is a dotfile and we're not protecting them
		if [[ "$PROTECT_DOTFILES" != "1" && "$orig_base" == .* ]]; then
			debug "Skipping dotfile: $orig_base (PROTECT_DOTFILES=$PROTECT_DOTFILES)"
			continue
		fi
		
		# Skip if this is a par2 file (regardless of extension)
		if [[ "$orig_base" =~ \.(par2|vol[0-9]+\+[0-9]+\.par2)$ ]]; then
			debug "Skipping par2 file: $orig_base"
			continue
		fi
		
		# Check if the original file exists
		if [[ ! -f "$par2_dir/$orig_base" ]]; then
			# Only process each set once (when we find the first file)
			if [[ ! -f "$par2_dir/.$orig_base.par2" ]] || [[ "$par2_file" == "$par2_dir/.$orig_base.par2" ]]; then
				echo "Removing orphaned par2 files: $par2_file"
				rm "$par2_dir/.$orig_base.par2" "$par2_dir/.$orig_base.rsrc.par2" "$par2_dir/.$orig_base.vol"* 2>/dev/null || true
			fi
		fi
	done
	
	echo "Par2 file check complete"
	echo "Scanning for files needing par2 updates..."
	
	# Count total files for progress indication, excluding dotfiles if not protected
	local total_files
	if [[ "$PROTECT_DOTFILES" == "1" ]]; then
		total_files=$(find "$target" -type f -not -name "*.par2" | wc -l | tr -d ' ')
	else
		total_files=$(find "$target" -type f -not -name ".*" -not -name "*.par2" | wc -l | tr -d ' ')
	fi
	echo "Found $total_files files to process"
	
	# Then update/create par2 files as needed
	processed_files=0
	find "$target" -type f -not -name "*.par2" | while read -r file; do
		if ! should_process_file "$file"; then
			continue
		fi
		processed_files=$((processed_files + 1))
		if ((processed_files % 100 == 0)); then
			echo "Processing files... ($processed_files/$total_files)"
		fi
		debug "Updating file: $file"
		process_single_file "$file" update
	done
	
	echo "Update complete"
}

# Verify par2 files recursively
verify_par2s() {
	local target="$1"
	local exit_code=0

	debug "Attempting verify on target: $target"
	
	if [[ -f "$target" ]]; then
		debug "Target is a file, calling process_single_file $target verify"
		process_single_file "$target" verify
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	debug "Target is a directory, processing files recursively"
	find "$target" -type f -not -name "*.par2" | while read -r file; do
		debug "Verifying protection for file: $file"
		if ! process_single_file "$file" verify; then
			exit_code=1
		fi
	done
	
	return $exit_code
}

# Repair files using par2
repair_par2s() {
	local target="$1"
	local exit_code=0
	
	debug "Attempting repair on target: $target"
	
	if [[ -f "$target" ]]; then
		debug "Target is a file, calling process_single_file $target repair"
		process_single_file "$target" repair
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	debug "Target is a directory, processing files recursively"
	find "$target" -type f -not -name "*.par2" | while read -r file; do
		debug "Repairing file if necessary: $file"
		if ! process_single_file "$file" repair; then
			exit_code=1
		fi
	done
	
	return $exit_code
}

# Clear all par2 files
clear_par2s() {
	local target="$1"

	debug "Attempting clear on target: $target"
	
	if [[ -f "$target" ]]; then
		debug "Target is a file, calling process_single_file $target clear"
		process_single_file "$target" clear
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	debug "Target $target is a directory, processing files recursively"
	find "$target" -type f -name "*.par2" | while read -r par2_file; do
		echo "Removing: $par2_file"
		rm "$par2_file"
	done
}

# Calculate par2 coverage statistics
stats_par2s() {
	local target="$1"
	local covered_bytes=0
	local uncovered_bytes=0
	local coverage_percent=0
	local stats_output=""
	local file_count=0
	
	if [[ -f "$target" ]]; then
		((file_count++))
		stats_output=$(process_single_file "$target" stats)
		IFS=: read -r bytes status <<< "$stats_output"
		if [[ "$status" == "covered" ]]; then
			covered_bytes=$((covered_bytes + bytes))
		else
			uncovered_bytes=$((uncovered_bytes + bytes))
		fi
	elif [[ -d "$target" ]]; then
		while IFS= read -r file; do
			((file_count++))
			stats_output=$(process_single_file "$file" stats)
			IFS=: read -r bytes status <<< "$stats_output"
			if [[ "$status" == "covered" ]]; then
				covered_bytes=$((covered_bytes + bytes))
			else
				uncovered_bytes=$((uncovered_bytes + bytes))
			fi
		done < <(find "$target" -type f -not -name "*.par2")
	else
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	local total_bytes=$((covered_bytes + uncovered_bytes))
	if [[ $total_bytes -gt 0 ]]; then
		coverage_percent=$(echo "scale=2; ($covered_bytes * 100) / $total_bytes" | bc)
	else
		coverage_percent="100.00"
	fi
	
	# Output statistics
	echo "Statistics for $target:"
	echo "Files processed: $file_count"
	echo "Total bytes: $total_bytes"
	echo "Covered bytes: $covered_bytes"
	echo "Uncovered bytes: $uncovered_bytes"
	echo "Coverage: ${coverage_percent}%"
}

# Debug status
debug_mode() {
	[ -n "${DEBUG}" ] && true || false
}

# Debug output function
declare -F debug >/dev/null 2>&1 || \
debug() {
	debug_mode && echo "DEBUG: $*" >&2
}

# Test output function
test_error() {
	echo "TEST ERROR: $*" >&2
	return 1
}
# Test debug output function
test_debug() {
	echo "TEST DEBUG: $*" >&2
}

# Print usage information
show_help() {
	local cmd_name
	cmd_name=$(basename "$0")
	cat >&2 <<EOF
${cmd_name} - Create and manage file redundancy at the directory level

Usage: $cmd_name <command> [<file_or_directory>]

Commands:
  help     Display this help message
  create   Create par2 files for all files in directory or a single file
  update   Update par2 files for modified files in directory or a single file
  verify   Verify all par2 files in directory or a single file
  repair   Repair any corrupted files in directory or a single file
  clear    Remove all par2 files in directory or for a single file
  stats    Show par2 coverage statistics for directory or a single file
  test     Run test suite

par2 (which is doing most of the heavy lifting here) by default works at the 
individual file level and allows you to specify a percentage of repairable
redundancy (5% by default). This means that up to 5% of the file's content can
be corrupted before the file is considered beyond repair. This extra information
is written into par2 files which add about 5% to the total space used.

But it's really designed to work across a giant segmented archive file (which
was its original use-case), and not at the individual file or directory level.

${cmd_name} applies this at the directory level, across every file, recursively.
On macOS, it also does special handling around resource forks, which are not
supported by par2 by default.
The par2 files are created as hidden files (prefixed with '.' i.e. dotfiles) 
colocated in the same directory as the source files. (I decided this was a
better strategy than putting them into a sqlite database or some other unified
file or container.) Each set of one or morepar2 files includes a default 5%
redundancy. Block size is calculated as a percentage of the original file size
using a double exponential decay formula (which was empirically determined 
to be the most effective, separately):
  1.2: Base percentage (asymptotic minimum)
  2.0 * e^(-0.001 * k): Slow decay term for gradual reduction from 1MB to 10MB
  21 * e^(-0.3 * k): Fast decay term for steep initial drop from 1KB to 100KB
(increased from 20)
where k is the file size in kilobytes (KB). With 5% redundancy, this provides
optimal block sizes in proportion to file size as follows:
  ~18-21% of file size for 1KB files
    (note that small files are rather inefficient with par2 currently,
    regardless of block size, but I tried!)
  ~4-7% of file size for 10KB files
  ~3-5% of file size for 50-100KB files
  ~1.2-2% of file size for 1MB files
  ~1.2% of file size for 10MB+ files
The block size is always rounded up to the nearest multiple of 4 bytes
(per par2 requirements).

There's also a fairly comprehensive test suite, which you can run with:
  > ${cmd_name} test

Environment Variables:
  NUM_PAR2_THREADS  Number of threads to use for par2 operations.
					Defaults to the number of CPU cores if not set.
					Example: NUM_PAR2_THREADS=4 ./par2_dir create /path/to/dir
  PAR2_REDUNDANCY   Par2 redundancy percentage (5 means roughly 5% extra data for recovery).
					Defaults to 5 if not set.
					Example: PAR2_REDUNDANCY=10 ./par2_dir create /path/to/dir
  PROTECT_DOTFILES  Protect dotfiles (files starting with .).
					Defaults to 0 (false) if not set (dotfiles will get skipped).
					Example: PROTECT_DOTFILES=1 ./par2_dir create /path/to/dir

Dependencies:
par2, of course (the Nix package I used is par2cmdline-turbo).
The GNU (not BSD which is the Mac default!) versions of stat, touch and sed
are currently required. You can install these via homebrew or your distro's
package manager (although in the case of Linux, these are likely the default).
It is assumed that these tools are available in the PATH via gstat, gtouch
and sed. (On Nix[OS]/nix-darwin, the coreutils-prefixed package provides this,
in case you don't want to shadow the BSD versions, which I recommend.)
EOF
}

test_suite() {
	test_dir=$(mktemp --tmpdir -d par2_dir_test.XXXXXX)
	test_fails=0
	test_debug "Testing in directory: $test_dir"
	test_debug "Testing with $NUM_PAR2_THREADS threads"
	
	# Test 1: Create par2 files for directory
	test_debug "Testing directory creation..."
	if ! create_par2s "$test_dir" >/dev/null; then
		test_error "create_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 2: Verify par2 files for directory
	test_debug "Testing directory verification..."
	if ! verify_par2s "$test_dir" >/dev/null; then
		test_error "verify_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 3: Update par2 files for directory
	test_debug "Testing directory update..."
	if ! update_par2s "$test_dir" >/dev/null; then
		test_error "update_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 4: Repair par2 files for directory
	test_debug "Testing directory repair..."
	if ! repair_par2s "$test_dir" >/dev/null; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	
	# Test 5: Clear par2 files for directory
	test_debug "Testing directory clear..."
	if ! clear_par2s "$test_dir" >/dev/null; then
		test_error "clear_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 6: Stats for directory
	test_debug "Testing directory stats..."
	local stats_output
	stats_output=$(stats_par2s "$test_dir")
	if ! echo "$stats_output" | grep -q "Coverage: 100.00%"; then
		test_error "stats_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 7: Create par2 files for non-existent directory
	test_debug "Testing non-existent directory creation..."
	if create_par2s "/non/existent/directory" >/dev/null; then
		test_error "create_par2s should fail on non-existent directory"
		((test_fails++))
	fi
	
	# Test 8: Single file operations
	test_debug "Testing single file operations..."
	
	# Create a test file
	echo "This is a test file for single file operations" > "$test_dir/single.txt"
	
	# Test create on single file
	if ! create_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "create_par2s failed on single file"
		((test_fails++))
	fi
	
	# Verify par2 file was created
	if [[ ! -f "$test_dir/.single.txt.par2" ]]; then
		test_error "Par2 file not created for single file"
		((test_fails++))
	fi
	
	# Test verify on single file
	if ! verify_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "verify_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test repair on single file
	test_debug "Starting repair test"
	# First clear any existing par2 files
	test_debug "Clearing existing par2 files"
	if ! clear_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "clear_par2s failed before repair test"
		((test_fails++))
	fi
	# Create par2 file for original content
	test_debug "Creating par2 file for original content"
	if ! create_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "create_par2s failed before repair test"
		((test_fails++))
	fi
	test_debug "Checking if par2 file exists: $(ls -la "$test_dir/.single.txt.par2" 2>/dev/null || echo "not found")"
	# Then corrupt the file
	test_debug "Corrupting file"
	sed -i 's/test/tXst/' "$test_dir/single.txt"
	test_debug "Corrupted file content: $(cat "$test_dir/single.txt")"
	test_debug "Attempting repair"
	if ! repair_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	test_debug "Checking repaired file content: $(cat "$test_dir/single.txt")"
	# Verify file was repaired
	if ! grep -q "This is a test file for single file operations" "$test_dir/single.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	fi
	if ! verify_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "Verification failed after repair"
		((test_fails++))
	else
		test_debug "Repair of $test_dir/single.txt succeeded, demonstrating par2's resilience to corruption"
	fi
	
	# Test update on single file
	echo "Modified content" > "$test_dir/single.txt"
	if ! update_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "update_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test stats on single file
	local single_stats
	single_stats=$(stats_par2s "$test_dir/single.txt")
	if ! echo "$single_stats" | grep -q "Coverage: 100.00%"; then
		test_error "stats_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test clear on single file
	if ! clear_par2s "$test_dir/single.txt" >/dev/null; then
		test_error "clear_par2s failed on single file"
		((test_fails++))
	fi
	
	# Verify par2 file was removed
	if [[ -f "$test_dir/.single.txt.par2" ]]; then
		test_error "Par2 file not removed for single file"
		((test_fails++))
	fi
	
	# Test with filename containing special characters
	test_debug "Testing filename with special characters..."
	echo "This is a test file with special characters" > "$test_dir/test*file?.txt"
	
	# Test create on file with special characters
	if ! create_par2s "$test_dir/test*file?.txt" >/dev/null; then
		test_error "create_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Verify par2 file was created with sanitized name
	if [[ ! -f "$test_dir/.test_file_.txt.par2" ]]; then
		test_error "Par2 file not created for file with special characters"
		((test_fails++))
	fi
	
	# Test verify on file with special characters
	if ! verify_par2s "$test_dir/test*file?.txt" >/dev/null; then
		test_error "verify_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Test repair on file with special characters
	# First clear any existing par2 files
	if ! clear_par2s "$test_dir/test*file?.txt" >/dev/null; then
		test_error "clear_par2s failed before repair test"
		((test_fails++))
	fi
	# Create par2 file for original content
	if ! create_par2s "$test_dir/test*file?.txt" >/dev/null; then
		test_error "create_par2s failed before repair test"
		((test_fails++))
	fi
	# Then corrupt the file
	$SED -i 's/characters/characXers/' "$test_dir/test*file?.txt"
	if ! repair_par2s "$test_dir/test*file?.txt" >/dev/null; then
		test_error "repair_par2s failed on file with special characters"
		((test_fails++))
	fi
	# Verify file was repaired
	if ! grep -q "This is a test file with special characters" "$test_dir/test*file?.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	fi
	
	# Test clear on file with special characters
	if ! clear_par2s "$test_dir/test*file?.txt" >/dev/null; then
		test_error "clear_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Verify par2 file was removed
	if [[ -f "$test_dir/.test_file_.txt.par2" ]]; then
		test_error "Par2 file not removed for file with special characters"
		((test_fails++))
	fi
	
	# Test high redundancy warning
	debug "Testing high redundancy warning..."
	local warning_output
	warning_output=$(PAR2_REDUNDANCY=100 "$0" create "$test_dir/single.txt" 2>&1)
	if ! echo "$warning_output" | grep -q "Warning: PAR2_REDUNDANCY is set to 100%"; then
		test_error "High redundancy warning not shown"
		((test_fails++))
	fi
	
	# Test normal redundancy (no warning)
	debug "Testing normal redundancy..."
	warning_output=$(PAR2_REDUNDANCY=5 "$0" create "$test_dir/single.txt" 2>&1)
	if echo "$warning_output" | grep -q "Warning: PAR2_REDUNDANCY"; then
		test_error "Warning shown for normal redundancy"
		((test_fails++))
	fi
	
	# Test corrupted par2 data
	debug "Testing corrupted par2 data..."
	# Create a test file
	echo "This is a test file for par2 corruption test" > "$test_dir/corrupt_test.txt"
	# Create par2 file
	if ! create_par2s "$test_dir/corrupt_test.txt" >/dev/null; then
		test_error "create_par2s failed before par2 corruption test"
		((test_fails++))
	fi
	# Corrupt the par2 file using dd to change a single byte in the middle
	local par2_size
	par2_size=$($STAT -c %s "$test_dir/.corrupt_test.txt.par2")
	local corrupt_pos=$((par2_size / 2))
	test_debug "Corrupting par2 file at position $corrupt_pos"
	printf 'X' | dd of="$test_dir/.corrupt_test.txt.par2" bs=1 seek="$corrupt_pos" count=1 conv=notrunc
	# Now corrupt the original file
	$SED -i 's/test/tXst/' "$test_dir/corrupt_test.txt"
	# Try to repair - this should succeed due to par2's built-in redundancy
	if ! repair_par2s "$test_dir/corrupt_test.txt" >/dev/null; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	# Verify file was repaired
	if ! grep -q "This is a test file for par2 corruption test" "$test_dir/corrupt_test.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	else
		test_debug "Repair succeeded, demonstrating par2's resilience to corruption"
	fi
	
	# Test corrupted par2 data with intact original file
	test_debug "Testing corrupted par2 data with intact original file..."
	# Create a fresh test file
	echo "This is another test file for par2 corruption test" > "$test_dir/corrupt_test2.txt"
	# Create par2 file
	if ! create_par2s "$test_dir/corrupt_test2.txt" >/dev/null; then
		test_error "create_par2s failed before second par2 corruption test"
		((test_fails++))
	fi
	# Save original content for comparison
	local original_content
	original_content=$(cat "$test_dir/corrupt_test2.txt")
	# Corrupt the par2 file
	par2_size=$($STAT -c %s "$test_dir/.corrupt_test2.txt.par2")
	corrupt_pos=$((par2_size / 2))
	test_debug "Corrupting second par2 file at position $corrupt_pos"
	printf 'X' | dd of="$test_dir/.corrupt_test2.txt.par2" bs=1 seek="$corrupt_pos" count=1 conv=notrunc
	# Verify should succeed due to par2's built-in redundancy
	if ! verify_par2s "$test_dir/corrupt_test2.txt" >/dev/null; then
		test_error "verify_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	# Check that original file is unchanged
	if [[ "$(cat "$test_dir/corrupt_test2.txt")" != "$original_content" ]]; then
		test_error "Original file was modified during verify"
		((test_fails++))
	fi
	test_debug "Verify succeeded, demonstrating par2's resilience to corruption"
	
	# Test update command with orphaned par2 files
	test_debug "Testing update command with orphaned par2 files"
	# Create test files in a subdirectory
	local update_test_dir="$test_dir/update_test"
	mkdir -p "$update_test_dir/subdir"
	echo "test file 1" > "$update_test_dir/file1.txt"
	echo "test file 2" > "$update_test_dir/file2.txt"
	echo "test file 3" > "$update_test_dir/subdir/file3.txt"
	
	# Create initial par2 files
	create_par2s "$update_test_dir"
	
	# Manually create volume-based par2 files to simulate legacy par2 files
	cp "$update_test_dir/.file2.txt.par2" "$update_test_dir/.file2.txt.vol0+1.par2"
	cp "$update_test_dir/.file2.txt.par2" "$update_test_dir/.file2.txt.vol0+2.par2"
	cp "$update_test_dir/.file1.txt.par2" "$update_test_dir/.file1.txt.vol0+1.par2"
	
	# Remove one of the source files to create an orphaned par2 set
	rm "$update_test_dir/file2.txt"
	
	# Run update
	update_par2s "$update_test_dir"
	
	# Verify entire par2 set for file2.txt was removed
	if [[ -f "$update_test_dir/.file2.txt.par2" ]] || \
	   [[ -f "$update_test_dir/.file2.txt.vol0+1.par2" ]] || \
	   [[ -f "$update_test_dir/.file2.txt.vol0+2.par2" ]]; then
		test_error "Orphaned par2 set was not completely removed"
		((test_fails++))
	fi
	
	# Verify par2 set for file1.txt still exists completely
	if [[ ! -f "$update_test_dir/.file1.txt.par2" ]] || \
	   [[ ! -f "$update_test_dir/.file1.txt.vol0+1.par2" ]]; then
		test_error "Valid par2 set was incorrectly removed"
		((test_fails++))
	fi
	
	# Verify regular par2 file for file3.txt still exists
	if [[ ! -f "$update_test_dir/subdir/.file3.txt.par2" ]]; then
		test_error "Valid par2 file was incorrectly removed"
		((test_fails++))
	fi
	
	# Test dotfile handling
	if ! test_dotfile_handling; then
		test_error "Dotfile handling test failed"
		((test_fails++))
	fi
	
	if ((test_fails > 0)); then
		test_error "Tests failed: $test_fails"
		return $test_fails
	fi

	echo "All tests passed"
	return 0
}

test_corruption_patterns() {
	local test_dir
	test_dir=$(mktemp --tmpdir -d par2_dir_corruption.XXXXXX)
	local test_fails=0
	trap 'rm -rf "$test_dir"' EXIT

	test_debug "Testing par2 repair capabilities with different corruption patterns..."
	
	# Generate 100KB random file
	dd if=/dev/urandom of="$test_dir/test.bin" bs=1024 count=100
	test_debug "Created test file: $test_dir/test.bin"
	
	# Create par2 with 5% redundancy using our interface
	"$0" create "$test_dir/test.bin"
	test_debug "Created par2 file with 5% redundancy"
	test_debug "$(ls -l "$test_dir")"
	
	# Test 1: Corrupt first 4KB
	cp "$test_dir/test.bin" "$test_dir/test1.bin"
	dd if=/dev/zero of="$test_dir/test1.bin" bs=4096 count=1 conv=notrunc
	test_debug "Testing repair of first 4KB corruption..."
	if ! "$0" repair "$test_dir/test1.bin"; then
		test_error "Failed to repair first 4KB corruption"
		((test_fails++))
	fi
	test_debug "First 4KB corruption test passed"
	
	# Test 2: Corrupt last 4KB
	cp "$test_dir/test.bin" "$test_dir/test2.bin"
	dd if=/dev/zero of="$test_dir/test2.bin" bs=4096 seek=24 count=1 conv=notrunc
	test_debug "Testing repair of last 4KB corruption..."
	if ! "$0" repair "$test_dir/test2.bin"; then
		test_error "Failed to repair last 4KB corruption"
		((test_fails++))
	fi
	test_debug "Last 4KB corruption test passed"
	
	# Test 3: Corrupt middle 4KB
	cp "$test_dir/test.bin" "$test_dir/test3.bin"
	dd if=/dev/zero of="$test_dir/test3.bin" bs=4096 seek=12 count=1 conv=notrunc
	test_debug "Testing repair of middle 4KB corruption..."
	if ! "$0" repair "$test_dir/test3.bin"; then
		test_error "Failed to repair middle 4KB corruption"
		((test_fails++))
	fi
	test_debug "Middle 4KB corruption test passed"
	
	# Test 4: Corrupt 8 random 512-byte chunks
	cp "$test_dir/test.bin" "$test_dir/test4.bin"
	# Use a deterministic seed for reproducibility
	RANDOM=42
	test_debug "Testing repair of 8 random 512-byte corruptions..."
	for i in {1..8}; do
		offset=$((RANDOM % (100*1024/512)))  # Random position within file (in 512-byte blocks)
		dd if=/dev/zero of="$test_dir/test4.bin" bs=512 seek=$offset count=1 conv=notrunc
		test_debug "Corrupted 512 bytes at offset: $((offset * 512)) bytes"
	done
	if ! "$0" repair "$test_dir/test4.bin"; then
		test_error "Failed to repair random 512-byte corruptions"
		((test_fails++))
	else
		test_debug "Random corruption test passed"
	fi
	
	if ((test_fails > 0)); then
		test_error "Corruption pattern tests failed: $test_fails"
		return $test_fails
	else
		test_debug "All corruption pattern tests passed!"
		return 0
	fi
}

test_dotfile_handling() {
	local test_dir
	test_dir=$(mktemp --tmpdir -d par2_dir_dotfiles.XXXXXX)
	local test_fails=0
	test_debug "DEBUG: Testing dotfile handling in directory: $test_dir"
	
	# Create test files
	echo "test content" > "$test_dir/regular.txt"
	echo "dotfile content" > "$test_dir/.hidden"
	echo "ds store content" > "$test_dir/.DS_Store"
	
	# Test with PROTECT_DOTFILES=0 (default)
	PROTECT_DOTFILES=0 create_par2s "$test_dir"
	
	# Verify only regular file has par2
	[[ -f "$test_dir/.regular.txt.par2" ]] || { test_error "Par2 not created for regular file" ; ((test_fails++)) }
	[[ ! -f "$test_dir/..hidden.par2" ]] || { test_error "Par2 created for hidden file when PROTECT_DOTFILES=0" ; ((test_fails++)) }
	[[ ! -f "$test_dir/..DS_Store.par2" ]] || { test_error "Par2 created for .DS_Store when PROTECT_DOTFILES=0" ; ((test_fails++)) }
	
	# Test with PROTECT_DOTFILES=1
	PROTECT_DOTFILES=1 create_par2s "$test_dir"
	
	# Verify all files have par2s
	[[ -f "$test_dir/.regular.txt.par2" ]] || { test_error "Par2 not created for regular file" ; ((test_fails++)) }
	[[ -f "$test_dir/..hidden.par2" ]] || { test_error "Par2 not created for hidden file when PROTECT_DOTFILES=1" ; ((test_fails++)) }
	[[ -f "$test_dir/..DS_Store.par2" ]] || { test_error "Par2 not created for .DS_Store when PROTECT_DOTFILES=1" ; ((test_fails++)) }
	
	# Test update with PROTECT_DOTFILES=0
	rm "$test_dir/.hidden"
	PROTECT_DOTFILES=0 update_par2s "$test_dir"
	
	# Verify dotfile par2s are ignored
	[[ -f "$test_dir/..hidden.par2" ]] || { test_error "Orphaned hidden file par2 removed when PROTECT_DOTFILES=0" ; ((test_fails++)) }
	
	# Test update with PROTECT_DOTFILES=1
	PROTECT_DOTFILES=1 update_par2s "$test_dir"
	
	# Verify orphaned dotfile par2s are removed
	[[ ! -f "$test_dir/..hidden.par2" ]] || { test_error "Orphaned hidden file par2 not removed when PROTECT_DOTFILES=1" ; ((test_fails++)) }
	[[ -f "$test_dir/..DS_Store.par2" ]] || { test_error "Existing dotfile par2 removed when PROTECT_DOTFILES=1" ; ((test_fails++)) }
	
	rm -rf "$test_dir"
	
	if ((test_fails > 0)); then
		test_error "Dotfile handling tests failed: $test_fails"
		return $test_fails
	else
		test_debug "All dotfile handling tests passed!"
		return 0
	fi
}

test_resource_fork_handling() {
	# Skip this test on non-macOS systems
	if ! is_macos; then
		test_debug "Skipping resource fork tests on non-macOS system"
		return 0
	fi

	local test_dir
	test_dir=$(mktemp --tmpdir -d par2_dir_rsrc.XXXXXX)
	local test_fails=0
	test_debug "Testing in directory: $test_dir"

	# Create a test file with resource fork
	local test_file="$test_dir/test.txt"
	local test_file_rsrc="$test_file/..namedfork/rsrc"
	echo "Main content" > "$test_file"
	echo "Resource fork content" > "$test_file_rsrc"

	# Test has_resource_fork function
	if ! has_resource_fork "$test_file"; then
		test_error "has_resource_fork failed to detect resource fork"
		((test_fails++))
	fi

	# Test create on file with resource fork
	if ! create_par2s "$test_file" >/dev/null; then
		test_error "create_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Verify both par2 files were created (one for data fork, one for resource fork)
	if [[ ! -f "$test_dir/.test.txt.par2" ]]; then
		test_error "Par2 file not created for data fork"
		((test_fails++))
	fi
	if [[ ! -f "$test_dir/.test.txt.rsrc.par2" ]]; then
		test_error "Par2 file not created for resource fork"
		((test_fails++))
	fi

	# Test verify on file with resource fork
	if ! verify_par2s "$test_file" >/dev/null; then
		test_error "verify_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Test repair on file with resource fork
	# First, record the original modification time
	local tmpfile_mtime=$(mktemp --tmpdir par2_dir_mtime.XXXXXX)
	$TOUCH -r "$test_file" "$tmpfile_mtime"

	# local test_file_mtime=$($STAT -c%Y "$test_file") # GNU stat expected!
	# local test_file_rsrc_mtime=$($STAT -c%Y "$test_file_rsrc") # GNU stat expected!
	# Then corrupt both forks
	echo "Xain content" > "$test_file"
	echo "Xesource fork content" > "$test_file_rsrc"
	# Then restore the original modification time using gtouch
	# and the original file mod time stored on the temp file
	$TOUCH -r "$tmpfile_mtime" "$test_file"
	rm "$tmpfile_mtime"
	
	if ! repair_par2s "$test_file" >/dev/null; then
		test_error "repair_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Verify both forks were repaired
	if ! grep -q "Main content" "$test_file"; then
		test_error "repair_par2s did not restore data fork content"
		((test_fails++))
	fi
	if ! grep -q "Resource fork content" "$test_file_rsrc"; then
		test_error "repair_par2s did not restore resource fork content"
		((test_fails++))
	fi

	# Test clear on file with resource fork
	if ! clear_par2s "$test_file" >/dev/null; then
		test_error "clear_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Verify both par2 files were removed
	if [[ -f "$test_dir/.test.txt.par2" ]]; then
		test_error "Par2 file not removed for data fork"
		((test_fails++))
	fi
	if [[ -f "$test_dir/.test.txt.rsrc.par2" ]]; then
		test_error "Par2 file not removed for resource fork"
		((test_fails++))
	fi

	rm -rf "$test_dir"
	return "$test_fails"
}

test_all() {
	local total_fails=0
	local test_fails

	# Redirect all output to /dev/null unless DEBUG is set
	if ! debug_mode; then
		exec 3>&1 4>&2  # Save original stdout/stderr
		# Pipe all output through grep to only show TEST ERROR/DEBUG lines
		exec 1> >(grep "^(TEST ERROR|TEST DEBUG):" || true) 2>&1
	fi

	test_suite
	test_fails=$?
	((total_fails += test_fails))

	test_dotfile_handling
	test_fails=$?
	((total_fails += test_fails))

	test_resource_fork_handling
	test_fails=$?
	((total_fails += test_fails))

	test_corruption_patterns
	test_fails=$?
	((total_fails += test_fails))

	# Restore original stdout/stderr if we redirected them
	if ! debug_mode; then
		exec 1>&3 2>&4
	fi

	if ((total_fails == 0)); then
		echo "All tests passed"
	else
		echo "Tests failed: $total_fails"
	fi

	return "$total_fails"
}

# Main execution (if script is run directly)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	command="$1"
	directory="$2"

	ensure_target_arg_provided() {
		if [[ $# -eq 0 ]]; then
			echo -ne "Error: No action specified. Use --help to see available actions.\n\n" >&2
			show_help
			exit 1
		fi
	}
	
	ensure_target_arg_provided "$@"
	
	case "$command" in
		help|-h|--help)
			show_help
			exit 0
			;;
		test)
			test_all
			exit $?
			;;
		create|update|verify|repair|clear|stats)
			if [[ -z "$directory" ]]; then
				echo -ne "Error: No target specified. Please provide a file or directory path.\n\n" >&2
				show_help
				exit 1
			fi
			"${command}_par2s" "$directory"
			exit $?
			;;
		*)
			echo -ne "Error: Unknown action '$command'. Use --help to see available actions.\n\n" >&2
			show_help
			exit 1
			;;
	esac
fi
