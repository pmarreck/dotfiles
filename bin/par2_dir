#!/usr/bin/env bash

# Enable strict mode- disabled for now pending future effort because it silently broke things
# set -euo pipefail

IFS=$'\n\t'

# Get number of CPU cores based on OS
get_cpu_cores() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sysctl -n hw.ncpu
    else
        nproc
    fi
}

# Set number of par2 threads, allowing override via environment variable
: "${NUM_PAR2_THREADS:=$(get_cpu_cores)}"
PAR2_REDUNDANCY=${PAR2_REDUNDANCY:-5}
PROTECT_DOTFILES=${PROTECT_DOTFILES:-0}

# Warn if redundancy is set too high
if ((PAR2_REDUNDANCY > 20)); then
    echo "Warning: PAR2_REDUNDANCY is set to ${PAR2_REDUNDANCY}%. This tool is designed for protecting against small corruptions (bitrot, sector failures) and not for full file recovery. Consider using a lower value (5-20%) to save space." >&2
fi

check_dependencies() {
	local dependencies=(gtouch gstat sed)
	local missing=()
	for dep in "${dependencies[@]}"
	do
		if ! command -v "$dep" &> /dev/null
		then
			missing+=("$dep")
		fi
	done
	if ! sed --help | grep -q "GNU sed"
	then
		missing+=("GNU sed")
	fi
	if [[ "${#missing[@]}" > 0 ]]
	then
		printf "Missing dependencies: %s\n" "${missing[*]}"
		exit 1
	fi
}

check_dependencies

# Utility function to sanitize filenames for par2
sanitize_filename() {
	local filename="$1"
	# Replace wildcards, question marks, and other problematic characters with underscores
	echo "$filename" | sed -E 's/[*?]/_/g; s/:/_/g; s/\\/_/g'
}

# Utility function to get corresponding par2 path
get_par2_path() {
	local orig_path="$1"
	local base_dir=$(dirname "$orig_path")
	local base_name=$(basename "$orig_path")
	local sanitized_name=$(sanitize_filename "$base_name")
	local par2_path="${base_dir}/.${sanitized_name}.par2"
	echo "$par2_path"
}

get_abs_directory() {
	local directory="$1"
	local abs_directory
	# Check if directory exists	
	# resolve it to an absolute path
	abs_directory=$(readlink -f "$directory")
	if [[ ! -d "$abs_directory" ]]; then
		echo "Error: Directory '$directory' does not exist" >&2
		return 1
	fi
	echo "$abs_directory"
}

remove_par2_files_for_file() {
	local file="$1"
	local dir_path=$(dirname "$file")
	local basefilename=$(basename "$file")
	local sanitized_name=$(sanitize_filename "$basefilename")
	local files=()
	# trying to glob while preserving spaces in paths is disgusting in Bash /shrug
	shopt -s nullglob
	files=("$dir_path/.$sanitized_name"*.par2)
	for file in "${files[@]}"; do
		rm -f "$file" 2>/dev/null
	done
	shopt -u nullglob
}

# Set AWK to the best available awk implementation
setup_awk() {
	local which_awk=$(command -v awk)
	command -v gawk >/dev/null 2>&1 && which_awk=$(command -v gawk)
	command -v frawk >/dev/null 2>&1 && which_awk=$(command -v frawk)
	debug "Using awk implementation: $which_awk"
	echo "$which_awk"
}

# Initialize AWK variable
AWK=$(setup_awk)
export AWK

# Calculate optimal block size for par2 based on file size
calculate_block_size() {
	local file_size="$1"
	local block_size
	
	# Calculate everything in one awk invocation:
	# - Convert to KB
	# - Calculate percentage using double exponential decay
	# - Calculate block size
	# - Enforce minimum of 4 bytes
	# - Round up to nearest multiple of 4
	read -r block_size < <($AWK -v size="$file_size" '
		BEGIN {
			# Convert to KB
			k = size / 1024
			
			# Calculate percentage using double exponential decay:
			# 1.2: Base percentage (asymptotic minimum)
			# 2.0 * exp(-0.001 * k): Slow decay term for gradual reduction from 1MB to 10MB
			# 21 * exp(-0.3 * k): Fast decay term for steep initial drop from 1KB to 100KB
			percent = 1.2 + 2.0 * exp(-0.001 * k) + 21 * exp(-0.3 * k)
			
			# Calculate block size in bytes
			block_size = int((size * percent) / 100)
			
			# Ensure minimum block size of 4
			if (block_size < 4) block_size = 4
			
			# Round up to nearest multiple of 4
			block_size = int((block_size + 3) / 4) * 4
			
			print block_size
		}
	')
	
	echo "$block_size"
}

# Function to check if a file should be processed
should_process_file() {
	local file="$1"
	local basename
	basename=$(basename "$file")
	
	# Skip par2 files
	[[ "$basename" == *.par2 ]] && return 1
	[[ "$basename" == .*.par2 ]] && return 1
	
	# Skip dotfiles unless PROTECT_DOTFILES is enabled
	if [[ "$PROTECT_DOTFILES" != "1" && "$basename" == .* ]]; then
		return 1
	fi
	
	return 0
}

# Check if we're on macOS
is_macos() {
	[[ "$OSTYPE" == "darwin"* ]]
}

# Check if a file has a resource fork (macOS only)
has_resource_fork() {
	local file="$1"
	[[ -f "${file}.rsrc" ]]
}

# Get the path to a file's resource fork (macOS only)
get_resource_fork_path() {
	local file="$1"
	echo "${file}.rsrc"
}

# Get par2 path for resource fork (macOS only)
get_resource_fork_par2_path() {
	local file="$1"
	if ! is_macos; then
		return 1
	fi
	local base_dir=$(dirname "$file")
	local base_name=$(basename "$file")
	local sanitized_name=$(sanitize_filename "$base_name")
	echo "${base_dir}/.${sanitized_name}.rsrc.par2"
}

# Process a single file for par2 operations
process_single_file() {
	local file="$1"
	local operation="$2"  # create, verify, repair, clear, update, stats
	local par2_file
	local resource_par2_file
	local file_size_bytes
	local block_size_bytes
	local par2_output
	local file_time
	local par2_time
	local has_rsrc=0
	
	# Skip if file doesn't exist or is a par2 file
	if [[ ! -f "$file" ]] || [[ "$file" == *.par2 ]] || [[ "$file" == .*.par2 ]]; then
		return 0
	fi

	if ! should_process_file "$file"; then
		return 0
	fi

	par2_file=$(get_par2_path "$file")
	
	# Check for resource fork
	if has_resource_fork "$file"; then
		has_rsrc=1
		resource_par2_file=$(get_resource_fork_par2_path "$file")
	fi
	
	case "$operation" in
		create)
			if [[ -f "$par2_file" ]]; then
				# Get absolute path for consistent output
				local abs_file
				abs_file=$(readlink -f "$file")
				echo "$abs_file - Exists"
				debug "Skipping $file: par2 file already exists"
				return 0
			fi
			
			debug "Creating par2 for file: $file"
			debug "Par2 file will be: $par2_file"
			
			# Get directory of file
			local file_dir
			file_dir=$(dirname "$file")
			
			file_size_bytes=$(gstat -c %s "$file")
			block_size_bytes=$(calculate_block_size "$file_size_bytes")
			
			debug "Processing file: $file"
			debug "File size: $file_size_bytes bytes, Block size: $block_size_bytes bytes"
			
			debug "PAR2 command: par2 create -s$block_size_bytes -r$PAR2_REDUNDANCY -n1 -T\"$NUM_PAR2_THREADS\" \"$par2_file\" \"$file\""
			
			# Get absolute path for consistent output
			local abs_file
			abs_file=$(readlink -f "$file")
			echo -n "$abs_file"
			
			if ! par2_output=$(par2 create -s"$block_size_bytes" -r"$PAR2_REDUNDANCY" -n1 -T"$NUM_PAR2_THREADS" "$par2_file" "$file" 2>&1); then
				echo -e "\nError creating par2 for $abs_file" >&2
				debug "Detailed error output: $par2_output"
				return 1
			fi

			# Handle resource fork if present
			if [[ $has_rsrc -eq 1 ]]; then
				local rsrc_path=$(get_resource_fork_path "$file")
				local rsrc_size_bytes=$(gstat -c %s "$rsrc_path")
				local rsrc_block_size_bytes=$(calculate_block_size "$rsrc_size_bytes")
				
				debug "Creating par2 for resource fork: $rsrc_path"
				debug "Resource fork par2 file will be: $resource_par2_file"
				
				if ! par2_output=$(par2 create -s"$rsrc_block_size_bytes" -r"$PAR2_REDUNDANCY" -n1 -T"$NUM_PAR2_THREADS" "$resource_par2_file" "$rsrc_path" 2>&1); then
					echo -e "\nError creating par2 for resource fork of $abs_file" >&2
					debug "Detailed error output: $par2_output"
					return 1
				fi
			fi
			
			echo " - Done."
			debug "PAR2 output: $par2_output"
			debug "Par2 file created: $(ls -l "$par2_file")"
			;;
			
		verify)
			[[ ! -f "$par2_file" ]] && return 0
			debug "Verifying file: $file"
			debug "Using par2 file: $par2_file"
			debug "PAR2 command: par2 verify \"$par2_file\""
			if ! par2_output=$(par2 verify "$par2_file" 2>&1); then
				echo "Verification failed for $(readlink -f "$file")" >&2
				debug "Detailed error output: $par2_output"
				return 1
			fi
			
			# Verify resource fork if present
			if [[ $has_rsrc -eq 1 && -f "$resource_par2_file" ]]; then
				debug "Verifying resource fork"
				if ! par2_output=$(par2 verify "$resource_par2_file" 2>&1); then
					echo "Resource fork verification failed for $(readlink -f "$file")" >&2
					debug "Detailed error output: $par2_output"
					return 1
				fi
			fi
			debug "PAR2 output: $par2_output"
			;;
			
		repair)
			[[ ! -f "$par2_file" ]] && return 0
			debug "Repairing file: $file"
			debug "Using par2 file: $par2_file"
			debug "File exists: $(ls -l "$file")"
			debug "Par2 file exists: $(ls -l "$par2_file")"
			debug "Directory contents before repair: $(ls -la "$(dirname "$file")")"
			debug "File content before repair: $(cat "$file")"
			debug "Par2 file content (hex): $(xxd -p "$par2_file" | head -n 1)"
			
			debug "PAR2 command: par2 repair -q \"$par2_file\""
			if ! par2_output=$(par2 repair -q "$par2_file" 2>&1); then
				echo "Repair failed for $(readlink -f "$file")" >&2
				debug "Detailed error output: $par2_output"
				return 1
			fi
			
			# Repair resource fork if present
			if [[ $has_rsrc -eq 1 && -f "$resource_par2_file" ]]; then
				debug "Repairing resource fork"
				local rsrc_path=$(get_resource_fork_path "$file")
				# Create resource fork directory if it doesn't exist
				mkdir -p "$(dirname "$rsrc_path")"
				if ! par2_output=$(par2 repair -q "$resource_par2_file" 2>&1); then
					echo "Resource fork repair failed for $(readlink -f "$file")" >&2
					debug "Detailed error output: $par2_output"
					return 1
				fi
			fi
			
			debug "PAR2 output: $par2_output"
			debug "Directory contents after repair: $(ls -la "$(dirname "$file")")"
			debug "File content after repair: $(cat "$file")"
			;;
			
		clear)
			remove_par2_files_for_file "$file"
			if [[ $has_rsrc -eq 1 ]]; then
				rm -f "$resource_par2_file" 2>/dev/null
			fi
			;;
			
		update)
			if [[ ! -f "$par2_file" ]]; then
				process_single_file "$file" create
				return $?
			fi
			
			file_time=$(gstat -c %Y "$file")
			par2_time=$(gstat -c %Y "$par2_file")
			
			local needs_update=0
			if (( file_time > par2_time )); then
				needs_update=1
			fi
			
			# Check resource fork if present
			if [[ $has_rsrc -eq 1 && -f "$resource_par2_file" ]]; then
				local rsrc_time=$(gstat -c %Y "$(get_resource_fork_path "$file")")
				local rsrc_par2_time=$(gstat -c %Y "$resource_par2_file")
				if (( rsrc_time > rsrc_par2_time )); then
					needs_update=1
				fi
			elif [[ $has_rsrc -eq 1 ]]; then
				# Resource fork exists but no par2 file for it
				needs_update=1
			fi
			
			if [[ $needs_update -eq 1 ]]; then
				debug "File or resource fork is newer, regenerating"
				remove_par2_files_for_file "$file"
				[[ $has_rsrc -eq 1 ]] && rm -f "$resource_par2_file" 2>/dev/null
				process_single_file "$file" create
				return $?
			fi
			;;
			
		stats)
			local total_size=0
			total_size=$(gstat -c %s "$file")
			
			if [[ $has_rsrc -eq 1 ]]; then
				local rsrc_size=$(gstat -c %s "$(get_resource_fork_path "$file")")
				((total_size += rsrc_size))
			fi
			
			if [[ -f "$par2_file" ]] && ( [[ $has_rsrc -eq 0 ]] || [[ -f "$resource_par2_file" ]] ); then
				echo "$total_size:covered"
			else
				echo "$total_size:uncovered"
			fi
			;;
	esac
	return 0
}

# Create par2 files recursively
create_par2s() {
	local target="$1"
	
	if [[ -f "$target" ]]; then
		process_single_file "$target" create
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | while read -r file; do
		process_single_file "$file" create
	done
}

# Update par2 files
update_par2s() {
	local target="$1"
	
	if [[ -f "$target" ]]; then
		if should_process_file "$target"; then
			process_single_file "$target" update
			return $?
		fi
		return 0
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	echo "Scanning for par2 files in $target..."
	
	# Count total par2 files for progress indication
	local total_par2_files
	total_par2_files=$(find "$target" -type f -name ".*.par2" | wc -l | tr -d ' ')
	echo "Found $total_par2_files par2 files to check"
	
	# First, remove orphaned par2 files and their associated volume files
	local processed_files=0
	find "$target" -type f -name ".*.par2" | while read -r par2_file; do
		processed_files=$((processed_files + 1))
		if ((processed_files % 100 == 0)); then
			echo "Checking par2 files... ($processed_files/$total_par2_files)"
		fi
		
		local par2_dir
		par2_dir=$(dirname "$par2_file")
		local par2_base
		par2_base=$(basename "$par2_file")
		local orig_base
		
		# Extract the base name (without .par2 or .volX+Y)
		if [[ "$par2_base" =~ \.vol ]]; then
			orig_base="${par2_base%%.vol*}"
		else
			orig_base="${par2_base%.par2}"
		fi
		orig_base="${orig_base#.}"  # Remove leading dot
		
		# Skip if this is a dotfile and we're not protecting them
		if [[ "$PROTECT_DOTFILES" != "1" && "$orig_base" == .* ]]; then
			continue
		fi
		
		# Check if the original file exists
		if [[ ! -f "$par2_dir/$orig_base" ]]; then
			# Only process each set once (when we find the first file)
			if [[ ! -f "$par2_dir/.$orig_base.par2" ]] || [[ "$par2_file" == "$par2_dir/.$orig_base.par2" ]]; then
				echo "Removing orphaned par2 file: $par2_file"
				rm "$par2_dir/.$orig_base.par2" "$par2_dir/.$orig_base.vol"* 2>/dev/null || true
			fi
		fi
	done
	
	echo "Par2 file check complete"
	echo "Scanning for files needing par2 updates..."
	
	# Count total files for progress indication, excluding dotfiles if not protected
	local total_files
	if [[ "$PROTECT_DOTFILES" == "1" ]]; then
		total_files=$(find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | wc -l | tr -d ' ')
	else
		total_files=$(find "$target" -type f -not -name ".*" -not -name "*.par2" -not -name ".*.par2" | wc -l | tr -d ' ')
	fi
	echo "Found $total_files files to process"
	
	# Then update/create par2 files as needed
	processed_files=0
	find "$target" -type f | while read -r file; do
		if ! should_process_file "$file"; then
			continue
		fi
		processed_files=$((processed_files + 1))
		if ((processed_files % 100 == 0)); then
			echo "Processing files... ($processed_files/$total_files)"
		fi
		process_single_file "$file" update
	done
	
	echo "Update complete"
}

# Verify par2 files recursively
verify_par2s() {
	local target="$1"
	local exit_code=0
	
	if [[ -f "$target" ]]; then
		process_single_file "$target" verify
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | while read -r file; do
		if ! process_single_file "$file" verify; then
			exit_code=1
		fi
	done
	
	return $exit_code
}

# Repair files using par2
repair_par2s() {
	local target="$1"
	local exit_code=0
	
	debug "Attempting repair on target: $target"
	
	if [[ -f "$target" ]]; then
		debug "Target is a file, calling process_single_file"
		process_single_file "$target" repair
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	debug "Target is a directory, processing files recursively"
	find "$target" -type f -not -name "*.par2" -not -name ".*.par2" | while read -r file; do
		debug "Processing file in directory: $file"
		if ! process_single_file "$file" repair; then
			exit_code=1
		fi
	done
	
	return $exit_code
}

# Clear all par2 files
clear_par2s() {
	local target="$1"
	
	if [[ -f "$target" ]]; then
		process_single_file "$target" clear
		return $?
	fi
	
	if [[ ! -d "$target" ]]; then
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	find "$target" -type f -name "*.par2" | while read -r par2_file; do
		echo "Removing: $par2_file"
		rm "$par2_file"
	done
}

# Calculate par2 coverage statistics
stats_par2s() {
	local target="$1"
	local covered_bytes=0
	local uncovered_bytes=0
	local coverage_percent=0
	local stats_output=""
	
	if [[ -f "$target" ]]; then
		stats_output=$(process_single_file "$target" stats)
		IFS=: read -r bytes status <<< "$stats_output"
		if [[ "$status" == "covered" ]]; then
			covered_bytes=$((covered_bytes + bytes))
		else
			uncovered_bytes=$((uncovered_bytes + bytes))
		fi
	elif [[ -d "$target" ]]; then
		local file_count=0
		while IFS= read -r file; do
			((file_count++))
			stats_output=$(process_single_file "$file" stats)
			IFS=: read -r bytes status <<< "$stats_output"
			if [[ "$status" == "covered" ]]; then
				covered_bytes=$((covered_bytes + bytes))
			else
				uncovered_bytes=$((uncovered_bytes + bytes))
			fi
		done < <(find "$target" -type f -not -name "*.par2" -not -name ".*.par2")
		
		# If no files were found, still output stats with zeros
		if [[ $file_count -eq 0 ]]; then
			echo "Total bytes: 0"
			echo "Covered bytes: 0"
			echo "Uncovered bytes: 0"
			echo "Coverage: 100.00%"
			return 0
		fi
	else
		echo "Error: $target is not a file or directory" >&2
		return 1
	fi
	
	local total_bytes=$((covered_bytes + uncovered_bytes))
	if [[ $total_bytes -gt 0 ]]; then
		coverage_percent=$(echo "scale=2; ($covered_bytes * 100) / $total_bytes" | bc)
	else
		coverage_percent="100.00"
	fi
	
	# Output statistics
	echo "Total bytes: $total_bytes"
	echo "Covered bytes: $covered_bytes"
	echo "Uncovered bytes: $uncovered_bytes"
	echo "Coverage: ${coverage_percent}%"
}

# Debug output function
debug() {
	[ -n "${DEBUG}" ] && echo "DEBUG: $*" >&2
}

# Test output function
test_error() {
	echo "TEST ERROR: $*" >&2
	return 1
}

# Print usage information
show_help() {
	local cmd_name
	cmd_name=$(basename "$0")
	cat >&2 <<EOF
${cmd_name} - Create and manage file redundancy at the directory level

Usage: $cmd_name <command> [<file_or_directory>]

Commands:
  help     Display this help message
  create   Create par2 files for all files in directory or a single file
  update   Update par2 files for modified files in directory or a single file
  verify   Verify all par2 files in directory or a single file
  repair   Repair any corrupted files in directory or a single file
  clear    Remove all par2 files in directory or for a single file
  stats    Show par2 coverage statistics for directory or a single file
  test     Run test suite

par2 by default works at the individual file level and allows you to specify
a percentage of repairable redundancy (5% by default). This means that up to 5%
of the file's content can be corrupted before the file is considered beyond repair.
This extra information is written into par2 files which add about 5% to the total
space used.

${cmd_name} applies this at the directory level, across every file, recursively.
The par2 files are created as hidden files (prefixed with .) in the same
directory as the source files. Each set of par2 files includes a fixed 5% redundancy.
Block size is calculated as a percentage of the original file size using
a double exponential decay formula (previously empirically determined):
  1.2: Base percentage (asymptotic minimum)
  2.0 * e^(-0.001 * k): Slow decay term for gradual reduction from 1MB to 10MB
  21 * e^(-0.3 * k): Fast decay term for steep initial drop from 1KB to 100KB (increased from 20)
where k is the file size in kilobytes (KB). With 5% redundancy, this provides
optimal block sizes:
  ~18-21% of file size for 1KB files
    (note that small files are inefficient with par2 currently,
    regardless of block size)
  ~4-7% of file size for 10KB files
  ~3-5% of file size for 50-100KB files
  ~1.2-2% of file size for 1MB files
  ~1.2% of file size for 10MB+ files
  The block size is always rounded up to the nearest multiple of 4 bytes
  (per par2 requirements).

Environment Variables:
  NUM_PAR2_THREADS  Number of threads to use for par2 operations
                    Defaults to the number of CPU cores if not set
                    Example: NUM_PAR2_THREADS=4 ./par2_dir create /path/to/dir
  PAR2_REDUNDANCY   Par2 redundancy percentage (5 means roughly 5% extra data for recovery)
                    Defaults to 5 if not set
                    Example: PAR2_REDUNDANCY=10 ./par2_dir create /path/to/dir
  PROTECT_DOTFILES  Protect dotfiles (files starting with .) from par2 operations
                    Defaults to 0 (false) if not set
                    Example: PROTECT_DOTFILES=1 ./par2_dir create /path/to/dir

Dependencies:
par2, of course (the Nix package I used is par2cmdline-turbo).
The GNU (not BSD which is the Mac default!) versions of stat, touch and sed
are currently required. You can install these via homebrew or your distro's
package manager (although in the case of Linux, these are likely the default).
It is assumed that these tools are available in the PATH via gstat, gtouch
and sed. (On Nix[OS]/nix-darwin, the coreutils-prefixed package provides this,
in case you don't want to shadow the BSD versions, which I recommend.)
EOF
}

test_suite() {
	test_dir=$(mktemp -d)
	test_fails=0
	debug "Testing in directory: $test_dir"
	debug "Testing with $NUM_PAR2_THREADS threads"
	
	# Test 1: Create par2 files for directory
	debug "Testing directory creation..."
	if ! create_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "create_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 2: Verify par2 files for directory
	debug "Testing directory verification..."
	if ! verify_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "verify_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 3: Update par2 files for directory
	debug "Testing directory update..."
	if ! update_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "update_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 4: Repair par2 files for directory
	debug "Testing directory repair..."
	if ! repair_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	
	# Test 5: Clear par2 files for directory
	debug "Testing directory clear..."
	if ! clear_par2s "$test_dir" >/dev/null 2>&1; then
		test_error "clear_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 6: Stats for directory
	debug "Testing directory stats..."
	local stats_output
	stats_output=$(stats_par2s "$test_dir")
	if ! echo "$stats_output" | grep -q "Coverage: 100.00%"; then
		test_error "stats_par2s failed on directory"
		((test_fails++))
	fi
	
	# Test 7: Create par2 files for non-existent directory
	debug "Testing non-existent directory creation..."
	if create_par2s "/non/existent/directory" >/dev/null 2>&1; then
		test_error "create_par2s should fail on non-existent directory"
		((test_fails++))
	fi
	
	# Test 8: Single file operations
	debug "Testing single file operations..."
	
	# Create a test file
	echo "This is a test file for single file operations" > "$test_dir/single.txt"
	
	# Test create on single file
	if ! create_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed on single file"
		((test_fails++))
	fi
	
	# Verify par2 file was created
	if [[ ! -f "$test_dir/.single.txt.par2" ]]; then
		test_error "Par2 file not created for single file"
		((test_fails++))
	fi
	
	# Test verify on single file
	if ! verify_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "verify_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test repair on single file
	debug "Starting repair test"
	# First clear any existing par2 files
	debug "Clearing existing par2 files"
	if ! clear_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed before repair test"
		((test_fails++))
	fi
	# Create par2 file for original content
	debug "Creating par2 file for original content"
	if ! create_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before repair test"
		((test_fails++))
	fi
	debug "Checking if par2 file exists: $(ls -la "$test_dir/.single.txt.par2" 2>/dev/null || echo "not found")"
	# Then corrupt the file
	debug "Corrupting file"
	sed -i 's/test/tXst/' "$test_dir/single.txt"
	debug "Corrupted file content: $(cat "$test_dir/single.txt")"
	debug "Attempting repair"
	if ! repair_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	debug "Checking repaired file content: $(cat "$test_dir/single.txt")"
	# Verify file was repaired
	if ! grep -q "This is a test file for single file operations" "$test_dir/single.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	fi
	if ! verify_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "Verification failed after repair"
		((test_fails++))
	else
		debug "Repair of $test_dir/single.txt succeeded, demonstrating par2's resilience to corruption"
	fi
	
	# Test update on single file
	echo "Modified content" > "$test_dir/single.txt"
	if ! update_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "update_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test stats on single file
	local single_stats
	single_stats=$(stats_par2s "$test_dir/single.txt")
	if ! echo "$single_stats" | grep -q "Coverage: 100.00%"; then
		test_error "stats_par2s failed on single file"
		((test_fails++))
	fi
	
	# Test clear on single file
	if ! clear_par2s "$test_dir/single.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed on single file"
		((test_fails++))
	fi
	
	# Verify par2 file was removed
	if [[ -f "$test_dir/.single.txt.par2" ]]; then
		test_error "Par2 file not removed for single file"
		((test_fails++))
	fi
	
	# Test with filename containing special characters
	debug "Testing filename with special characters..."
	echo "This is a test file with special characters" > "$test_dir/test*file?.txt"
	
	# Test create on file with special characters
	if ! create_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Verify par2 file was created with sanitized name
	if [[ ! -f "$test_dir/.test_file_.txt.par2" ]]; then
		test_error "Par2 file not created for file with special characters"
		((test_fails++))
	fi
	
	# Test verify on file with special characters
	if ! verify_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "verify_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Test repair on file with special characters
	# First clear any existing par2 files
	if ! clear_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed before repair test"
		((test_fails++))
	fi
	# Create par2 file for original content
	if ! create_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before repair test"
		((test_fails++))
	fi
	# Then corrupt the file
	sed -i 's/characters/characXers/' "$test_dir/test*file?.txt"
	if ! repair_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "repair_par2s failed on file with special characters"
		((test_fails++))
	fi
	# Verify file was repaired
	if ! grep -q "This is a test file with special characters" "$test_dir/test*file?.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	fi
	
	# Test clear on file with special characters
	if ! clear_par2s "$test_dir/test*file?.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed on file with special characters"
		((test_fails++))
	fi
	
	# Verify par2 file was removed
	if [[ -f "$test_dir/.test_file_.txt.par2" ]]; then
		test_error "Par2 file not removed for file with special characters"
		((test_fails++))
	fi
	
	# Test high redundancy warning
	debug "Testing high redundancy warning..."
	local warning_output
	warning_output=$(PAR2_REDUNDANCY=100 "$0" create "$test_dir/single.txt" 2>&1)
	if ! echo "$warning_output" | grep -q "Warning: PAR2_REDUNDANCY is set to 100%"; then
		test_error "High redundancy warning not shown"
		((test_fails++))
	fi
	
	# Test normal redundancy (no warning)
	debug "Testing normal redundancy..."
	warning_output=$(PAR2_REDUNDANCY=5 "$0" create "$test_dir/single.txt" 2>&1)
	if echo "$warning_output" | grep -q "Warning: PAR2_REDUNDANCY"; then
		test_error "Warning shown for normal redundancy"
		((test_fails++))
	fi
	
	# Test corrupted par2 data
	debug "Testing corrupted par2 data..."
	# Create a test file
	echo "This is a test file for par2 corruption test" > "$test_dir/corrupt_test.txt"
	# Create par2 file
	if ! create_par2s "$test_dir/corrupt_test.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before par2 corruption test"
		((test_fails++))
	fi
	# Corrupt the par2 file using dd to change a single byte in the middle
	local par2_size
	par2_size=$(gstat -c %s "$test_dir/.corrupt_test.txt.par2")
	local corrupt_pos=$((par2_size / 2))
	debug "Corrupting par2 file at position $corrupt_pos"
	printf 'X' | dd of="$test_dir/.corrupt_test.txt.par2" bs=1 seek="$corrupt_pos" count=1 conv=notrunc 2>/dev/null
	# Now corrupt the original file
	sed -i 's/test/tXst/' "$test_dir/corrupt_test.txt"
	# Try to repair - this should succeed due to par2's built-in redundancy
	if ! repair_par2s "$test_dir/corrupt_test.txt" >/dev/null 2>&1; then
		test_error "repair_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	# Verify file was repaired
	if ! grep -q "This is a test file for par2 corruption test" "$test_dir/corrupt_test.txt"; then
		test_error "repair_par2s did not restore original file content"
		((test_fails++))
	else
		debug "Repair succeeded, demonstrating par2's resilience to corruption"
	fi
	
	# Test corrupted par2 data with intact original file
	debug "Testing corrupted par2 data with intact original file..."
	# Create a fresh test file
	echo "This is another test file for par2 corruption test" > "$test_dir/corrupt_test2.txt"
	# Create par2 file
	if ! create_par2s "$test_dir/corrupt_test2.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed before second par2 corruption test"
		((test_fails++))
	fi
	# Save original content for comparison
	local original_content
	original_content=$(cat "$test_dir/corrupt_test2.txt")
	# Corrupt the par2 file
	par2_size=$(gstat -c %s "$test_dir/.corrupt_test2.txt.par2")
	corrupt_pos=$((par2_size / 2))
	debug "Corrupting second par2 file at position $corrupt_pos"
	printf 'X' | dd of="$test_dir/.corrupt_test2.txt.par2" bs=1 seek="$corrupt_pos" count=1 conv=notrunc 2>/dev/null
	# Verify should succeed due to par2's built-in redundancy
	if ! verify_par2s "$test_dir/corrupt_test2.txt" >/dev/null 2>&1; then
		test_error "verify_par2s failed despite par2's built-in redundancy"
		((test_fails++))
	fi
	# Check that original file is unchanged
	if [[ "$(cat "$test_dir/corrupt_test2.txt")" != "$original_content" ]]; then
		test_error "Original file was modified during verify"
		((test_fails++))
	fi
	debug "Verify succeeded, demonstrating par2's resilience to corruption"
	
	# Test update command with orphaned par2 files
	debug "Testing update command with orphaned par2 files"
	# Create test files in a subdirectory
	local update_test_dir="$test_dir/update_test"
	mkdir -p "$update_test_dir/subdir"
	echo "test file 1" > "$update_test_dir/file1.txt"
	echo "test file 2" > "$update_test_dir/file2.txt"
	echo "test file 3" > "$update_test_dir/subdir/file3.txt"
	
	# Create initial par2 files
	create_par2s "$update_test_dir"
	
	# Manually create volume-based par2 files to simulate legacy par2 files
	cp "$update_test_dir/.file2.txt.par2" "$update_test_dir/.file2.txt.vol0+1.par2"
	cp "$update_test_dir/.file2.txt.par2" "$update_test_dir/.file2.txt.vol0+2.par2"
	cp "$update_test_dir/.file1.txt.par2" "$update_test_dir/.file1.txt.vol0+1.par2"
	
	# Remove one of the source files to create an orphaned par2 set
	rm "$update_test_dir/file2.txt"
	
	# Run update
	update_par2s "$update_test_dir"
	
	# Verify entire par2 set for file2.txt was removed
	if [[ -f "$update_test_dir/.file2.txt.par2" ]] || \
	   [[ -f "$update_test_dir/.file2.txt.vol0+1.par2" ]] || \
	   [[ -f "$update_test_dir/.file2.txt.vol0+2.par2" ]]; then
		test_error "Orphaned par2 set was not completely removed"
		return 1
	fi
	
	# Verify par2 set for file1.txt still exists completely
	if [[ ! -f "$update_test_dir/.file1.txt.par2" ]] || \
	   [[ ! -f "$update_test_dir/.file1.txt.vol0+1.par2" ]]; then
		test_error "Valid par2 set was incorrectly removed"
		return 1
	fi
	
	# Verify regular par2 file for file3.txt still exists
	if [[ ! -f "$update_test_dir/subdir/.file3.txt.par2" ]]; then
		test_error "Valid par2 file was incorrectly removed"
		return 1
	fi
	
	# Test dotfile handling
	test_dotfile_handling || return 1
	
	if ((test_fails > 0)); then
		echo "Tests failed: $test_fails"
		return 1
	fi
	echo "All tests passed"
	return 0
}

test_dotfile_handling() {
	local test_dir
	test_dir=$(mktemp -d)
	debug "DEBUG: Testing dotfile handling in directory: $test_dir"
	
	# Create test files
	echo "test content" > "$test_dir/regular.txt"
	echo "dotfile content" > "$test_dir/.hidden"
	echo "ds store content" > "$test_dir/.DS_Store"
	
	# Test with PROTECT_DOTFILES=0 (default)
	PROTECT_DOTFILES=0 create_par2s "$test_dir"
	
	# Verify only regular file has par2
	[[ -f "$test_dir/.regular.txt.par2" ]] || { echo "TEST ERROR: Par2 not created for regular file"; return 1; }
	[[ ! -f "$test_dir/..hidden.par2" ]] || { echo "TEST ERROR: Par2 created for hidden file when PROTECT_DOTFILES=0"; return 1; }
	[[ ! -f "$test_dir/..DS_Store.par2" ]] || { echo "TEST ERROR: Par2 created for .DS_Store when PROTECT_DOTFILES=0"; return 1; }
	
	# Test with PROTECT_DOTFILES=1
	PROTECT_DOTFILES=1 create_par2s "$test_dir"
	
	# Verify all files have par2s
	[[ -f "$test_dir/.regular.txt.par2" ]] || { echo "TEST ERROR: Par2 not created for regular file"; return 1; }
	[[ -f "$test_dir/..hidden.par2" ]] || { echo "TEST ERROR: Par2 not created for hidden file when PROTECT_DOTFILES=1"; return 1; }
	[[ -f "$test_dir/..DS_Store.par2" ]] || { echo "TEST ERROR: Par2 not created for .DS_Store when PROTECT_DOTFILES=1"; return 1; }
	
	# Test update with PROTECT_DOTFILES=0
	rm "$test_dir/.hidden"
	PROTECT_DOTFILES=0 update_par2s "$test_dir"
	
	# Verify dotfile par2s are ignored
	[[ -f "$test_dir/..hidden.par2" ]] || { echo "TEST ERROR: Hidden file par2 removed when PROTECT_DOTFILES=0"; return 1; }
	
	# Test update with PROTECT_DOTFILES=1
	PROTECT_DOTFILES=1 update_par2s "$test_dir"
	
	# Verify orphaned dotfile par2s are removed
	[[ ! -f "$test_dir/..hidden.par2" ]] || { echo "TEST ERROR: Orphaned hidden file par2 not removed when PROTECT_DOTFILES=1"; return 1; }
	[[ -f "$test_dir/..DS_Store.par2" ]] || { echo "TEST ERROR: Existing dotfile par2 removed when PROTECT_DOTFILES=1"; return 1; }
	
	rm -rf "$test_dir"
	return 0
}

test_resource_fork_handling() {
	# Skip this test on non-macOS systems
	if ! is_macos; then
		echo "Skipping resource fork tests on non-macOS system"
		return 0
	fi

	local test_dir
	test_dir=$(mktemp -d)
	local test_fails=0

	# Create a test file with resource fork data
	echo "Main content" > "$test_dir/test.txt"
	echo "Resource fork content" > "$test_dir/test.txt.rsrc"

	# Test has_resource_fork function
	if ! has_resource_fork "$test_dir/test.txt"; then
		test_error "has_resource_fork failed to detect resource fork"
		((test_fails++))
	fi

	# Test create on file with resource fork
	if ! create_par2s "$test_dir/test.txt" >/dev/null 2>&1; then
		test_error "create_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Verify both par2 files were created (one for data fork, one for resource fork)
	if [[ ! -f "$test_dir/.test.txt.par2" ]]; then
		test_error "Par2 file not created for data fork"
		((test_fails++))
	fi
	if [[ ! -f "$test_dir/.test.txt.rsrc.par2" ]]; then
		test_error "Par2 file not created for resource fork"
		((test_fails++))
	fi

	# Test verify on file with resource fork
	if ! verify_par2s "$test_dir/test.txt" >/dev/null 2>&1; then
		test_error "verify_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Test repair on file with resource fork
	# First corrupt both forks
	echo "Xain content" > "$test_dir/test.txt"
	echo "Xesource fork content" > "$test_dir/test.txt.rsrc"
	
	if ! repair_par2s "$test_dir/test.txt" >/dev/null 2>&1; then
		test_error "repair_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Verify both forks were repaired
	if ! grep -q "Main content" "$test_dir/test.txt"; then
		test_error "repair_par2s did not restore data fork content"
		((test_fails++))
	fi
	if ! grep -q "Resource fork content" "$test_dir/test.txt.rsrc"; then
		test_error "repair_par2s did not restore resource fork content"
		((test_fails++))
	fi

	# Test clear on file with resource fork
	if ! clear_par2s "$test_dir/test.txt" >/dev/null 2>&1; then
		test_error "clear_par2s failed on file with resource fork"
		((test_fails++))
	fi

	# Verify both par2 files were removed
	if [[ -f "$test_dir/.test.txt.par2" ]]; then
		test_error "Par2 file not removed for data fork"
		((test_fails++))
	fi
	if [[ -f "$test_dir/.test.txt.rsrc.par2" ]]; then
		test_error "Par2 file not removed for resource fork"
		((test_fails++))
	fi

	rm -rf "$test_dir"
	return "$test_fails"
}

test_all() {
	local total_fails=0
	local test_fails

	# Redirect all output to /dev/null unless DEBUG is set
	if [[ "${DEBUG:-}" != "1" ]]; then
		exec 3>&1 4>&2  # Save original stdout/stderr
		exec 1>/dev/null 2>&1
	fi

			test_suite
			test_fails=$?
			((total_fails += test_fails))

			test_dotfile_handling
			test_fails=$?
			((total_fails += test_fails))

			test_resource_fork_handling
			test_fails=$?
			((total_fails += test_fails))

	# Restore original stdout/stderr if we redirected them
	if [[ "${DEBUG:-}" != "1" ]]; then
		exec 1>&3 2>&4
	fi

	if ((total_fails == 0)); then
		echo "All tests passed"
	else
		echo "Tests failed: $total_fails"
	fi

	return "$total_fails"
}

# Main execution (if script is run directly)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	command="$1"
	directory="$2"

	ensure_target_arg_provided() {
		if [[ $# -eq 0 ]]; then
			echo -ne "Error: No action specified. Use --help to see available actions.\n\n" >&2
			show_help
			exit 1
		fi
	}
	
	ensure_target_arg_provided "$@"
	
	case "$command" in
		help|-h|--help)
			show_help
			exit 0
			;;
		test)
			test_all
			exit $?
			;;
		create|update|verify|repair|clear|stats)
			if [[ -z "$directory" ]]; then
				echo -ne "Error: No target specified. Please provide a file or directory path.\n\n" >&2
				show_help
				exit 1
			fi
			"${command}_par2s" "$directory"
			exit $?
			;;
		*)
			echo -ne "Error: Unknown action '$command'. Use --help to see available actions.\n\n" >&2
			show_help
			exit 1
			;;
	esac
fi
