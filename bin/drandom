#!/usr/bin/env luajit

local argv = arg or {}

local function stderr_write(msg)
	io.stderr:write(msg)
end

local function shell_quote(s)
	return "'" .. s:gsub("'", "'\\''") .. "'"
end

local function exec_status(cmd)
	local ok, reason, code = os.execute(cmd)
	if type(ok) == "number" then
		return ok
	end
	if ok == true then
		return 0
	end
	if reason == "exit" and type(code) == "number" then
		return code
	end
	return 1
end

local function print_about()
	print("Deterministic PCG32-based RNG with per-context persisted seeds for reproducible numbers")
end

local function print_help()
	print([[
Usage: drandom [options] [start] [end]
       DRANDOM_SEED=<seed> drandom [options] [start] [end]
       DRANDOM_CONTEXT=<name> drandom [options] [start] [end]

Deterministic random number generator using PCG32.
Outputs random integers between start and end (inclusive).

If start is not specified, it defaults to 0
If end is not specified, it defaults to 99

Set DRANDOM_SEED to start a reproducible sequence for this invocation.
After each run, the RNG state is saved to a per-context seed file, and
subsequent invocations without DRANDOM_SEED continue from that file.
Setting DRANDOM_SEED again resets the sequence for that context.

Seed formats:
  - Decimal (e.g., 12345)
  - Hex with 0x prefix (e.g., 0xDEADBEEF)
  - If a seed consists solely of hex digits and includes letters (A-F),
    but lacks the 0x prefix (e.g., DEADBEEF), a warning is printed and it
    is interpreted as hexadecimal.

Options:
  -a, --about         Show a short description
  -b, --binaryoutput  Output binary bytes (default 0-255, custom range allowed)
  -c, --count N       Output N numbers (default: 1, or 1024 with -b)
  -h, --help          Show this help message
      --test          Run the associated test suite

Persistence details:
  - State dir: ${DRANDOM_STATE_HOME:-/tmp}/drandom/${USER}
  - File name: <context>.seed (context defaults to parent shell PID, PPID)
  - Override: DRANDOM_CONTEXT and/or DRANDOM_STATE_HOME to isolate sequences

Examples:
  drandom           # Random number from 0-99
  drandom 1 6       # Roll a die (1-6)
  drandom 0 1       # Coin flip (0 or 1)
  drandom -b        # 1024 random bytes to stdout
  drandom -b -c 64  # 64 random bytes to stdout

  # Deterministic sequence:
  DRANDOM_SEED=12345
  drandom           # First number (deterministic)
  drandom           # Second number (deterministic)

  # Isolated sequence in scripts/tests:
  DRANDOM_CONTEXT=myjob DRANDOM_SEED=42 drandom; DRANDOM_CONTEXT=myjob drandom
]])
end

local first_arg = argv[1]
if first_arg == "--test" then
	local script_path = argv[0] or "drandom"
	local script_name = script_path:match("([^/]+)$") or script_path
	local test_file = (os.getenv("HOME") or "") .. "/dotfiles/bin/test/" .. script_name .. "_test"
	local f = io.open(test_file, "r")
	if f then
		f:close()
		local cmd = "FAST=1 " .. shell_quote(test_file) .. " >/dev/null"
		local status = exec_status(cmd)
		os.exit(status)
	else
		stderr_write("Test file not found: " .. test_file .. "\n")
		os.exit(1)
	end
elseif first_arg == "--about" or first_arg == "-a" then
	print_about()
	os.exit(0)
elseif first_arg == "--help" or first_arg == "-h" then
	print_help()
	os.exit(0)
end

local ffi = require("ffi")
local bit = require("bit")

ffi.cdef[[
	int getppid(void);
	int gettimeofday(struct timeval *tv, void *tz);
	typedef long time_t;
	struct timeval {
		time_t tv_sec;
		long tv_usec;
	};
]]

local u64 = ffi.typeof("uint64_t")

local function parse_uint64_dec(s)
	local value = ffi.new(u64, 0)
	for i = 1, #s do
		local c = s:byte(i)
		if c < 48 or c > 57 then
			return nil
		end
		value = value * 10 + (c - 48)
	end
	return value
end

local function parse_uint64_hex(s)
	local value = ffi.new(u64, 0)
	s = s:gsub("^0[xX]", "")
	for i = 1, #s do
		local c = s:byte(i)
		local digit
		if c >= 48 and c <= 57 then
			digit = c - 48
		elseif c >= 65 and c <= 70 then
			digit = c - 55
		elseif c >= 97 and c <= 102 then
			digit = c - 87
		else
			return nil
		end
		value = value * 16 + digit
	end
	return value
end

local function trim(s)
	return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

local function parse_seed(seed_str, env_seed_set)
	if not seed_str then
		return nil
	end
	local seed = trim(seed_str)
	if seed == "" then
		return nil
	end
	if seed:match("^0[xX][0-9A-Fa-f]+$") then
		return parse_uint64_hex(seed)
	end
	if seed:match("^[0-9A-Fa-f]+$") and seed:match("[A-Fa-f]") then
		if env_seed_set then
			stderr_write("Warning: DRANDOM_SEED '" .. seed .. "' looks like hex without 0x prefix; interpreting as hex\n")
		end
		return parse_uint64_hex(seed)
	end
	return parse_uint64_dec(seed)
end

local function u64_to_hex(value)
	if value == nil then
		return "0x0"
	end
	local digits = {}
	local tmp = ffi.new(u64, value)
	if tmp == 0 then
		return "0x0"
	end
	while tmp > 0 do
		local nibble = tonumber(tmp % 16)
		if nibble < 10 then
			digits[#digits + 1] = string.char(48 + nibble)
		else
			digits[#digits + 1] = string.char(87 + nibble)
		end
		tmp = tmp / 16
	end
	return "0x" .. table.concat(digits):reverse()
end

local function now_seed()
	local tv = ffi.new("struct timeval")
	if ffi.C.gettimeofday(tv, nil) == 0 then
		local seconds = ffi.new(u64, tv.tv_sec)
		local micros = ffi.new(u64, tv.tv_usec)
		return seconds * 1000000 + micros
	end
	return ffi.new(u64, os.time())
end

local function get_context()
	local env_ctx = os.getenv("DRANDOM_CONTEXT")
	if env_ctx and env_ctx ~= "" then
		return env_ctx
	end
	local ok, ppid = pcall(function()
		return ffi.C.getppid()
	end)
	if ok and ppid then
		return tostring(ppid)
	end
	return tostring(os.getenv("PPID") or "unknown")
end

local function get_user()
	local user = os.getenv("USER")
	if user and user ~= "" then
		return user
	end
	return "unknown"
end

local state = ffi.new(u64, 0)
local inc = ffi.new(u64, 1442695040888963407ULL)
local mult = ffi.new(u64, 6364136223846793005ULL)

local function pcg32_random()
	local old = state
	state = old * mult + inc
	local xorshifted = bit.rshift(bit.bxor(bit.rshift(old, 18), old), 27)
	local rot = tonumber(bit.rshift(old, 59))
	local x = tonumber(ffi.cast("uint32_t", xorshifted))
	local res = bit.bor(bit.rshift(x, rot), bit.lshift(x, bit.band(-rot, 31)))
	return tonumber(ffi.cast("uint32_t", res))
end

local function pcg32_seed(seed)
	state = ffi.new(u64, 0)
	inc = ffi.new(u64, 1442695040888963407ULL)
	pcg32_random()
	state = state + seed
	pcg32_random()
end

local function rand_range(start, ending)
	local range = ending - start + 1
	if range <= 1 then
		return start
	end
	local bound = 4294967296 - (4294967296 % range)
	while true do
		local r = pcg32_random()
		if r < bound then
			return start + (r % range)
		end
	end
end

local function read_seed_file(path)
	local f = io.open(path, "r")
	if not f then
		return nil
	end
	local line = f:read("*l")
	f:close()
	if not line then
		return nil
	end
	return parse_seed(line, false)
end

local function write_seed_file(path, value)
	local f = io.open(path, "w")
	if not f then
		return
	end
	f:write(u64_to_hex(value))
	f:write("\n")
	f:close()
end

-- Parse command line arguments
local function parse_args()
	local options = {
		binary_output = false,
		count = nil,
		start = nil,
		ending = nil
	}
	local positionals = {}
	local i = 1

	while i <= #argv do
		local arg_val = argv[i]
		if arg_val == "--binaryoutput" or arg_val == "-b" then
			options.binary_output = true
		elseif arg_val == "--count" or arg_val == "-c" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --count requires a number argument\n")
				os.exit(1)
			end
			options.count = tonumber(argv[i])
			if not options.count then
				stderr_write("Error: --count value must be a number\n")
				os.exit(1)
			end
		else
			-- Collect positional arguments
			table.insert(positionals, arg_val)
		end
		i = i + 1
	end

	-- Parse positional arguments as start and end
	if #positionals >= 1 then
		options.start = tonumber(positionals[1])
		if not options.start then
			stderr_write("Error: start value must be a number\n")
			os.exit(1)
		end
	end
	if #positionals >= 2 then
		options.ending = tonumber(positionals[2])
		if not options.ending then
			stderr_write("Error: end value must be a number\n")
			os.exit(1)
		end
	end

	return options, positionals
end

-- Output a single byte as binary
local function write_byte(value)
	io.stdout:write(string.char(value))
end

local options, positionals = parse_args()

-- Set defaults based on mode
local start_val, end_val, count
local show_defaults_msg = false

if options.binary_output then
	-- Binary mode: default range 0-255, but allow custom range within bounds
	start_val = options.start or 0
	end_val = options.ending or 255
	count = options.count or 1024

	-- Validate binary range is within 0-255
	if start_val < 0 then
		stderr_write("Error: start value must be >= 0 for binary output\n")
		os.exit(1)
	end
	if end_val > 255 then
		stderr_write("Error: end value must be <= 255 for binary output\n")
		os.exit(1)
	end
else
	-- Normal mode: use provided or default range
	-- Show note if using default range (before applying defaults)
	if options.start == nil and options.ending == nil then
		show_defaults_msg = true
	end

	start_val = options.start or 0
	end_val = options.ending or 99
	count = options.count or 1
end

-- Validate start <= end (applies to both modes)
if start_val > end_val then
	stderr_write("Error: start value must be less than or equal to end value\n")
	os.exit(1)
end

local state_home = os.getenv("DRANDOM_STATE_HOME") or "/tmp"
local context = get_context()
local state_dir = state_home .. "/drandom/" .. get_user()
local seed_file = state_dir .. "/" .. context .. ".seed"

local env_seed_raw = os.getenv("DRANDOM_SEED")
local env_seed_set = env_seed_raw ~= nil

if env_seed_set and env_seed_raw == "" then
	env_seed_set = false
	env_seed_raw = nil
end

local seed
if env_seed_set then
	seed = parse_seed(env_seed_raw, true)
	if not seed then
		seed = ffi.new(u64, 0)
	end
	pcg32_seed(seed)
else
	local persisted = read_seed_file(seed_file)
	if persisted then
		state = persisted
	else
		seed = now_seed()
		pcg32_seed(seed)
	end
end

if show_defaults_msg then
	stderr_write("(with a start of 0 and an end of 99)\n")
end

-- Generate output
if options.binary_output then
	-- Binary output mode
	for _ = 1, count do
		write_byte(rand_range(start_val, end_val))
	end
else
	-- Text output mode
	for _ = 1, count do
		print(rand_range(start_val, end_val))
	end
end

os.execute("mkdir -p " .. shell_quote(state_dir) .. " 2>/dev/null")
write_seed_file(seed_file, state)
