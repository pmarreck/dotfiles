#!/usr/bin/env bash

# dirtree_test: Test the dirtree utility (eza wrapper)

test_count=0
failed_count=0

test_function() {
	local description="$1"
	local command="$2"
	local expected_pattern="$3"
	
	((test_count++))
	echo "Testing $description..."
	
	local output
	output=$(eval "$command" 2>&1)
	local exit_code=$?
	
	if [[ $exit_code -ne 0 ]]; then
		echo "✗ Test failed: $description (exit code $exit_code)" >&2
		echo "  Command: $command" >&2
		echo "  Output: $output" >&2
		((failed_count++))
		return 1
	fi
	
	if [[ -n "$expected_pattern" ]] && ! echo "$output" | grep -q "$expected_pattern"; then
		echo "✗ Test failed: $description (pattern not found)" >&2
		echo "  Command: $command" >&2
		echo "  Expected pattern: $expected_pattern" >&2
		echo "  Actual output: $output" >&2
		((failed_count++))
		return 1
	fi
	
	echo "✓ Test passed"
	return 0
}

# Create a temporary test directory structure
tmpdir=$(mktemp -d)
mkdir -p "$tmpdir/testdir"
touch "$tmpdir/testdir/file1.txt"
touch "$tmpdir/testdir/.hidden"
mkdir -p "$tmpdir/testdir/subdir"
touch "$tmpdir/testdir/subdir/file2.txt"

# Basic listing: no root line in output by default (non-TTY)
test_function "basic listing omits root line by default" \
	"dirtree '$tmpdir/testdir' | grep -q 'testdir' && echo BAD || echo OK" \
	"OK"

# Test dotfiles visibility (eza shows hidden files with --all)
test_function "dotfiles visibility" \
	"dirtree '$tmpdir/testdir'" \
	"\.hidden"

# Test depth limiting (default depth is 2)
test_function "depth limiting" \
	"dirtree -d 1 '$tmpdir/testdir'" \
	"subdir"

# Test that subdirectory contents are not shown with depth 1
test_function "depth limiting effectiveness" \
	"dirtree -d 1 '$tmpdir/testdir' | grep -v file2.txt && echo 'PASS'" \
	"PASS"

# Test help option
test_function "help option" \
	"dirtree --help" \
	"Usage:"

# Test current directory default produces entries (no root)
test_function "current directory listing shows entries" \
	"cd '$tmpdir/testdir' && dirtree | grep -q 'file1.txt' && echo OK" \
	"OK"

# Ensure directory name does not appear (no self-nesting/root line)
test_function "no directory self-nesting or root line" \
	"dirtree '$tmpdir/testdir' | grep -c 'testdir' | grep -q '^0$' && echo PASS" \
	"PASS"

# Test that files are visible at depth 2
test_function "files visible at depth 2" \
	"dirtree -d 2 '$tmpdir/testdir' | grep -c 'file1.txt' | grep -E '^1$' && echo 'PASS'" \
	"PASS"

# Test that both files and directories are listed
test_function "files and directories both listed" \
	"dirtree -d 2 '$tmpdir/testdir' | grep -E '(file1.txt|subdir)' | wc -l | grep -E '^[2-9]$' && echo 'PASS'" \
	"PASS"


# Hyperlinks behavior when stdout is not a TTY
test_function "no hyperlinks by default when not TTY" \
	"dirtree '$tmpdir/testdir' | grep -q ']8;;' && echo BAD || echo OK" \
	"OK"

test_function "hyperlinks present when forced with --decorated" \
	"dirtree --decorated '$tmpdir/testdir' | grep -q ']8;;' && echo OK" \
	"OK"

# Test that eza is available
test_function "eza availability" \
	"command -v eza >/dev/null && echo 'EZA_FOUND'" \
	"EZA_FOUND"

# Skip error handling test - eza availability checking is tested elsewhere

# Test depth parameter validation
test_function "depth parameter validation" \
	"dirtree -d abc 2>&1 | grep 'numeric argument' && echo 'VALIDATED'" \
	"VALIDATED"

# Test directory validation
test_function "directory validation" \
	"dirtree /nonexistent/path 2>&1 | grep 'not a directory' && echo 'VALIDATED'" \
	"VALIDATED"

# Persisting default state via --default only (no --simple)
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir"
rm -f "$basedir/.dirtree-state"
basedir_q=$(printf '%q' "$basedir")
state_q=$(printf '%q' "$basedir/.dirtree-state")

test_function "persist default via --default only" \
	"(cd $basedir_q && dirtree --default closed >/dev/null && head -n1 $state_q | grep -q '^ver=1\\.1$' && grep -q '^default=closed$' $state_q && echo OK)" \
	"OK"

# Clean up first tmpdir
rm -rf "$tmpdir"

# Persisting default visibility via --default hide/show
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir"
rm -f "$basedir/.dirtree-state"
basedir_q=$(printf '%q' "$basedir")
state_q=$(printf '%q' "$basedir/.dirtree-state")

test_function "persist default visibility via --default hide" \
	"(cd $basedir_q && dirtree --default hide >/dev/null && head -n1 $state_q | grep -q '^ver=1\\.1$' && grep -q '^default=hidden$' $state_q && echo OK)" \
	"OK"

rm -rf "$tmpdir"

# Persisting default array via multiple tokens
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir"
rm -f "$basedir/.dirtree-state"
basedir_q=$(printf '%q' "$basedir")

test_function "persist default array via multiple --default tokens" \
	"(cd $basedir_q && dirtree --default opened hidden >/dev/null && awk '/^default=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\topened' && awk '/^default=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\thidden' && echo OK)" \
	"OK"

rm -rf "$tmpdir"

# Decorated mode should honor persisted default=closed
tmpdir=$(mktemp -d)
basedir="$tmpdir/closed"
mkdir -p "$basedir/parent/child/grandchild"

test_function "decorated mode honors default=closed" \
	"(\
		cd \"$basedir\" && \
		cat <<'STATE' > .dirtree-state
ver=1.1
default=closed
STATE
		tmp=\$(mktemp) && \
		trap 'rm -f \"\$tmp\"' EXIT && \
		dirtree > \"\$tmp\" && \
		if grep -Fq 'parent/*' \"\$tmp\" && ! grep -q 'child' \"\$tmp\"; then \
			echo OK; \
		else \
			echo BAD; \
		fi \
	)" \
	"OK"

rm -rf "$tmpdir"

# Decorated mode expands explicitly opened directories even when default=closed
tmpdir=$(mktemp -d)
basedir="$tmpdir/closed"
mkdir -p "$basedir/parent/child/grandchild"

test_function "decorated mode honors explicit open over default" \
	"(\
		cd \"$basedir\" && \
		cat <<'STATE' > .dirtree-state
ver=1.1
default=closed
open=[
parent
]
STATE
		tmp=\$(mktemp) && \
		trap 'rm -f \"\$tmp\"' EXIT && \
		dirtree > \"\$tmp\" && \
		if grep -Fq 'parent/*' \"\$tmp\"; then \
			echo BAD; \
		elif grep -Fq 'child/' \"\$tmp\"; then \
			echo OK; \
		else \
			echo BAD; \
		fi \
	)" \
	"OK"

rm -rf "$tmpdir"

# --open should handle names with spaces/parentheses without hanging
tmpdir=$(mktemp -d)
basedir="$tmpdir/spaces"
mkdir -p "$basedir/sys (server)/child"

test_function "--open handles directories with spaces" \
	"(\
		cd \"$basedir\" && \
		tmp=\$(mktemp) && \
		timeout 5 dirtree --open 'sys (server)' > \"\$tmp\" && \
		grep -Fq 'sys (server)' \"\$tmp\" && \
		grep -Fq 'child/' \"\$tmp\" && \
		echo OK && \
		rm -f \"\$tmp\" \
	)" \
	"OK"

rm -rf "$tmpdir"

# Decorated mode should handle percent-encoded OSC8 hyperlinks
tmpdir=$(mktemp -d)
basedir="$tmpdir/spaces"
mkdir -p "$basedir/sys (server)/child"
cat <<'STATE' > "$basedir/.dirtree-state"
ver=1.1
default=closed
STATE

stubdir=$(mktemp -d)
cat >"$stubdir/eza" <<'EOS'
#!/usr/bin/env bash
path="${@: -1}"
abs=$(cd "$path" && pwd -P)
case "$abs" in
*/sys\ \(server\))
	base="${abs%/sys (server)}"
	printf '\e]8;;file://%s/sys%%20(server)/child\e\\child\e]8;;\e\\\n' "$base"
	;;
*)
	printf '\e]8;;file://%s/.dirtree-state\e\\.dirtree-state\e]8;;\e\\\n' "$abs"
	printf '\e]8;;file://%s/sys%%20(server)\e\\sys (server)\e]8;;\e\\\n' "$abs"
	;;
esac
EOS
chmod +x "$stubdir/eza"

test_function "decorated handles percent-encoded OSC8 hyperlinks" \
	"(\
		cd \"$basedir\" && \
		tmp=\$(mktemp) && \
		trap 'rm -f \"\$tmp\"' EXIT && \
		PATH='$stubdir':\"\$PATH\" timeout 5 dirtree > \"\$tmp\" && \
		grep -Fq 'sys (server)/*' \"\$tmp\" && \
		! grep -Fq 'child/' \"\$tmp\" && \
		! grep -Fq '//\*' \"\$tmp\" && \
		echo OK \
	)" \
	"OK"

rm -rf "$stubdir"
rm -rf "$tmpdir"

# --- INI-MA format tests ---

tmpdir_inima=$(mktemp -d)
basedir="$tmpdir_inima/inima"
mkdir -p "$basedir/src" "$basedir/docs" "$basedir/tmp" "$basedir/logs"

test_function "state persists using INI-MA arrays" \
	"(\
		cd \"$basedir\" && \
		rm -f .dirtree-state && \
		dirtree --default opened >/dev/null && \
		dirtree --open src >/dev/null && \
		dirtree --open '/^docs/' >/dev/null && \
		dirtree --close tmp >/dev/null && \
		dirtree --close '/^tmp/' >/dev/null && \
		dirtree --show docs >/dev/null && \
		dirtree --show '/^src/' >/dev/null && \
		dirtree --hide logs >/dev/null && \
		dirtree --hide '/\\.lnk$/' >/dev/null && \
		head -n1 .dirtree-state | grep -q '^ver=1\\.1$' && \
		! grep -q '_regex=' .dirtree-state && \
		awk '/^open=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tsrc' && \
		awk '/^open=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/^docs/' && \
		awk '/^close=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\ttmp' && \
		awk '/^close=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/^tmp/' && \
		awk '/^show=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tdocs' && \
		awk '/^show=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/^src/' && \
		awk '/^hide=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tlogs' && \
		awk '/^hide=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/\\.lnk$/' && \
		echo OK \
	)" \
	"OK"

test_function "legacy state migrates to INI-MA" \
	"(\
		cd \"$basedir\" && \
		rm -f .dirtree-state && \
		cat <<'LEGACY' > .dirtree-state
default=closed
open=src;docs
open_regex=^lib
close=tmp
close_regex=^build
show=docs
show_regex=^bin
hide=logs
hide_regex=^node
LEGACY
		tmpf=\$(mktemp) && \
		dirtree --simple > \"\$tmpf\" && \
		rm -f \"\$tmpf\" && \
		head -n1 .dirtree-state | grep -q '^ver=1\\.1$' && \
		! grep -q '_regex=' .dirtree-state && \
		awk '/^open=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tsrc' && \
		awk '/^open=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tdocs' && \
		awk '/^open=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/^lib/' && \
		awk '/^close=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\ttmp' && \
		awk '/^close=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/^build/' && \
		awk '/^show=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tdocs' && \
		awk '/^show=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/^bin/' && \
		awk '/^hide=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tlogs' && \
		awk '/^hide=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\t/^node/' && \
		echo OK \
	)" \
	"OK"

rm -rf "$tmpdir_inima"

# --- Additional tests for --simple (LLM) mode with state ---

# Recreate temp dir for stateful tests
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/src/lib" "$basedir/node_modules/pkg" "$basedir/docs"
touch "$basedir/README.md" "$basedir/src/main.sh" "$basedir/src/lib/util.sh" "$basedir/node_modules/pkg/index.js" "$basedir/docs/guide.md"

# Ensure no preexisting state
rm -f "$basedir/.dirtree-state"

# 1) simple mode default opened, then close src
basedir_q=$(printf '%q' "$basedir")
test_function "--simple default opened then close src" \
	"dirtree --simple --default opened -c src $basedir_q && dirtree --simple $basedir_q | sed -n '1,120p'" \
	"src/*"

# 2) simple mode reopen src, should show src/lib and files
test_function "--simple reopen src shows contents" \
	"dirtree --simple -o src $basedir_q && dirtree --simple -d 3 $basedir_q | grep -E 'src/lib|main.sh' && echo PASS" \
	"PASS"

# 3) default closed: only top-level items shown collapsed; then open docs
test_function "--simple set default closed and open docs" \
	"dirtree --simple --default closed -o docs $basedir_q && dirtree --simple -d 3 $basedir_q | grep -E 'docs/|docs/guide.md' && echo PASS" \
	"PASS"

# 4) state file persisted and preserves unknown keys
cat <<'STATE' > "$basedir/.dirtree-state"
ver=1.1
custom=keepme
STATE
state_q=$(printf '%q' "$basedir/.dirtree-state")
test_function "--simple preserves unknown keys in state" \
	"dirtree --simple -o src $basedir_q && grep -q '^custom=keepme$' $state_q && head -n1 $state_q | grep -q '^ver=1\\.1$' && echo OK" \
	"OK"

# 5) closed marker shows '/' for empty dir, '/*' for non-empty
mkdir -p "$basedir/emptydir"
test_function "--simple closed marker variants" \
	"dirtree --simple --default opened -c emptydir -c src $basedir_q && dirtree --simple $basedir_q | awk '/emptydir\/$|emptydir\/\*|src\/\*/{print}' | wc -l | grep -E '^[2-9]$' && echo PASS" \
	"PASS"

# Cleanup temp dir for stateful tests
rm -rf "$tmpdir"

# --- Auto simple mode tests (via env var + non-TTY) ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/src" "$basedir/docs"
touch "$basedir/src/a" "$basedir/docs/b"
basedir_q=$(printf '%q' "$basedir")

# Seed state: default opened, close src
dirtree --simple --default opened -c src "$basedir" >/dev/null

test_function "auto simple via DIRTREE_AUTO_SIMPLE when not TTY" \
	"DIRTREE_AUTO_SIMPLE=1 dirtree $basedir_q | grep -q 'src/\*' && echo OK" \
	"OK"

rm -rf "$tmpdir"

# --- Simple mode: no leading connectors ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/a/b"
touch "$basedir/a/b/file"
basedir_q=$(printf '%q' "$basedir")

test_function "simple: no leading '├──', '└──', or '│   '" \
	"out=\"\$(dirtree --simple $basedir_q)\"; ! echo \"$out\" | grep -q '^├──' && ! echo \"$out\" | grep -q '^└──' && ! echo \"$out\" | grep -q '^│   ' && echo OK" \
	"OK"

rm -rf "$tmpdir"

# --- Decorated mode respects closed subtrees ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/.git/inner"
touch "$basedir/.git/inner/file"
basedir_q=$(printf '%q' "$basedir")

test_function "decorated mode collapses explicitly closed .git" \
	"dirtree -c .git $basedir_q | grep -q '/.git/\*' || echo PASS" \
	"PASS"

rm -rf "$tmpdir"

# --- Decorated mode keeps colors and doesn't star plain files ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/sub"
touch "$basedir/plain" "$basedir/sub/file"
basedir_q=$(printf '%q' "$basedir")

test_function "no ANSI colors when piped by default" \
	"dirtree $basedir_q | grep -q $'\033\[' && echo BAD || echo OK" \
	"OK"

test_function "ANSI colors retained when piped with --decorated" \
	"dirtree --decorated $basedir_q | grep -q $'\033\[' && echo OK" \
	"OK"

test_function "decorated output does not star non-executable plain files" \
	"dirtree $basedir_q | grep -q 'plain\*' && echo BAD || echo OK" \
	"OK"

rm -rf "$tmpdir"

# --- Decorated mode adds trailing slashes to dirs, not files ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/dirA" "$basedir/.git" "$basedir/dirB"
touch "$basedir/fileA" "$basedir/.gitignore"
basedir_q=$(printf '%q' "$basedir")

test_function "decorated: dirs end with '/', files do not" \
	"out=\"\$(dirtree $basedir_q)\"; echo \"$out\" | awk '/dirA/{exit !(/\/$/)}'; echo \"$out\" | awk '/dirB/{exit !(/\/$/)}'; echo \"$out\" | awk '/fileA/{exit (/\/$/)}'; echo OK" \
	"OK"

test_function "decorated: closing .git does not tag .gitignore" \
	"dirtree -c .git $basedir_q | grep -q '.gitignore/\\*' && echo BAD || echo OK" \
	"OK"

rm -rf "$tmpdir"

# --- Decorated indentation reflects hierarchy ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/parent/child"

test_function "decorated indentation reflects hierarchy" \
	"(\
		tmpf=\$(mktemp) && \
		dirtree \"$basedir\" > \"\$tmpf\" && \
		tmpclean=\$(mktemp) && \
		strip_ansi < \"\$tmpf\" > \"\$tmpclean\" && \
		grep -Eq '^└── parent/' \"\$tmpclean\" && \
		grep -Eq '^    └── child/' \"\$tmpclean\" && \
		echo OK && \
		rm -f \"\$tmpf\" \"\$tmpclean\" \
	)" \
	"OK"

rm -rf "$tmpdir"

# --- Sorting behaviour ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/order"
mkdir -p "$basedir"
touch -t 202001010000 "$basedir/a"
touch -t 202001020000 "$basedir/b"

test_function "default sort is modified desc" \
	"dirtree '$basedir' | sed -n '1p'" \
	"├── b$"

test_function "--sort alpha --asc orders ascending" \
	"dirtree --sort alpha --asc '$basedir' | sed -n '1p'" \
	"├── a$"

test_function "--sort alpha --desc orders descending" \
	"dirtree --sort alpha --desc '$basedir' | sed -n '1p'" \
	"├── b$"

rm -rf "$tmpdir"

# --- default closed + open parent keeps grandchildren collapsed ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/parent/child/grand"

test_function "open parent does not expand grandchildren by default" \
	"(\
		cd '$basedir' && \
		dirtree --default closed >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree --open parent > \"\$tmpf\" && \
		tmpclean=\$(mktemp) && \
		strip_ansi < \"\$tmpf\" > \"\$tmpclean\" && \
		grep -Fq '└── parent/' \"\$tmpclean\" && \
		grep -Fq '└── child/*' \"\$tmpclean\" && \
		! grep -F 'grand/' \"\$tmpclean\" && \
		echo OK && \
		rm -f \"\$tmpf\" \"\$tmpclean\" \
	)" \
	"OK"

rm -rf "$tmpdir"

# --- Regex open/close behavior and hide support ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/src/lib" "$basedir/tests"
touch "$basedir/src/shortcut.lnk"
touch "$basedir/src/config.json"
touch "$basedir/src/configXjson"

test_function "--open regex persists in state" \
	"(\
		cd '$basedir' && \
		dirtree --default closed >/dev/null && \
		dirtree --open '/^src/' >/dev/null && \
		awk '/^open=\[/{flag=1;next}/^]/{flag=0} flag && /\/\^src\//{found=1} END{exit found?0:1}' .dirtree-state && \
		echo OK \
	)" \
	"OK"

test_function "--open slash regex persists in state" \
	"(\
		cd '$basedir' && \
		dirtree --default closed >/dev/null && \
		dirtree --open '/^src/' >/dev/null && \
		awk '/^open=\[/{flag=1;next}/^]/{flag=0} flag && /\/\^src\//{found=1} END{exit found?0:1}' .dirtree-state && \
		echo OK \
	)" \
	"OK"

test_function "literal close beats regex open" \
	"(\
		cd '$basedir' && \
		dirtree --default closed >/dev/null && \
		dirtree --open '/^src/' >/dev/null && \
		dirtree --close src >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree > \"\$tmpf\" && \
		strip_ansi < \"\$tmpf\" | grep -Fq 'src/*' && \
		echo OK && \
		rm -f \"\$tmpf\" \
	)" \
	"OK"

test_function "--close slash regex persists in state" \
	"(\
		cd '$basedir' && \
		dirtree --default closed >/dev/null && \
		dirtree --close '/^src/' >/dev/null && \
		awk '/^close=\[/{flag=1;next}/^]/{flag=0} flag && /\/\^src\//{found=1} END{exit found?0:1}' .dirtree-state && \
		echo OK \
	)" \
	"OK"

# ensure fresh state before conflict scenario
rm -f "$basedir/.dirtree-state"

test_function "regex/open close conflict raises error" \
	"(\
		cd '$basedir' && \
		cat <<'STATE' > .dirtree-state
ver=1.1
default=closed
open=[
/^src/
]
close=[
/^src/
]
STATE
		dirtree > /tmp/out 2> /tmp/err; rc=\$?; rm -f /tmp/out; test \$rc -ne 0 && grep -q 'matches both open and close patterns' /tmp/err && echo OK && rm -f /tmp/err \
	)" \
	"OK"

rm -f "$basedir/.dirtree-state"

test_function "--hide literal suppresses node" \
	"(\
		cd '$basedir' && \
		dirtree --hide tests >/dev/null && \
		dirtree | strip_ansi | grep -q 'tests' && echo BAD || echo OK \
	)" \
	"OK"

test_function "--hide regex suppresses matches" \
	"(\
		cd '$basedir' && \
		dirtree --hide '/^src/' >/dev/null && \
		dirtree | strip_ansi | grep -q 'src' && echo BAD || echo OK \
	)" \
	"OK"

rm -f "$basedir/.dirtree-state"

test_function "--hide slash regex persists and hides" \
	"(\
		cd '$basedir' && \
	dirtree --hide '/\\.lnk$/' >/dev/null && \
	grep -Fq '/\\.lnk$/' .dirtree-state && \
	tmpf=\$(mktemp) && \
	dirtree > \"\$tmpf\" && \
	strip_ansi < \"\$tmpf\" | grep -q 'shortcut.lnk' && echo BAD || echo OK && \
	rm -f \"\$tmpf\" \
	)" \
	"OK"

basedir_saved="$basedir"

# re:-prefixed arguments should be treated as literals
tmpdir_re_literal=$(mktemp -d)
basedir_re_literal="$tmpdir_re_literal/re_literal"
mkdir -p "$basedir_re_literal/src/deep" "$basedir_re_literal/re:^src/inner"

cat <<'STATE' > "$basedir_re_literal/.dirtree-state"
ver=1.1
default=closed
STATE

test_function "re-prefix --open treats argument as literal" \
	"(\
		cd '$basedir_re_literal' && \
		dirtree --open 're:^src' >/dev/null && \
		awk '/^open=\[/{flag=1;next}/^]/{flag=0} flag {print}' .dirtree-state | grep -Fxq $'\tre:^src' && \
		tmpf=\$(mktemp) && \
		dirtree > \"\$tmpf\" && \
		tmpclean=\$(mktemp) && \
		strip_ansi < \"\$tmpf\" > \"\$tmpclean\" && \
		grep -Fq 're:^src/' \"\$tmpclean\" && \
		grep -Fq 'inner/' \"\$tmpclean\" && \
		grep -Fq 'src/*' \"\$tmpclean\" && echo OK || echo BAD && \
		rm -f \"\$tmpf\" \"\$tmpclean\" \
	)" \
	"OK"

cat <<'STATE' > "$basedir_re_literal/.dirtree-state"
ver=1.1
default=opened
STATE

test_function "re-prefix --hide treats argument as literal" 	"(		cd '$basedir_re_literal' && 		dirtree --hide 're:^src' >/dev/null && 		awk '/^hide=\[/{flag=1;next}/^]/{flag=0} flag {print}' .dirtree-state | grep -Fxq $'	re:^src' && 		tmpf=\$(mktemp) && 		dirtree > "\$tmpf" 2> "\$tmpf.err" && 		strip_ansi < "\$tmpf" | grep -Fq 're:^src/' && echo BAD || (strip_ansi < "\$tmpf" | grep -Fq 'src/' && echo OK) && 		rm -f "\$tmpf" "\$tmpf.err" 	)" 	"OK"

rm -rf "$tmpdir_re_literal"

tmpdir_inline=$(mktemp -d)
basedir_inline="$tmpdir_inline/inline_arrays"
mkdir -p "$basedir_inline/src/deep" "$basedir_inline/docs/with space" "$basedir_inline/tmp/cache" "$basedir_inline/logs"
touch "$basedir_inline/src/deep/file.txt" "$basedir_inline/docs/with space/readme.md" "$basedir_inline/tmp/cache/tmpfile" "$basedir_inline/logs/app.log"

cat <<'STATE' > "$basedir_inline/.dirtree-state"
ver=1.1
default=[ open shown ]
open=[ src docs/with\ space ]
close=[ tmp ]
show=[ src/deep ]
hide=[ logs /\.log$/ ]
STATE

test_function "inline INI-MA arrays parse correctly" 	"(		cd '$basedir_inline' && 		tmpf=\$(mktemp) && 		tmpf_err=\$(mktemp) && 		dirtree --decorated > "\$tmpf" 2> "\$tmpf_err" && 		strip_ansi < "\$tmpf" | grep -Fq 'docs/with space/' && 		strip_ansi < "\$tmpf" | grep -Fq 'src/deep/' && 		! strip_ansi < "\$tmpf" | grep -Fq 'logs/' && 		awk '/^open=\[/{flag=1;next}/^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'	docs/with space' && 		awk '/^hide=\[/{flag=1;next}/^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'	/\.log$/' && 		echo OK && 		rm -f "\$tmpf" "\$tmpf_err" 	)" 	"OK"

rm -rf "$tmpdir_inline"

basedir="$basedir_saved"

test_function "--hide literal with dot stays literal" \
	"(\
		cd '$basedir' && \
		dirtree --hide src/config.json >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree > \"\$tmpf\" && \
		strip_ansi < \"\$tmpf\" | grep -Fq 'config.json' && echo BAD || ( \
			awk '/^hide=\[/{flag=1;next} flag && /^]/{flag=0;next} flag {print}' .dirtree-state | grep -Fxq $'\tsrc/config.json' && \
			strip_ansi < \"\$tmpf\" | grep -Fq 'configXjson' && echo OK \
		) && \
		rm -f \"\$tmpf\" \
	)" \
	"OK"

test_function "--show-hidden reveals hidden entries without persisting" \
	"(\
		cd '$basedir' && \
		dirtree --hide tests >/dev/null && \
		dirtree --hide '/^src/' >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree --show-hidden > \"\$tmpf\" && \
		strip_ansi < \"\$tmpf\" | grep -Fq 'tests/' && \
		strip_ansi < \"\$tmpf\" | grep -Fq 'src/' && \
		rm -f \"\$tmpf\" && \
		grep -q '^hide=' .dirtree-state && \
		echo OK \
	)" \
	"OK"

test_function "decorated output reports hidden counts" \
	"(\
		cd '$basedir' && \
		dirtree --hide tests >/dev/null && \
		dirtree --hide '/^src/' >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree > \"\$tmpf\" 2>\"\$tmpf.err\" && \
		if grep -E '\\btests/' \"\$tmpf\"; then \
			echo BAD; \
		else \
			grep -Fq $'\033[2;3m2 directories are hidden.\033[0m' \"\$tmpf.err\" && echo OK; \
		fi && \
		rm -f \"\$tmpf\" \"\$tmpf.err\" \
	)" \
	"OK"

test_function "--show-hidden suppresses hidden count" \
	"(\
		cd '$basedir' && \
		dirtree --hide tests >/dev/null && \
		dirtree --hide '/^src/' >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree --show-hidden > \"\$tmpf\" 2>\"\$tmpf.err\" && \
		sed -n 's/^.*hidden\.$//p' \"\$tmpf.err\" | grep -q '.' && echo BAD || echo OK && \
		rm -f \"\$tmpf\" \"\$tmpf.err\" \
	)" \
	"OK"

rm -f "$basedir/.dirtree-state"

test_function "--show literal overrides hide regex" \
	"(\
		cd '$basedir' && \
		dirtree --hide tests >/dev/null && \
		dirtree --hide '/^src/' >/dev/null && \
		dirtree --show src >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree > \"\$tmpf\" && \
		tmpclean=\$(mktemp) && \
		strip_ansi < \"\$tmpf\" > \"\$tmpclean\" && \
		grep -Fq 'src/' \"\$tmpclean\" && \
		grep -Fq 'tests' \"\$tmpclean\" && echo BAD || echo OK && \
		rm -f \"\$tmpf\" \"\$tmpclean\" \
	)" \
	"OK"

rm -f "$basedir/.dirtree-state"

test_function "hide literal beats show regex" \
	"(\
		cd '$basedir' && \
		dirtree --hide tests >/dev/null && \
		dirtree --show '/tests/' >/dev/null && \
		dirtree | strip_ansi | grep -q 'tests' && echo BAD || echo OK \
	)" \
	"OK"

rm -f "$basedir/.dirtree-state"

test_function "--show slash regex persists" \
	"(\
		cd '$basedir' && \
		dirtree --show '/shortcut/' >/dev/null && \
		grep -Fq '/shortcut/' .dirtree-state && \
		tmpf=\$(mktemp) && \
		dirtree > \"\$tmpf\" && \
		strip_ansi < \"\$tmpf\" | grep -Fq 'shortcut.lnk' && echo OK && \
		rm -f \"\$tmpf\" \
	)" \
	"OK"

rm -f "$basedir/.dirtree-state"

test_function "--show rejects absolute paths" \
	"(\
		cd '$basedir' && \
		err=\$(mktemp) && \
		dirtree --show /absolute 1>/tmp/out 2>\"\$err\"; \
		rc=\$?; \
		rm -f /tmp/out; \
		test \$rc -ne 0 && grep -q 'relative' \"\$err\" && echo OK && rm -f \"\$err\" \
	)" \
	"OK"

rm -f "$basedir/.dirtree-state"

test_function "open but hidden directory stays collapsed" \
	"(\
		cd '$basedir' && \
		dirtree --default opened >/dev/null && \
		dirtree --open src >/dev/null && \
		dirtree --hide src >/dev/null && \
		tmpf=\$(mktemp) && \
		dirtree > \"\$tmpf\" && \
		strip_ansi < \"\$tmpf\" | grep -Fq 'src/' && echo BAD || echo OK && \
		rm -f \"\$tmpf\" \
	)" \
	"OK"

test_function "--hide rejects absolute paths" \
	"(\
		cd '$basedir' && \
		err=\$(mktemp) && \
		dirtree --hide /absolute 1>/tmp/out 2>\"\$err\"; \
		rc=\$?; \
		rm -f /tmp/out; \
		test \$rc -ne 0 && grep -q 'relative' \"\$err\" && echo OK && rm -f \"\$err\" \
	)" \
	"OK"

rm -rf "$tmpdir"

# --- Decorated mode flush-left: no tree connector glyphs ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/a/b"
touch "$basedir/a/b/file"
basedir_q=$(printf '%q' "$basedir")

test_function "decorated tree shows connectors" \
	"(\
		tmpf=\$(mktemp) && \
		dirtree $basedir_q > \"\$tmpf\" && \
		grep -q '^└──' \"\$tmpf\" && \
		echo OK && \
		rm -f \"\$tmpf\" \
	)" \
	"OK"

rm -rf "$tmpdir"

# Final report
echo
if [[ $failed_count -eq 0 ]]; then
	echo "All $test_count tests passed"
else
	echo "$failed_count of $test_count tests failed" >&2
fi

exit $failed_count
