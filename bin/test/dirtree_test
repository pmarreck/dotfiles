#!/usr/bin/env bash

# dirtree_test: Test the dirtree utility (eza wrapper)

test_count=0
failed_count=0

test_function() {
    local description="$1"
    local command="$2"
    local expected_pattern="$3"
    
    ((test_count++))
    echo "Testing $description..."
    
    local output
    output=$(eval "$command" 2>&1)
    local exit_code=$?
    
    if [[ $exit_code -ne 0 ]]; then
        echo "✗ Test failed: $description (exit code $exit_code)" >&2
        echo "  Command: $command" >&2
        echo "  Output: $output" >&2
        ((failed_count++))
        return 1
    fi
    
    if [[ -n "$expected_pattern" ]] && ! echo "$output" | grep -q "$expected_pattern"; then
        echo "✗ Test failed: $description (pattern not found)" >&2
        echo "  Command: $command" >&2
        echo "  Expected pattern: $expected_pattern" >&2
        echo "  Actual output: $output" >&2
        ((failed_count++))
        return 1
    fi
    
    echo "✓ Test passed"
    return 0
}

# Create a temporary test directory structure
tmpdir=$(mktemp -d)
mkdir -p "$tmpdir/testdir"
touch "$tmpdir/testdir/file1.txt"
touch "$tmpdir/testdir/.hidden"
mkdir -p "$tmpdir/testdir/subdir"
touch "$tmpdir/testdir/subdir/file2.txt"

# Test basic directory tree (eza shows directory name)
test_function "basic directory tree" \
    "dirtree '$tmpdir/testdir'" \
    "testdir"

# Test dotfiles visibility (eza shows hidden files with --all)
test_function "dotfiles visibility" \
    "dirtree '$tmpdir/testdir'" \
    "\.hidden"

# Test depth limiting (default depth is 2)
test_function "depth limiting" \
    "dirtree -d 1 '$tmpdir/testdir'" \
    "subdir"

# Test that subdirectory contents are not shown with depth 1
test_function "depth limiting effectiveness" \
    "dirtree -d 1 '$tmpdir/testdir' | grep -v file2.txt && echo 'PASS'" \
    "PASS"

# Test help option
test_function "help option" \
    "dirtree --help" \
    "Usage:"

# Test current directory default
test_function "current directory default" \
    "cd '$tmpdir/testdir' && dirtree" \
    "testdir"

# Test for directory self-nesting bug (should not occur with eza)
test_function "no directory self-nesting" \
    "dirtree '$tmpdir/testdir' | grep -c 'testdir' | grep -E '^[1-9][0-9]*$' && echo 'PASS'" \
    "PASS"

# Test that files are visible at depth 2
test_function "files visible at depth 2" \
    "dirtree -d 2 '$tmpdir/testdir' | grep -c 'file1.txt' | grep -E '^1$' && echo 'PASS'" \
    "PASS"

# Test that both files and directories are listed
test_function "files and directories both listed" \
    "dirtree -d 2 '$tmpdir/testdir' | grep -E '(file1.txt|subdir)' | wc -l | grep -E '^[2-9]$' && echo 'PASS'" \
    "PASS"

testdir" \
s*"├──\\|└──"
'$tmpdir/testdir'" \
    "├──\|└──"

# Test hyperlinks are present (eza hyperlink format)
test_function "hyperlinks present" \
    "dirtree '$tmpdir/testdir'" \
    "]8;;"

# Test that eza is available
test_function "eza availability" \
    "command -v eza >/dev/null && echo 'EZA_FOUND'" \
    "EZA_FOUND"

# Skip error handling test - eza availability checking is tested elsewhere

# Test depth parameter validation
test_function "depth parameter validation" \
    "dirtree -d abc 2>&1 | grep 'numeric argument' && echo 'VALIDATED'" \
    "VALIDATED"

# Test directory validation
test_function "directory validation" \
    "dirtree /nonexistent/path 2>&1 | grep 'not a directory' && echo 'VALIDATED'" \
    "VALIDATED"

# Clean up first tmpdir
rm -rf "$tmpdir"

# --- Additional tests for --simple (LLM) mode with state ---

# Recreate temp dir for stateful tests
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/src/lib" "$basedir/node_modules/pkg" "$basedir/docs"
touch "$basedir/README.md" "$basedir/src/main.sh" "$basedir/src/lib/util.sh" "$basedir/node_modules/pkg/index.js" "$basedir/docs/guide.md"

# Ensure no preexisting state
rm -f "$basedir/.dirtree-state"

# 1) simple mode default opened, then close src
test_function "--simple default opened then close src" \
    "dirtree --simple --default opened -c src '$basedir' && dirtree --simple '$basedir' | sed -n '1,120p'" \
    "src/*"

# 2) simple mode reopen src, should show src/lib and files
test_function "--simple reopen src shows contents" \
    "dirtree --simple -o src '$basedir' && dirtree --simple -d 3 '$basedir' | grep -E 'src/lib|main.sh' && echo PASS" \
    "PASS"

# 3) default closed: only top-level items shown collapsed; then open docs
test_function "--simple set default closed and open docs" \
    "dirtree --simple --default closed -o docs '$basedir' && dirtree --simple -d 3 '$basedir' | grep -E 'docs/|docs/guide.md' && echo PASS" \
    "PASS"

# 4) state file persisted and preserves unknown keys
echo 'custom=keepme' > "$basedir/.dirtree-state"
test_function "--simple preserves unknown keys in state" \
    "dirtree --simple -o src '$basedir' && grep -q '^custom=keepme$' '$basedir/.dirtree-state' && echo OK" \
    "OK"

# 5) closed marker shows '/' for empty dir, '/*' for non-empty
mkdir -p "$basedir/emptydir"
test_function "--simple closed marker variants" \
    "dirtree --simple --default opened -c emptydir -c src '$basedir' && dirtree --simple '$basedir' | awk '/emptydir\/$|emptydir\/\*|src\/\*/{print}' | wc -l | grep -E '^[2-9]$' && echo PASS" \
    "PASS"

# Cleanup temp dir for stateful tests
rm -rf "$tmpdir"

# --- Auto simple mode tests (via env var + non-TTY) ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/src" "$basedir/docs"
touch "$basedir/src/a" "$basedir/docs/b"

# Seed state: default opened, close src
dirtree --simple --default opened -c src "$basedir" >/dev/null

test_function "auto simple via DIRTREE_AUTO_SIMPLE when not TTY" \
  "DIRTREE_AUTO_SIMPLE=1 dirtree '$basedir' | grep -q 'src/\*' && echo OK" \
  "OK"

rm -rf "$tmpdir"

# --- Simple mode: no leading connectors ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/a/b"
touch "$basedir/a/b/file"

test_function "simple: no leading '├──', '└──', or '│   '" \
  "out=\"$(dirtree --simple '$basedir')\"; ! echo \"$out\" | grep -q '^├──' && ! echo \"$out\" | grep -q '^└──' && ! echo \"$out\" | grep -q '^│   ' && echo OK" \
  "OK"

rm -rf "$tmpdir"

# --- Decorated mode respects closed subtrees ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/.git/inner"
touch "$basedir/.git/inner/file"

test_function "decorated mode collapses explicitly closed .git" \
  "dirtree -c .git '$basedir' | grep -q '/.git/\*' || echo PASS" \
  "PASS"

rm -rf "$tmpdir"

# --- Decorated mode keeps colors and doesn't star plain files ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/sub"
touch "$basedir/plain" "$basedir/sub/file"

test_function "decorated output retains ANSI colors when piped" \
  "dirtree '$basedir' | grep -q $'\033\[' && echo OK" \
  "OK"

test_function "decorated output does not star non-executable plain files" \
  "dirtree '$basedir' | grep -q 'plain\*' && echo BAD || echo OK" \
  "OK"

rm -rf "$tmpdir"

# --- Decorated mode adds trailing slashes to dirs, not files ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/dirA" "$basedir/.git" "$basedir/dirB"
touch "$basedir/fileA" "$basedir/.gitignore"

test_function "decorated: dirs end with '/', files do not" \
  "out=\"$(dirtree '$basedir')\"; echo \"$out\" | awk '/dirA/{exit !(/\/$/)}'; echo \"$out\" | awk '/dirB/{exit !(/\/$/)}'; echo \"$out\" | awk '/fileA/{exit (/\/$/)}'; echo OK" \
  "OK"

test_function "decorated: closing .git does not tag .gitignore" \
  "dirtree -c .git '$basedir' | grep -q '.gitignore/\\*' && echo BAD || echo OK" \
  "OK"

rm -rf "$tmpdir"

# --- Decorated mode flush-left: no tree connector glyphs ---
tmpdir=$(mktemp -d)
basedir="$tmpdir/proj"
mkdir -p "$basedir/a/b"
touch "$basedir/a/b/file"

test_function "decorated: no leading '├──', '└──', or '│   '" \
  "out=\"$(dirtree '$basedir')\"; ! echo \"$out\" | grep -q '^├──' && ! echo \"$out\" | grep -q '^└──' && ! echo \"$out\" | grep -q '^│   ' && echo OK" \
  "OK"

rm -rf "$tmpdir"

# Final report
echo
if [[ $failed_count -eq 0 ]]; then
    echo "All $test_count tests passed"
else
    echo "$failed_count of $test_count tests failed" >&2
fi

exit $failed_count
