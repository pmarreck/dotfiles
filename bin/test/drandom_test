#!/usr/bin/env bash

if [ "$DRANDOM_TEST_DEPTH" = "1" ]; then
	exit 0
fi

# Test the drandom function for determinism and statistical properties
test_drandom() {
	local fails=0
	local tests=0
	# Sample sizes (FAST mode reduces iterations for quick --test runs)
	local sample_size=${DRANDOM_TEST_SAMPLE_SIZE:-1000}
	local binary_sample_size=${DRANDOM_TEST_BINARY_SIZE:-1000}
	if [ -n "$FAST" ]; then
		sample_size=40
		binary_sample_size=60
	fi
	local range_start=0
	local range_end=100
	local expected_mean=50

	echo "Testing drandom deterministic RNG..."

	# Test 0: About/Help/Test flags
	(( tests++ ))
	echo "Testing --about/-a flags..."

	local about_output
	about_output=$(drandom --about 2>/dev/null)
	local about_lines
	about_lines=$(printf '%s\n' "$about_output" | wc -l | tr -d ' ')

	if [ -n "$about_output" ] && [ "$about_lines" -eq 1 ] && echo "$about_output" | grep -qi "deterministic"; then
		echo "✓ About flag test passed"
	else
		echo "✗ About flag test failed: output='$about_output' (lines: $about_lines)" >&2
		(( fails++ ))
	fi

	(( tests++ ))
	echo "Testing --help/-h flags..."

	local help_output
	help_output=$(drandom --help)
	local help_status=$?

	if [ $help_status -eq 0 ] && echo "$help_output" | grep -q "Usage: drandom"; then
		echo "✓ Help flag test passed"
	else
		echo "✗ Help flag test failed: status=$help_status" >&2
		(( fails++ ))
	fi

	(( tests++ ))
	echo "Testing --test flag..."

	local test_output
	test_output=$(DRANDOM_TEST_DEPTH=1 DRANDOM_TEST_SAMPLE_SIZE=20 DRANDOM_TEST_BINARY_SIZE=20 drandom --test 2>&1)
	local test_status=$?

	if [ $test_status -eq 0 ] && [ -z "$test_output" ]; then
		echo "✓ --test flag test passed"
	else
		echo "✗ --test flag test failed: status=$test_status, output='$test_output'" >&2
		(( fails++ ))
	fi

	# Test 1: PCG32 known output (ensures algorithm change)
	(( tests++ ))
	echo "Testing PCG32 known output..."

	local pcg_output
	pcg_output=$(DRANDOM_SEED=42 drandom 0 99 2>/dev/null)

	if [ "$pcg_output" = "26" ]; then
		echo "✓ PCG32 known output test passed"
	else
		echo "✗ PCG32 known output test failed: expected 26, got $pcg_output" >&2
		(( fails++ ))
	fi

	# Test 2: Determinism - same seed should produce same sequence
	(( tests++ ))
	echo "Testing determinism..."

	local seed="12345"
	local seq1=$(DRANDOM_SEED=$seed bash -c 'for i in {1..10}; do drandom; done' 2>/dev/null | tr '\n' ' ')
	local seq2=$(DRANDOM_SEED=$seed bash -c 'for i in {1..10}; do drandom; done' 2>/dev/null | tr '\n' ' ')

	if [ "$seq1" = "$seq2" ]; then
		echo "✓ Determinism test passed: same seed produces same sequence"
	else
		echo "✗ Determinism test failed:" >&2
		echo "  Sequence 1: $seq1" >&2
		echo "  Sequence 2: $seq2" >&2
		(( fails++ ))
	fi

	# Test 3: Different seeds produce different sequences
	(( tests++ ))
	echo "Testing seed variation..."

	local seq_a=$(DRANDOM_SEED=11111 bash -c 'for i in {1..10}; do drandom; done' 2>/dev/null | tr '\n' ' ')
	local seq_b=$(DRANDOM_SEED=22222 bash -c 'for i in {1..10}; do drandom; done' 2>/dev/null | tr '\n' ' ')

	if [ "$seq_a" != "$seq_b" ]; then
		echo "✓ Seed variation test passed: different seeds produce different sequences"
	else
		echo "✗ Seed variation test failed: different seeds produced identical sequences" >&2
		echo "  Sequence A: $seq_a" >&2
		echo "  Sequence B: $seq_b" >&2
		(( fails++ ))
	fi

	# Test 4: Range bounds - all values should be within specified range
	(( tests++ ))
	echo "Testing range bounds..."

	local out_of_bounds=0
	local test_start=10
	local test_end=20

	for ((i=0; i<100; i++)); do
		local val=$(DRANDOM_SEED=$i drandom $test_start $test_end 2>/dev/null)
		if (( val < test_start || val > test_end )); then
			(( out_of_bounds++ ))
		fi
	done

	if [ $out_of_bounds -eq 0 ]; then
		echo "✓ Range bounds test passed: all values within [$test_start, $test_end]"
	else
		echo "✗ Range bounds test failed: $out_of_bounds values out of bounds" >&2
		(( fails++ ))
	fi

	# Test 5: Statistical properties - should be reasonably uniform over large sample
	(( tests++ ))
	echo "Testing statistical uniformity (this may take a moment)..."

	# Generate samples and calculate statistics using awk
	local stats=$(for ((i=0; i<sample_size; i++)); do
		DRANDOM_SEED=$((12345 + i)) drandom $range_start $range_end 2>/dev/null
	done | awk -v range_start="$range_start" -v range_end="$range_end" -v expected_mean="$expected_mean" '
	{
		samples[NR] = $1
		sum += $1
		if (NR == 1 || $1 < min) min = $1
		if (NR == 1 || $1 > max) max = $1
	}
	END {
		mean = sum / NR

		# Calculate standard deviation
		for (i = 1; i <= NR; i++) {
			variance_sum += (samples[i] - mean) * (samples[i] - mean)
		}
		stddev = sqrt(variance_sum / (NR - 1))

		# For uniform distribution over [a,b], expected stddev = (b-a)/sqrt(12)
		expected_stddev = (range_end - range_start) / sqrt(12)

		printf "ACTUAL_MEAN=%.2f\n", mean
		printf "ACTUAL_STDDEV=%.2f\n", stddev
		printf "EXPECTED_STDDEV=%.2f\n", expected_stddev
		printf "MIN=%d\n", min
		printf "MAX=%d\n", max
	}')

	# Parse the results
	eval "$stats"

	echo "  Statistical Analysis:"
	echo "    Sample size: $sample_size"
	echo "    Range: [$MIN, $MAX]"
	echo "    Expected mean: $expected_mean"
	echo "    Actual mean: $ACTUAL_MEAN"
	echo "    Expected stddev (uniform): $EXPECTED_STDDEV"
	echo "    Actual stddev: $ACTUAL_STDDEV"

	# Mean should be close to expected (within 5% of range)
	local mean_diff=$(echo "scale=2; if ($ACTUAL_MEAN - $expected_mean < 0) $expected_mean - $ACTUAL_MEAN else $ACTUAL_MEAN - $expected_mean" | bc -l)
	local mean_tolerance=5.0

	# Standard deviation should be reasonably close to uniform distribution expectation (within 50%)
	local stddev_tolerance=$(echo "scale=2; $EXPECTED_STDDEV * 0.50" | bc -l)
	local stddev_diff=$(echo "scale=2; if ($ACTUAL_STDDEV - $EXPECTED_STDDEV < 0) $EXPECTED_STDDEV - $ACTUAL_STDDEV else $ACTUAL_STDDEV - $EXPECTED_STDDEV" | bc -l)

	local statistical_pass=true

	if (( $(echo "$mean_diff > $mean_tolerance" | bc -l) )); then
		echo "    ✗ Mean test failed: difference $mean_diff > $mean_tolerance" >&2
		statistical_pass=false
	else
		echo "    ✓ Mean test passed (diff: $mean_diff <= $mean_tolerance)"
	fi

	if (( $(echo "$stddev_diff > $stddev_tolerance" | bc -l) )); then
		echo "    ✗ Standard deviation test failed: difference $stddev_diff > $stddev_tolerance" >&2
		statistical_pass=false
	else
		echo "    ✓ Standard deviation test passed (diff: $stddev_diff <= $stddev_tolerance)"
	fi

	if $statistical_pass; then
		echo "✓ Statistical uniformity test passed"
	else
		(( fails++ ))
	fi

	# Test 6: Binary range test (0-1 should not alternate mechanically AND should be statistically balanced)
	(( tests++ ))
	echo "Testing binary range for quality..."

	local binary_data=$(for ((i=0; i<binary_sample_size; i++)); do
		DRANDOM_SEED=$((5000 + i)) drandom 0 1 2>/dev/null
	done)

	# Count 0s and 1s
	local count_0=$(echo "$binary_data" | grep -c "^0$")
	local count_1=$(echo "$binary_data" | grep -c "^1$")
	local total_count=$((count_0 + count_1))

	# Calculate percentages
	local pct_0=$(echo "scale=1; $count_0 * 100 / $total_count" | bc -l)
	local pct_1=$(echo "scale=1; $count_1 * 100 / $total_count" | bc -l)

	echo "  Binary sample analysis ($binary_sample_size samples):"
	echo "    0s: $count_0 ($pct_0%)"
	echo "    1s: $count_1 ($pct_1%)"

	# Test for mechanical alternation with a smaller sequence
	local short_seq=$(DRANDOM_SEED=1000 bash -c 'for i in {1..20}; do drandom 0 1; done' 2>/dev/null | tr -d '\n')
	local alternating_pattern="01010101010101010101"
	local reverse_alternating="10101010101010101010"

	local binary_test_pass=true

	# Test 1: No mechanical alternation
	if [ "$short_seq" = "$alternating_pattern" ] || [ "$short_seq" = "$reverse_alternating" ]; then
		echo "  ✗ Mechanical alternation detected in sequence: $short_seq" >&2
		binary_test_pass=false
	else
		# Check for runs (consecutive values)
		local has_runs=false
		for pattern in "00" "11"; do
			if [[ "$short_seq" == *"$pattern"* ]]; then
				has_runs=true
				break
			fi
		done

		if $has_runs; then
			echo "  ✓ No mechanical alternation, runs detected"
		else
			echo "  ✗ Suspicious: no runs found in sequence: $short_seq" >&2
			binary_test_pass=false
		fi
	fi

	# Test 2: Statistical balance (should be within 40%-60% for each value)
	if (( $(echo "$pct_0 >= 40 && $pct_0 <= 60" | bc -l) )) && (( $(echo "$pct_1 >= 40 && $pct_1 <= 60" | bc -l) )); then
		echo "  ✓ Statistical balance maintained (both values 40-60%)"
	else
		echo "  ✗ Statistical imbalance: 0s=$pct_0%, 1s=$pct_1% (expected 40-60% each)" >&2
		binary_test_pass=false
	fi

	if $binary_test_pass; then
		echo "✓ Binary range test passed: no alternation + statistical balance"
	else
		(( fails++ ))
	fi

	# Test 7: Hex seed support
	(( tests++ ))
	echo "Testing hex seed support..."

	# 6a: Raw hex (no 0x) should be deterministic and produce same sequence twice
	local hex_seq1=$(DRANDOM_SEED="DEADBEEF" bash -c 'for i in {1..5}; do drandom; done' 2>/dev/null | tr '\n' ' ')
	local hex_seq2=$(DRANDOM_SEED="DEADBEEF" bash -c 'for i in {1..5}; do drandom; done' 2>/dev/null | tr '\n' ' ')

	if [ "$hex_seq1" = "$hex_seq2" ]; then
		echo "✓ Hex seed test (raw) passed: raw hex works deterministically"
	else
		echo "✗ Hex seed test failed: hex seed not deterministic" >&2
		echo "  Sequence 1: $hex_seq1" >&2
		echo "  Sequence 2: $hex_seq2" >&2
		(( fails++ ))
	fi

	# 6b: 0x-prefixed hex should match raw-hex interpretation (aside from warning)
	local hex_seq_pref=$(DRANDOM_SEED="0xDEADBEEF" bash -c 'for i in {1..5}; do drandom; done' 2>/dev/null | tr '\n' ' ')
	if [ "$hex_seq_pref" = "$hex_seq1" ]; then
		echo "✓ Hex seed test (0x) passed: 0x-prefixed hex matches raw-hex interpretation"
	else
		echo "✗ Hex seed 0x test failed: sequences differ" >&2
		echo "  Raw hex: $hex_seq1" >&2
		echo "  0x hex: $hex_seq_pref" >&2
		(( fails++ ))
	fi

	# 6c: Raw hex without 0x should emit a warning on stderr
	local warn_ctx="warnctx-$$-$RANDOM"
	local warn_output=$(DRANDOM_STATE_HOME="$HOME/dotfiles/.state" DRANDOM_CONTEXT="$warn_ctx" DRANDOM_SEED="DEADBEEF" drandom 2>&1 >/dev/null)
	if echo "$warn_output" | grep -qi "warning.*hex.*0x"; then
		echo "✓ Hex seed warning test passed: warning emitted for raw hex without 0x"
	else
		echo "✗ Hex seed warning test failed: no warning emitted" >&2
		(( fails++ ))
	fi

	# Test 8: Cross-invocation determinism when seeding once per terminal
	(( tests++ ))
	echo "Testing cross-invocation determinism (seed once, then call again)..."

	# Use a unique context per test run to avoid interference
	local ctx="testctx-$$-$RANDOM"
	local state_home="$HOME/dotfiles/.state"

	# First pair: seed, then call again (two separate invocations)
	DRANDOM_STATE_HOME="$state_home" DRANDOM_CONTEXT="$ctx" DRANDOM_SEED=12345 drandom >/dev/null 2>/dev/null
	local second1=$(DRANDOM_STATE_HOME="$state_home" DRANDOM_CONTEXT="$ctx" drandom 2>/dev/null)

	# Small delay to ensure time-based seeding would differ if persistence is broken
	sleep 0.02

	# Second pair: repeat the above; with proper persistence, the second value should match
	DRANDOM_STATE_HOME="$state_home" DRANDOM_CONTEXT="$ctx" DRANDOM_SEED=12345 drandom >/dev/null 2>/dev/null
	local second2=$(DRANDOM_STATE_HOME="$state_home" DRANDOM_CONTEXT="$ctx" drandom 2>/dev/null)

	# Cleanup test seed file
	rm -f "$state_home/drandom/$USER/${ctx}.seed" 2>/dev/null || true

	if [ "$second1" = "$second2" ]; then
		echo "✓ Cross-invocation determinism test passed"
	else
		echo "✗ Cross-invocation determinism test failed: second values differ across pairs" >&2
		echo "  Second1: $second1" >&2
		echo "  Second2: $second2" >&2
		(( fails++ ))
	fi

	# Final results
	if [ $fails -gt 0 ]; then
		echo "" >&2
		echo "drandom test FAILED: $fails of $tests tests failed" >&2
		echo "The drandom function has issues with determinism or statistical properties." >&2
		return $fails
	else
		echo ""
		echo "drandom test PASSED: All $tests tests passed"
		echo "The drandom function provides good deterministic randomness."
		return 0
	fi
}

# Run the test if this script is executed directly
if ! (return 0 2>/dev/null); then
	test_drandom
	exit $?
fi
