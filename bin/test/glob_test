#!/usr/bin/env bash

PATH="$HOME/bin:$PATH"

test_glob() {
  local fails=0
  local tests=0
  local output
  local glob_path

  glob_path=$(command -v glob)

  # Create test directory
  pushd "$(mktemp --tmpdir -d glob_test.XXXXXX)" >/dev/null

  # Test 1: Direct pattern expansion
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  output=$(glob "test*.jpg" 2>/dev/null)
  expected_files=$'test with spaces.jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should glob glob patterns correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 2: Command with pattern
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  output=$(glob echo "test*.jpg" 2>/dev/null)
  expected_files="test with spaces.jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should execute commands with globed arguments"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 3: Command with multiple patterns
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  # For this test, we expect test1.jpg to appear twice, once from direct arg and once from expansion
  output=$(glob echo "test1.jpg" "test*.jpg" 2>/dev/null)
  # Expected output is the sorted list of files with test1.jpg appearing twice
  expected_files="test with spaces.jpg test1.jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should handle multiple arguments correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 4: Pattern with spaces
  (( tests++ ))
  # Create test file for this test
  touch "test with spaces.jpg"
  output=$(glob "test with*.jpg" 2>/dev/null)
  assert "$output" == "test with spaces.jpg" "glob should handle patterns with spaces"
  (( fails += $? ))
  # Clean up test file
  rm -f "test with spaces.jpg"

  # Test 5: Non-matching pattern (new behavior: empty result)
  (( tests++ ))
  output=$(glob "nonexistent*.jpg" 2>/dev/null)
  assert "$output" == "" "glob should return empty result when no matches are found"
  (( fails += $? ))

  # Test 5b: Non-matching pattern exit code
  (( tests++ ))
  glob "nonexistent*.jpg" >/dev/null 2>&1
  exit_code=$?
  assert "$exit_code" == "1" "glob should return exit code 1 when no matches are found"
  (( fails += $? ))

  # Test 6: Command with non-matching pattern (should execute command with no args)
  (( tests++ ))
  output=$(glob echo "nonexistent*.jpg" 2>/dev/null)
  assert "$output" == "" "glob should execute command with no arguments when no patterns match"
  (( fails += $? ))

  # Test 7: Command with options
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  output=$(glob echo -n "test*.jpg" 2>/dev/null)
  # The -n option should be passed through
  expected_files="test with spaces.jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should pass options to commands"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 8: Verify sorting order with diverse filenames
  (( tests++ ))
  # Create diverse files to test sorting
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  output=$(glob "*.jpg" 2>/dev/null)
  expected_files=$'aafirst.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should sort filenames correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg

  # Test 9: Sorting with multiple patterns
  (( tests++ ))
  # Create diverse files to test sorting with multiple patterns
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  output=$(glob echo "a*.jpg" "t*.jpg" "z*.jpg" 2>/dev/null)
  expected_files="aafirst.jpg test with spaces.jpg test1.jpg test2.jpg zzlast.jpg"
  assert "$output" == "$expected_files" "glob should handle multiple patterns and sort correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  
  # Test 10: Respect nullglob setting (when nullglob is set, non-matching patterns disappear)
  (( tests++ ))
  # Create test file for this test
  touch aafirst.jpg
  # Test with ls command and nullglob enabled
  # When nullglob is set, non-matching patterns should be removed completely
  output=$(bash -O nullglob "$glob_path" ls "nonexistent*.jpg" "a*.jpg" 2>/dev/null)
  # Should only include aafirst.jpg, not the nonexistent pattern
  expected_files="aafirst.jpg"
  assert "$output" == "$expected_files" "glob should respect nullglob setting (enabled)"
  (( fails += $? ))
  # Clean up test file
  rm -f aafirst.jpg
  
  # Test 11: Respect dotglob setting (when dotglob is set, hidden files are included)
  (( tests++ ))
  # Create test files including a hidden file
  touch ".hidden.jpg" aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  
  output=$(bash -O dotglob "$glob_path" "*.jpg" 2>/dev/null)
  # Should include the hidden file
  expected_files=$'.hidden.jpg\naafirst.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should respect dotglob setting (enabled)"
  (( fails += $? ))
  
  output=$(bash "$glob_path" "*.jpg" 2>/dev/null)
  # Should NOT include the hidden file
  expected_files=$'aafirst.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should respect dotglob setting (disabled)"
  (( fails += $? ))
  
  # Clean up all test files
  rm -f ".hidden.jpg" aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg

  # Test 12: --dotglob includes dotfiles even when dotglob is disabled
  (( tests++ ))
  touch ".hidden.par2"
  output=$(bash "$glob_path" --dotglob "**/*.par2" 2>/dev/null)
  expected_files=".hidden.par2"
  assert "$output" == "$expected_files" "glob --dotglob should include dotfiles even when dotglob is disabled"
  (( fails += $? ))
  rm -f ".hidden.par2"

  # Test 13: --dotfiles is a synonym for --dotglob
  (( tests++ ))
  touch ".hidden.par2"
  output=$(bash "$glob_path" --dotfiles "**/*.par2" 2>/dev/null)
  expected_files=".hidden.par2"
  assert "$output" == "$expected_files" "glob --dotfiles should include dotfiles like --dotglob"
  (( fails += $? ))
  rm -f ".hidden.par2"

  # Test 14: --all includes dotfiles even when dotglob is disabled
  (( tests++ ))
  touch ".hidden1.par2" ".hidden2.par2"
  output=$(bash "$glob_path" --all "**/*.par2" 2>/dev/null)
  expected_files=$'.hidden1.par2\n.hidden2.par2'
  assert "$output" == "$expected_files" "glob --all should include dotfiles even when dotglob is disabled"
  (( fails += $? ))
  rm -f ".hidden1.par2" ".hidden2.par2"

  # Test 15: Recursive globbing with ** pattern
  (( tests++ ))
  # Create a subdirectory structure and files
  mkdir -p subdir1/subdir2
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  touch subdir1/nested1.jpg subdir1/subdir2/nested2.jpg
  
  # Test recursive globbing
  output=$(glob "**/*.jpg" 2>/dev/null)
  expected_files=$'aafirst.jpg\nsubdir1/nested1.jpg\nsubdir1/subdir2/nested2.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should handle recursive ** patterns"
  (( fails += $? ))
  # Clean up test files and directories
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  rm -rf subdir1

  # Test 16: Recursive globbing with set -f (globbing disabled)
  (( tests++ ))
  # Create a subdirectory structure and files
  mkdir -p subdir1/subdir2
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  touch subdir1/nested1.jpg subdir1/subdir2/nested2.jpg
  # Save current noglob setting
  local old_noglob_setting
  [[ -o noglob ]] && old_noglob_setting=true || old_noglob_setting=false
  
  # Disable globbing
  set -f
  output=$(glob "**/*.jpg" 2>/dev/null)
  expected_files=$'aafirst.jpg\nsubdir1/nested1.jpg\nsubdir1/subdir2/nested2.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should handle recursive ** patterns with globbing disabled"
  (( fails += $? ))
  
  # Restore original noglob setting
  $old_noglob_setting || set +f
  # Clean up test files and directories
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  rm -rf subdir1
  
  # Test 17: Command with recursive pattern
  (( tests++ ))
  # Create a subdirectory structure and files
  mkdir -p subdir1/subdir2
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  touch subdir1/nested1.jpg subdir1/subdir2/nested2.jpg
  output=$(glob echo "**/*.jpg" 2>/dev/null)
  expected_files="aafirst.jpg subdir1/nested1.jpg subdir1/subdir2/nested2.jpg test with spaces.jpg test1.jpg test2.jpg zzlast.jpg"
  assert "$output" == "$expected_files" "glob should execute commands with recursive ** patterns"
  (( fails += $? ))
  # Clean up test files and directories
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  rm -rf subdir1
  
  # Test 18: Recursive pattern with nullglob
  (( tests++ ))
  # Test with a non-matching recursive pattern and command mode
  # When nullglob is set, non-matching patterns should be removed completely
  output=$(bash -O nullglob "$glob_path" ls "**/nonexistent*.jpg" 2>/dev/null)
  # Should be empty with nullglob
  expected_files=""
  assert "$output" == "$expected_files" "glob should respect nullglob with recursive patterns"
  (( fails += $? ))
  
  # Test 19: Case-insensitive matching with --ignore-case
  (( tests++ ))
  # Create test files with mixed case (including lowercase files for case-sensitive test)
  touch "Test.JPG" "test.Jpg" "TEST.jpg" "other.png" "test with spaces.jpg" "test1.jpg" "test2.jpg"
  
  # Test without ignore-case flag (should only match exact case)
  output=$(glob "test*.jpg" 2>/dev/null)
  expected_files=$'test with spaces.jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should be case-sensitive by default"
  (( fails += $? ))
  
  # Test with --ignore-case flag (should match all case variations)
  (( tests++ ))
  output=$(glob --ignore-case "test*.jpg" 2>/dev/null)
  expected_files=$'TEST.jpg\nTest.JPG\ntest with spaces.jpg\ntest.Jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should match case-insensitively with --ignore-case"
  (( fails += $? ))
  
  # Test 21: Case-insensitive matching with -i (shorthand)
  (( tests++ ))
  output=$(glob -i "test*.jpg" 2>/dev/null)
  expected_files=$'TEST.jpg\nTest.JPG\ntest with spaces.jpg\ntest.Jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should match case-insensitively with -i shorthand"
  (( fails += $? ))
  
  # Test 22: Case-insensitive with command execution
  (( tests++ ))
  output=$(glob -i echo "test*.jpg" 2>/dev/null)
  expected_files="TEST.jpg Test.JPG test with spaces.jpg test.Jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should execute commands with case-insensitive matching"
  (( fails += $? ))
  
  # Clean up case-insensitive test files
  rm -f "Test.JPG" "test.Jpg" "TEST.jpg" "other.png" "test with spaces.jpg" "test1.jpg" "test2.jpg"
  
  # Test 23: Mixed matching and non-matching patterns
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg
  output=$(glob "test1.jpg" "nonexistent*.jpg" "test2.jpg" 2>/dev/null)
  expected_files=$'test1.jpg\\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should include only matching patterns, skip non-matching ones"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg
  
  # Test 24: All patterns non-matching should return empty and exit 1
  (( tests++ ))
  glob "nonexistent1*.jpg" "nonexistent2*.png" >/dev/null 2>&1
  exit_code=$?
  assert "$exit_code" == "1" "glob should return exit code 1 when no patterns match"
  (( fails += $? ))
  
  # Test 25: Mixed patterns with command execution
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg
  output=$(glob echo "test1.jpg" "nonexistent*.jpg" "test2.jpg" 2>/dev/null)
  expected_files="test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should pass only matching patterns to commands"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg
  
  # Test 26: Quoted brace expansion with simple patterns
  (( tests++ ))
  # Create test files for brace expansion
  touch test1.jpg test2.jpg test.png
  output=$(glob "*.{jpg,png}" 2>/dev/null)
  expected_files=$'test.png\\ntest1.jpg\\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should handle quoted brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg test.png
  
  # Test 27: Quoted brace expansion with spaces in paths
  (( tests++ ))
  # Create directory and files with spaces for this test
  mkdir -p "dir with spaces"
  touch "dir with spaces/file.jpg" "dir with spaces/file.png"
  output=$(glob "dir with spaces/*.{jpg,png}" 2>/dev/null)
  expected_files=$'dir with spaces/file.jpg\ndir with spaces/file.png'
  assert "$output" == "$expected_files" "glob should handle quoted brace expansion with spaces in paths"
  (( fails += $? ))
  # Clean up test files and directory
  rm -rf "dir with spaces"
  
  # Test 28: Quoted brace expansion with command execution
  (( tests++ ))
  # Create test files for command mode brace expansion
  touch test1.jpg test2.jpg test.png
  output=$(glob echo "*.{jpg,png}" 2>/dev/null)
  expected_files="test.png test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should handle quoted brace expansion in command mode"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg test.png
  
  # Test 29: Complex brace expansion with multiple braces
  (( tests++ ))
  touch "a.txt" "b.txt" "c.log" "d.log"
  output=$(glob "*.{txt,log}" 2>/dev/null)
  expected_files=$'a.txt\nb.txt\nc.log\nd.log'
  assert "$output" == "$expected_files" "glob should handle multiple files with brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f "a.txt" "b.txt" "c.log" "d.log"
  
  # Test 30: Nested brace expansion (if supported by bash)
  (( tests++ ))
  touch "file1.jpg" "file2.jpg" "file1.png" "file2.png"
  output=$(glob "file{1,2}.{jpg,png}" 2>/dev/null)
  expected_files=$'file1.jpg\nfile1.png\nfile2.jpg\nfile2.png'
  assert "$output" == "$expected_files" "glob should handle nested brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f "file1.jpg" "file2.jpg" "file1.png" "file2.png"
  
  # Test 31: Case-insensitive with quoted brace expansion and wildcards
  (( tests++ ))
  touch "CaseTest.jpg" "CaseTest.png"
  output=$(glob -i "casetest*.{jpg,png}" 2>/dev/null)
  expected_files=$'CaseTest.jpg\nCaseTest.png'
  assert "$output" == "$expected_files" "glob should handle case-insensitive quoted brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f "CaseTest.jpg" "CaseTest.png"
  
  # Test 32: Case-insensitive recursive brace expansion should not treat first result as command
  (( tests++ ))
  # Create test files in subdirectories (recursive patterns only match subdirectories)
  mkdir -p "subdir with spaces"
  touch "subdir with spaces/image.jpg" "subdir with spaces/image.png"
  output=$(glob -i "**/*.{jpg,png}" 2>/dev/null)
  expected_files=$'subdir with spaces/image.jpg\nsubdir with spaces/image.png'
  assert "$output" == "$expected_files" "glob should not treat first match as command in direct mode"
  (( fails += $? ))
  # Clean up test files
  rm -rf "subdir with spaces"
  
  # Test 33: Relative path to executable should work in command mode
  (( tests++ ))
  # Create a substantial executable script that file will recognize
  cat > my-script << 'EOF'
#!/usr/bin/env bash
# A test script for glob testing
# This needs to be substantial enough for file to recognize it as a shell script

echo "script output: $*"
EOF
  chmod +x my-script
  touch test.txt other.txt
  output=$(glob ./my-script "*.txt" 2>/dev/null)
  expected_output="script output: other.txt test.txt"
  assert "$output" == "$expected_output" "glob should treat relative path to executable as command"
  (( fails += $? ))
  # Clean up
  rm -f my-script test.txt other.txt
  
  # Test 34: Absolute path to executable should work in command mode  
  (( tests++ ))
  touch test.txt other.txt
  # Use the actual path to echo on this system
  local echo_path=$(which echo)
  output=$(glob "$echo_path" "*.txt" 2>/dev/null)
  expected_output="other.txt test.txt"
  assert "$output" == "$expected_output" "glob should treat absolute path to executable as command"
  (( fails += $? ))
  # Clean up
  rm -f test.txt other.txt
  
  # Test 35: Non-executable file should be treated as pattern (direct mode)
  (( tests++ ))
  echo "not a script" > not-executable
  touch test.txt
  output=$(glob "not-executable" "*.txt" 2>/dev/null)
  expected_files=$'not-executable\ntest.txt'
  assert "$output" == "$expected_files" "glob should treat non-executable file as pattern in direct mode"
  (( fails += $? ))
  # Clean up
  rm -f not-executable test.txt
  
  # Test 36: File path with spaces should be direct mode (not treated as command)
  (( tests++ ))
  touch "file with spaces.jpg" "other.txt"
  output=$(glob "file with spaces.jpg" "*.txt" 2>/dev/null)
  expected_files=$'file with spaces.jpg\\nother.txt'
  assert "$output" == "$expected_files" "glob should treat file paths as patterns in direct mode"
  (( fails += $? ))
  # Clean up
  rm -f "file with spaces.jpg" "other.txt"
  
  # Test 37: Executable file with path separators should be direct mode when it's clearly a filename
  (( tests++ ))
  mkdir -p subdir
  # Create a file that looks like a data file but is technically executable
  # The .jpg extension should make it clear this isn't meant to be a command
  cat > "subdir/fake-command.jpg" << 'EOF'
#!/usr/bin/env bash
# This looks like a script but has a .jpg extension
# so it should be treated as a data file, not a command
echo "should not execute"
EOF
  chmod +x "subdir/fake-command.jpg"
  touch test.txt
  output=$(glob "subdir/fake-command.jpg" "*.txt" 2>/dev/null)
  expected_files=$'subdir/fake-command.jpg\ntest.txt'
  assert "$output" == "$expected_files" "glob should treat executable files that look like data files as patterns"
  (( fails += $? ))
  # Clean up
  rm -rf subdir test.txt
  
  # Test 38: Relative pattern with spaces and slashes globs correctly (direct mode)
  (( tests++ ))
  mkdir -p "sys (twserver)/system/SAGA"
  touch "sys (twserver)/system/SAGA/A.md" "sys (twserver)/system/SAGA/B.txt" "sys (twserver)/system/SAGA/C.MD"
  output=$(glob "sys (twserver)/system/SAGA/*.md" 2>/dev/null)
  expected_files="sys (twserver)/system/SAGA/A.md"
  assert "$output" == "$expected_files" "glob should glob relative pattern with spaces and slashes (case-sensitive)"
  (( fails += $? ))
  
  # Test 39: Relative pattern with spaces and slashes with --ignore-case (direct mode)
  (( tests++ ))
  output=$(glob --ignore-case "sys (twserver)/system/SAGA/*.md" 2>/dev/null)
  expected_files=$'sys (twserver)/system/SAGA/A.md\nsys (twserver)/system/SAGA/C.MD'
  assert "$output" == "$expected_files" "glob should glob relative pattern with spaces and slashes (case-insensitive)"
  (( fails += $? ))
  
  # Cleanup for tests 35/36
  rm -rf "sys (twserver)"
  
  # Test 40: Default output format should be newline-separated without escaping
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob "*.jpg" "*.txt" 2>/dev/null)
  expected_output=$'other.txt\ntest with spaces.jpg'
  assert "$output" == "$expected_output" "glob should use newline-separated output by default without escaping spaces"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 41: -n flag should produce space-separated output with escaping (old behavior)
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob -n "*.jpg" "*.txt" 2>/dev/null)
  expected_output="other.txt test\\ with\\ spaces.jpg "
  assert "$output" == "$expected_output" "glob -n should use space-separated output with escaping"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 42: -0 flag should produce null-separated output without escaping
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob -0 "*.jpg" "*.txt" 2>/dev/null | tr '\0' '|')
  expected_output="other.txt|test with spaces.jpg|"
  assert "$output" == "$expected_output" "glob -0 should use null-separated output without escaping"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 43: Last flag wins (-0 after -n)
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob -n -0 "*.jpg" "*.txt" 2>/dev/null | tr '\0' '|')
  expected_output="other.txt|test with spaces.jpg|"
  assert "$output" == "$expected_output" "glob -n -0 should use null-separated output (last flag wins)"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 44: Last flag wins (-n after -0)
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"  
  output=$(glob -0 -n "*.jpg" "*.txt" 2>/dev/null)
  expected_output="other.txt test\\ with\\ spaces.jpg "
  assert "$output" == "$expected_output" "glob -0 -n should use space-separated output (last flag wins)"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"

  # Test 45: Recursive globbing should include directories (e.g. **/node_modules)
  (( tests++ ))
  mkdir -p project/node_modules lib/components/node_modules shared/plugins
  output=$(glob "**/node_modules" 2>/dev/null)
  expected_output=$'lib/components/node_modules\nproject/node_modules'
  assert "$output" == "$expected_output" "glob should return directories when pattern matches them"
  (( fails += $? ))
  rm -rf project lib shared

  # Test 46: --double-quote should wrap output and escape embedded quotes
  (( tests++ ))
  touch 'plain.txt' 'file "quote".txt'
  output=$(glob --double-quote "*.txt" 2>/dev/null)
  expected_output=$'"file \\\"quote\\\".txt"\n"plain.txt"'
  assert "$output" == "$expected_output" "glob --double-quote should double-quote results"
  (( fails += $? ))
  rm -f 'plain.txt' 'file "quote".txt'

  # Test 47: --double-quote should ignore -n with warning
  (( tests++ ))
  touch warn.txt
  warning=$(glob --double-quote -n "*.txt" 2>&1 >/dev/null)
  assert "$warning" == "Warning: -n is ignored when --double-quote is used" "glob should warn when -n is combined with --double-quote"
  (( fails += $? ))
  rm -f warn.txt

  # Test 48: --double-quote should ignore -0 with warning
  (( tests++ ))
  touch warn0.txt
  warning=$(glob --double-quote -0 "*.txt" 2>&1 >/dev/null)
  assert "$warning" == "Warning: -0 is ignored when --double-quote is used" "glob should warn when -0 is combined with --double-quote"
  (( fails += $? ))
  rm -f warn0.txt
  
  # Test 49: --double-quote should not be allowed in command mode
  (( tests++ ))
  glob --double-quote echo "*.txt" >/dev/null 2>&1
  exit_code=$?
  assert "$exit_code" == "2" "glob --double-quote should error in command mode"
  (( fails += $? ))

  # Test 50: Command mode should error when argument list is too long without --batch
  (( tests++ ))
  mkdir -p many-args
  local too_many_files=()
  for i in {1..12}; do
    printf -v filename "many-args/file_%02d_with_a_very_long_name.par2" "$i"
    touch "$filename"
    too_many_files+=("$filename")
  done
  output=$(GLOB_ARG_MAX=200 glob rm "many-args/*.par2" 2>&1 >/dev/null)
  exit_code=$?
  assert "$exit_code" == "2" "glob should error when arguments exceed ARG_MAX without --batch"
  (( fails += $? ))
  assert "$output" =~ "--batch" "glob should suggest --batch when arguments are too long"
  (( fails += $? ))
  rm -rf many-args

  # Test 51: --batch should split command executions to stay under ARG_MAX
  (( tests++ ))
  mkdir -p many-args
  local batched_files=()
  for i in {1..12}; do
    printf -v filename "many-args/file_%02d_with_a_very_long_name.par2" "$i"
    touch "$filename"
    batched_files+=("$filename")
  done
  cat > "print-args" << 'EOF'
#!/usr/bin/env bash
if [ -n "$RUN_LOG" ]; then
	echo "run" >> "$RUN_LOG"
fi
printf "%s\n" "$@"
EOF
  chmod +x "print-args"
  run_log="$PWD/run-log.txt"
  batch_err_file="$PWD/batch-err.txt"
  output=$(RUN_LOG="$run_log" GLOB_ARG_MAX=200 glob --batch "$PWD/print-args" "many-args/*.par2" 2>"$batch_err_file")
  expected_output=$(printf "%s\n" "${batched_files[@]}" | LC_ALL=C sort)
  assert "$output" == "$expected_output" "glob --batch should return all arguments across chunks"
  (( fails += $? ))
  run_count=$(wc -l < "$run_log" | tr -d ' ')
  if (( run_count >= 2 )); then
    :
  else
    echo "Expected --batch to run command multiple times (got $run_count)" >&2
    (( fails++ ))
  fi
  batch_err=$(cat "$batch_err_file")
  assert "$batch_err" =~ "batching results into" "glob --batch should announce batching"
  (( fails += $? ))
  batch_lines=$(printf "%s" "$batch_err" | grep -c "Batch [0-9][0-9]*/[0-9][0-9]* done")
  if (( batch_lines == run_count )); then
    :
  else
    echo "Expected $run_count batch messages (got $batch_lines)" >&2
    (( fails++ ))
  fi
  assert "$batch_err" =~ "ETA" "glob --batch should include ETA after first batch"
  (( fails += $? ))
  rm -rf many-args "print-args" "$run_log" "$batch_err_file"

  # Leave temp dir (mktemp -d creates a temporary directory that will be cleaned up by the system)
  popd >/dev/null

  # Final summary
  if [ $fails -gt 0 ]; then
    red_text "$fails of $tests glob tests failed!\n" >&2
  else
    green_text "All $tests glob tests passed!\n" >&2
  fi
  return $fails
}

# Run the test if this script is executed directly
if ! (return 0 2>/dev/null); then
  test_glob
fi
