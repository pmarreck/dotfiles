#!/usr/bin/env bash

source $HOME/dotfiles/bin/glob

test_glob() {
  local fails=0
  local tests=0
  local output

  # Create test directory
  pushd "$(mktemp --tmpdir -d glob_test.XXXXXX)" >/dev/null

  # Test 1: Direct pattern expansion
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  output=$(glob "test*.jpg" 2>/dev/null)
  expected_files=$'test with spaces.jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should glob glob patterns correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 2: Command with pattern
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  output=$(glob echo "test*.jpg" 2>/dev/null)
  expected_files="test with spaces.jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should execute commands with globed arguments"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 3: Command with multiple patterns
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  # For this test, we expect test1.jpg to appear twice, once from direct arg and once from expansion
  output=$(glob echo "test1.jpg" "test*.jpg" 2>/dev/null)
  # Expected output is the sorted list of files with test1.jpg appearing twice
  expected_files="test with spaces.jpg test1.jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should handle multiple arguments correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 4: Pattern with spaces
  (( tests++ ))
  # Create test file for this test
  touch "test with spaces.jpg"
  output=$(glob "test with*.jpg" 2>/dev/null)
  assert "$output" == "test with spaces.jpg" "glob should handle patterns with spaces"
  (( fails += $? ))
  # Clean up test file
  rm -f "test with spaces.jpg"

  # Test 5: Non-matching pattern (new behavior: empty result)
  (( tests++ ))
  output=$(glob "nonexistent*.jpg" 2>/dev/null)
  assert "$output" == "" "glob should return empty result when no matches are found"
  (( fails += $? ))

  # Test 5b: Non-matching pattern exit code
  (( tests++ ))
  glob "nonexistent*.jpg" >/dev/null 2>&1
  exit_code=$?
  assert "$exit_code" == "1" "glob should return exit code 1 when no matches are found"
  (( fails += $? ))

  # Test 6: Command with non-matching pattern (should execute command with no args)
  (( tests++ ))
  output=$(glob echo "nonexistent*.jpg" 2>/dev/null)
  assert "$output" == "" "glob should execute command with no arguments when no patterns match"
  (( fails += $? ))

  # Test 7: Command with options
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg "test with spaces.jpg"
  output=$(glob echo -n "test*.jpg" 2>/dev/null)
  # The -n option should be passed through
  expected_files="test with spaces.jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should pass options to commands"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg "test with spaces.jpg"

  # Test 8: Verify sorting order with diverse filenames
  (( tests++ ))
  # Create diverse files to test sorting
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  output=$(glob "*.jpg" 2>/dev/null)
  expected_files=$'aafirst.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should sort filenames correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg

  # Test 9: Sorting with multiple patterns
  (( tests++ ))
  # Create diverse files to test sorting with multiple patterns
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  output=$(glob echo "a*.jpg" "t*.jpg" "z*.jpg" 2>/dev/null)
  expected_files="aafirst.jpg test with spaces.jpg test1.jpg test2.jpg zzlast.jpg"
  assert "$output" == "$expected_files" "glob should handle multiple patterns and sort correctly"
  (( fails += $? ))
  # Clean up test files
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  
  # Test 10: Respect nullglob setting (when nullglob is set, non-matching patterns disappear)
  (( tests++ ))
  # Create test file for this test
  touch aafirst.jpg
  # Save current nullglob setting
  local old_nullglob_setting
  [[ -o nullglob ]] && old_nullglob_setting=true || old_nullglob_setting=false
  
  # Enable nullglob
  shopt -s nullglob
  
  # Test with ls command and nullglob enabled
  # When nullglob is set, non-matching patterns should be removed completely
  output=$(glob ls "nonexistent*.jpg" "a*.jpg" 2>/dev/null)
  # Should only include aafirst.jpg, not the nonexistent pattern
  expected_files="aafirst.jpg"
  assert "$output" == "$expected_files" "glob should respect nullglob setting (enabled)"
  (( fails += $? ))
  
  # Restore original nullglob setting
  $old_nullglob_setting || shopt -u nullglob
  # Clean up test file
  rm -f aafirst.jpg
  
  # Test 11: Respect dotglob setting (when dotglob is set, hidden files are included)
  (( tests++ ))
  # Create test files including a hidden file
  touch ".hidden.jpg" aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  
  # Save current dotglob setting
  local old_dotglob_setting
  [[ -o dotglob ]] && old_dotglob_setting=true || old_dotglob_setting=false
  
  # Enable dotglob
  shopt -s dotglob
  output=$(glob "*.jpg" 2>/dev/null)
  # Should include the hidden file
  expected_files=$'.hidden.jpg\naafirst.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should respect dotglob setting (enabled)"
  (( fails += $? ))
  
  # Disable dotglob
  shopt -u dotglob
  output=$(glob "*.jpg" 2>/dev/null)
  # Should NOT include the hidden file
  expected_files=$'aafirst.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should respect dotglob setting (disabled)"
  (( fails += $? ))
  
  # Restore original dotglob setting
  $old_dotglob_setting && shopt -s dotglob || shopt -u dotglob
  
  # Clean up all test files
  rm -f ".hidden.jpg" aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  
  # Test 12: Recursive globbing with ** pattern
  (( tests++ ))
  # Create a subdirectory structure and files
  mkdir -p subdir1/subdir2
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  touch subdir1/nested1.jpg subdir1/subdir2/nested2.jpg
  
  # Test recursive globbing
  output=$(glob "**/*.jpg" 2>/dev/null)
  expected_files=$'aafirst.jpg\nsubdir1/nested1.jpg\nsubdir1/subdir2/nested2.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should handle recursive ** patterns"
  (( fails += $? ))
  # Clean up test files and directories
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  rm -rf subdir1
  
  # Test 13: Recursive globbing with set -f (globbing disabled)
  (( tests++ ))
  # Create a subdirectory structure and files
  mkdir -p subdir1/subdir2
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  touch subdir1/nested1.jpg subdir1/subdir2/nested2.jpg
  # Save current noglob setting
  local old_noglob_setting
  [[ -o noglob ]] && old_noglob_setting=true || old_noglob_setting=false
  
  # Disable globbing
  set -f
  output=$(glob "**/*.jpg" 2>/dev/null)
  expected_files=$'aafirst.jpg\nsubdir1/nested1.jpg\nsubdir1/subdir2/nested2.jpg\ntest with spaces.jpg\ntest1.jpg\ntest2.jpg\nzzlast.jpg'
  assert "$output" == "$expected_files" "glob should handle recursive ** patterns with globbing disabled"
  (( fails += $? ))
  
  # Restore original noglob setting
  $old_noglob_setting || set +f
  # Clean up test files and directories
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  rm -rf subdir1
  
  # Test 14: Command with recursive pattern
  (( tests++ ))
  # Create a subdirectory structure and files
  mkdir -p subdir1/subdir2
  touch aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  touch subdir1/nested1.jpg subdir1/subdir2/nested2.jpg
  output=$(glob echo "**/*.jpg" 2>/dev/null)
  expected_files="aafirst.jpg subdir1/nested1.jpg subdir1/subdir2/nested2.jpg test with spaces.jpg test1.jpg test2.jpg zzlast.jpg"
  assert "$output" == "$expected_files" "glob should execute commands with recursive ** patterns"
  (( fails += $? ))
  # Clean up test files and directories
  rm -f aafirst.jpg "test with spaces.jpg" test1.jpg test2.jpg zzlast.jpg
  rm -rf subdir1
  
  # Test 15: Recursive pattern with nullglob
  (( tests++ ))
  # Save current nullglob setting
  local old_nullglob_setting
  [[ -o nullglob ]] && old_nullglob_setting=true || old_nullglob_setting=false
  
  # Enable nullglob
  shopt -s nullglob
  # Test with a non-matching recursive pattern and command mode
  # When nullglob is set, non-matching patterns should be removed completely
  output=$(glob ls "**/nonexistent*.jpg" 2>/dev/null)
  # Should be empty with nullglob
  expected_files=""
  assert "$output" == "$expected_files" "glob should respect nullglob with recursive patterns"
  (( fails += $? ))
  
  # Restore original nullglob setting
  $old_nullglob_setting || shopt -u nullglob
  
  # Test 16: Case-insensitive matching with --ignore-case
  (( tests++ ))
  # Create test files with mixed case (including lowercase files for case-sensitive test)
  touch "Test.JPG" "test.Jpg" "TEST.jpg" "other.png" "test with spaces.jpg" "test1.jpg" "test2.jpg"
  
  # Test without ignore-case flag (should only match exact case)
  output=$(glob "test*.jpg" 2>/dev/null)
  expected_files=$'test with spaces.jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should be case-sensitive by default"
  (( fails += $? ))
  
  # Test with --ignore-case flag (should match all case variations)
  (( tests++ ))
  output=$(glob --ignore-case "test*.jpg" 2>/dev/null)
  expected_files=$'TEST.jpg\nTest.JPG\ntest with spaces.jpg\ntest.Jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should match case-insensitively with --ignore-case"
  (( fails += $? ))
  
  # Test 18: Case-insensitive matching with -i (shorthand)
  (( tests++ ))
  output=$(glob -i "test*.jpg" 2>/dev/null)
  expected_files=$'TEST.jpg\nTest.JPG\ntest with spaces.jpg\ntest.Jpg\ntest1.jpg\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should match case-insensitively with -i shorthand"
  (( fails += $? ))
  
  # Test 19: Case-insensitive with command execution
  (( tests++ ))
  output=$(glob -i echo "test*.jpg" 2>/dev/null)
  expected_files="TEST.jpg Test.JPG test with spaces.jpg test.Jpg test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should execute commands with case-insensitive matching"
  (( fails += $? ))
  
  # Clean up case-insensitive test files
  rm -f "Test.JPG" "test.Jpg" "TEST.jpg" "other.png" "test with spaces.jpg" "test1.jpg" "test2.jpg"
  
  # Test 20: Mixed matching and non-matching patterns
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg
  output=$(glob "test1.jpg" "nonexistent*.jpg" "test2.jpg" 2>/dev/null)
  expected_files=$'test1.jpg\\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should include only matching patterns, skip non-matching ones"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg
  
  # Test 21: All patterns non-matching should return empty and exit 1
  (( tests++ ))
  glob "nonexistent1*.jpg" "nonexistent2*.png" >/dev/null 2>&1
  exit_code=$?
  assert "$exit_code" == "1" "glob should return exit code 1 when no patterns match"
  (( fails += $? ))
  
  # Test 22: Mixed patterns with command execution
  (( tests++ ))
  # Create test files for this test
  touch test1.jpg test2.jpg
  output=$(glob echo "test1.jpg" "nonexistent*.jpg" "test2.jpg" 2>/dev/null)
  expected_files="test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should pass only matching patterns to commands"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg
  
  # Test 23: Quoted brace expansion with simple patterns
  (( tests++ ))
  # Create test files for brace expansion
  touch test1.jpg test2.jpg test.png
  output=$(glob "*.{jpg,png}" 2>/dev/null)
  expected_files=$'test.png\\ntest1.jpg\\ntest2.jpg'
  assert "$output" == "$expected_files" "glob should handle quoted brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg test.png
  
  # Test 24: Quoted brace expansion with spaces in paths
  (( tests++ ))
  # Create directory and files with spaces for this test
  mkdir -p "dir with spaces"
  touch "dir with spaces/file.jpg" "dir with spaces/file.png"
  output=$(glob "dir with spaces/*.{jpg,png}" 2>/dev/null)
  expected_files=$'dir with spaces/file.jpg\ndir with spaces/file.png'
  assert "$output" == "$expected_files" "glob should handle quoted brace expansion with spaces in paths"
  (( fails += $? ))
  # Clean up test files and directory
  rm -rf "dir with spaces"
  
  # Test 25: Quoted brace expansion with command execution
  (( tests++ ))
  # Create test files for command mode brace expansion
  touch test1.jpg test2.jpg test.png
  output=$(glob echo "*.{jpg,png}" 2>/dev/null)
  expected_files="test.png test1.jpg test2.jpg"
  assert "$output" == "$expected_files" "glob should handle quoted brace expansion in command mode"
  (( fails += $? ))
  # Clean up test files
  rm -f test1.jpg test2.jpg test.png
  
  # Test 26: Complex brace expansion with multiple braces
  (( tests++ ))
  touch "a.txt" "b.txt" "c.log" "d.log"
  output=$(glob "*.{txt,log}" 2>/dev/null)
  expected_files=$'a.txt\nb.txt\nc.log\nd.log'
  assert "$output" == "$expected_files" "glob should handle multiple files with brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f "a.txt" "b.txt" "c.log" "d.log"
  
  # Test 27: Nested brace expansion (if supported by bash)
  (( tests++ ))
  touch "file1.jpg" "file2.jpg" "file1.png" "file2.png"
  output=$(glob "file{1,2}.{jpg,png}" 2>/dev/null)
  expected_files=$'file1.jpg\nfile1.png\nfile2.jpg\nfile2.png'
  assert "$output" == "$expected_files" "glob should handle nested brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f "file1.jpg" "file2.jpg" "file1.png" "file2.png"
  
  # Test 28: Case-insensitive with quoted brace expansion and wildcards
  (( tests++ ))
  touch "CaseTest.jpg" "CaseTest.png"
  output=$(glob -i "casetest*.{jpg,png}" 2>/dev/null)
  expected_files=$'CaseTest.jpg\nCaseTest.png'
  assert "$output" == "$expected_files" "glob should handle case-insensitive quoted brace expansion"
  (( fails += $? ))
  # Clean up test files
  rm -f "CaseTest.jpg" "CaseTest.png"
  
  # Test 29: Case-insensitive recursive brace expansion should not treat first result as command
  (( tests++ ))
  # Create test files in subdirectories (recursive patterns only match subdirectories)
  mkdir -p "subdir with spaces"
  touch "subdir with spaces/image.jpg" "subdir with spaces/image.png"
  output=$(glob -i "**/*.{jpg,png}" 2>/dev/null)
  expected_files=$'subdir with spaces/image.jpg\nsubdir with spaces/image.png'
  assert "$output" == "$expected_files" "glob should not treat first match as command in direct mode"
  (( fails += $? ))
  # Clean up test files
  rm -rf "subdir with spaces"
  
  # Test 30: Relative path to executable should work in command mode
  (( tests++ ))
  # Create a substantial executable script that file will recognize
  cat > my-script << 'EOF'
#!/usr/bin/env bash
# A test script for glob testing
# This needs to be substantial enough for file to recognize it as a shell script

echo "script output: $*"
EOF
  chmod +x my-script
  touch test.txt other.txt
  output=$(glob ./my-script "*.txt" 2>/dev/null)
  expected_output="script output: other.txt test.txt"
  assert "$output" == "$expected_output" "glob should treat relative path to executable as command"
  (( fails += $? ))
  # Clean up
  rm -f my-script test.txt other.txt
  
  # Test 31: Absolute path to executable should work in command mode  
  (( tests++ ))
  touch test.txt other.txt
  # Use the actual path to echo on this system
  local echo_path=$(which echo)
  output=$(glob "$echo_path" "*.txt" 2>/dev/null)
  expected_output="other.txt test.txt"
  assert "$output" == "$expected_output" "glob should treat absolute path to executable as command"
  (( fails += $? ))
  # Clean up
  rm -f test.txt other.txt
  
  # Test 32: Non-executable file should be treated as pattern (direct mode)
  (( tests++ ))
  echo "not a script" > not-executable
  touch test.txt
  output=$(glob "not-executable" "*.txt" 2>/dev/null)
  expected_files=$'not-executable\ntest.txt'
  assert "$output" == "$expected_files" "glob should treat non-executable file as pattern in direct mode"
  (( fails += $? ))
  # Clean up
  rm -f not-executable test.txt
  
  # Test 33: File path with spaces should be direct mode (not treated as command)
  (( tests++ ))
  touch "file with spaces.jpg" "other.txt"
  output=$(glob "file with spaces.jpg" "*.txt" 2>/dev/null)
  expected_files=$'file with spaces.jpg\\nother.txt'
  assert "$output" == "$expected_files" "glob should treat file paths as patterns in direct mode"
  (( fails += $? ))
  # Clean up
  rm -f "file with spaces.jpg" "other.txt"
  
  # Test 34: Executable file with path separators should be direct mode when it's clearly a filename
  (( tests++ ))
  mkdir -p subdir
  # Create a file that looks like a data file but is technically executable
  # The .jpg extension should make it clear this isn't meant to be a command
  cat > "subdir/fake-command.jpg" << 'EOF'
#!/usr/bin/env bash
# This looks like a script but has a .jpg extension
# so it should be treated as a data file, not a command
echo "should not execute"
EOF
  chmod +x "subdir/fake-command.jpg"
  touch test.txt
  output=$(glob "subdir/fake-command.jpg" "*.txt" 2>/dev/null)
  expected_files=$'subdir/fake-command.jpg\ntest.txt'
  assert "$output" == "$expected_files" "glob should treat executable files that look like data files as patterns"
  (( fails += $? ))
  # Clean up
  rm -rf subdir test.txt
  
  # Test 35: Relative pattern with spaces and slashes globs correctly (direct mode)
  (( tests++ ))
  mkdir -p "sys (twserver)/system/SAGA"
  touch "sys (twserver)/system/SAGA/A.md" "sys (twserver)/system/SAGA/B.txt" "sys (twserver)/system/SAGA/C.MD"
  output=$(glob "sys (twserver)/system/SAGA/*.md" 2>/dev/null)
  expected_files="sys (twserver)/system/SAGA/A.md"
  assert "$output" == "$expected_files" "glob should glob relative pattern with spaces and slashes (case-sensitive)"
  (( fails += $? ))
  
  # Test 36: Relative pattern with spaces and slashes with --ignore-case (direct mode)
  (( tests++ ))
  output=$(glob --ignore-case "sys (twserver)/system/SAGA/*.md" 2>/dev/null)
  expected_files=$'sys (twserver)/system/SAGA/A.md\nsys (twserver)/system/SAGA/C.MD'
  assert "$output" == "$expected_files" "glob should glob relative pattern with spaces and slashes (case-insensitive)"
  (( fails += $? ))
  
  # Cleanup for tests 35/36
  rm -rf "sys (twserver)"
  
  # Test 37: Default output format should be newline-separated without escaping
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob "*.jpg" "*.txt" 2>/dev/null)
  expected_output=$'other.txt\ntest with spaces.jpg'
  assert "$output" == "$expected_output" "glob should use newline-separated output by default without escaping spaces"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 38: -n flag should produce space-separated output with escaping (old behavior)
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob -n "*.jpg" "*.txt" 2>/dev/null)
  expected_output="other.txt test\\ with\\ spaces.jpg "
  assert "$output" == "$expected_output" "glob -n should use space-separated output with escaping"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 39: -0 flag should produce null-separated output without escaping
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob -0 "*.jpg" "*.txt" 2>/dev/null | tr '\0' '|')
  expected_output="other.txt|test with spaces.jpg|"
  assert "$output" == "$expected_output" "glob -0 should use null-separated output without escaping"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 40: Last flag wins (-0 after -n)
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"
  output=$(glob -n -0 "*.jpg" "*.txt" 2>/dev/null | tr '\0' '|')
  expected_output="other.txt|test with spaces.jpg|"
  assert "$output" == "$expected_output" "glob -n -0 should use null-separated output (last flag wins)"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"
  
  # Test 41: Last flag wins (-n after -0)
  (( tests++ ))
  touch "test with spaces.jpg" "other.txt"  
  output=$(glob -0 -n "*.jpg" "*.txt" 2>/dev/null)
  expected_output="other.txt test\\ with\\ spaces.jpg "
  assert "$output" == "$expected_output" "glob -0 -n should use space-separated output (last flag wins)"
  (( fails += $? ))
  rm -f "test with spaces.jpg" "other.txt"

  # Test 42: Recursive globbing should include directories (e.g. **/node_modules)
  (( tests++ ))
  mkdir -p project/node_modules lib/components/node_modules shared/plugins
  output=$(glob "**/node_modules" 2>/dev/null)
  expected_output=$'lib/components/node_modules\nproject/node_modules'
  assert "$output" == "$expected_output" "glob should return directories when pattern matches them"
  (( fails += $? ))
  rm -rf project lib shared

  # Test 43: --double-quote should wrap output and escape embedded quotes
  (( tests++ ))
  touch 'plain.txt' 'file "quote".txt'
  output=$(glob --double-quote "*.txt" 2>/dev/null)
  expected_output=$'"file \\\"quote\\\".txt"\n"plain.txt"'
  assert "$output" == "$expected_output" "glob --double-quote should double-quote results"
  (( fails += $? ))
  rm -f 'plain.txt' 'file "quote".txt'

  # Test 44: --double-quote should ignore -n with warning
  (( tests++ ))
  touch warn.txt
  warning=$(glob --double-quote -n "*.txt" 2>&1 >/dev/null)
  assert "$warning" == "Warning: -n is ignored when --double-quote is used" "glob should warn when -n is combined with --double-quote"
  (( fails += $? ))
  rm -f warn.txt

  # Test 45: --double-quote should ignore -0 with warning
  (( tests++ ))
  touch warn0.txt
  warning=$(glob --double-quote -0 "*.txt" 2>&1 >/dev/null)
  assert "$warning" == "Warning: -0 is ignored when --double-quote is used" "glob should warn when -0 is combined with --double-quote"
  (( fails += $? ))
  rm -f warn0.txt
  
  # Test 46: --double-quote should not be allowed in command mode
  (( tests++ ))
  glob --double-quote echo "*.txt" >/dev/null 2>&1
  exit_code=$?
  assert "$exit_code" == "2" "glob --double-quote should error in command mode"
  (( fails += $? ))

  # Leave temp dir (mktemp -d creates a temporary directory that will be cleaned up by the system)
  popd >/dev/null

  # Final summary
  if [ $fails -gt 0 ]; then
    red_text "$fails of $tests glob tests failed!\n" >&2
  else
    green_text "All $tests glob tests passed!\n" >&2
  fi
  return $fails
}

# Run the test if this script is executed directly
if ! (return 0 2>/dev/null); then
  test_glob
fi
