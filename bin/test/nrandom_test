#!/usr/bin/env bash

if [ "$NRANDOM_TEST_DEPTH" = "1" ]; then
	exit 0
fi

# Test the nrandom function for normal distribution
test_nrandom() {
	local fails=0
	local tests=0
	local sample_size=1000
	local range_start=0
	local range_end=100
	local expected_mean=50
	local expected_stddev=$(echo "scale=2; (100 - 0) / 6" | bc -l)  # range/6 as used in nrandom

	echo "Generating $sample_size samples..."

	# Test 0: About/Help/Test flags
	(( tests++ ))
	echo "Testing --about/-a flags..."

	local about_output
	about_output=$(nrandom --about 2>/dev/null)
	local about_lines
	about_lines=$(printf '%s\n' "$about_output" | wc -l | tr -d ' ')

	if [ -n "$about_output" ] && [ "$about_lines" -eq 1 ] && echo "$about_output" | grep -qi "normal"; then
		echo "✓ About flag test passed"
	else
		echo "✗ About flag test failed: output='$about_output' (lines: $about_lines)" >&2
		(( fails++ ))
	fi

	(( tests++ ))
	echo "Testing --help/-h flags..."

	local help_output
	help_output=$(nrandom -h)
	local help_status=$?

	if [ $help_status -eq 0 ] && echo "$help_output" | grep -q "Usage: nrandom"; then
		echo "✓ Help flag test passed"
	else
		echo "✗ Help flag test failed: status=$help_status" >&2
		(( fails++ ))
	fi

	(( tests++ ))
	echo "Testing --test flag..."

	local test_output
	test_output=$(NRANDOM_TEST_DEPTH=1 nrandom --test 2>&1)
	local test_status=$?

	if [ $test_status -eq 0 ] && [ -z "$test_output" ]; then
		echo "✓ --test flag test passed"
	else
		echo "✗ --test flag test failed: status=$test_status, output='$test_output'" >&2
		(( fails++ ))
	fi

	# Generate samples and calculate statistics in one pass using awk
	local stats=$(for ((i=0; i<sample_size; i++)); do
		nrandom $range_start $range_end
	done | awk -v expected_mean="$expected_mean" -v expected_stddev="$expected_stddev" '
	{
		samples[NR] = $1
		sum += $1
		if (NR == 1 || $1 < min) min = $1
		if (NR == 1 || $1 > max) max = $1
	}
	END {
		# Calculate mean
		mean = sum / NR

		# Calculate standard deviation
		for (i = 1; i <= NR; i++) {
			variance_sum += (samples[i] - mean) * (samples[i] - mean)
		}
		stddev = sqrt(variance_sum / (NR - 1))

		# Count samples within standard deviations
		within_1sd = 0
		within_2sd = 0
		within_3sd = 0
		outside_bounds = 0
		theoretical_min = expected_mean - 3 * expected_stddev
		theoretical_max = expected_mean + 3 * expected_stddev

		for (i = 1; i <= NR; i++) {
			z_score = (samples[i] - mean) / stddev
			abs_z = (z_score < 0) ? -z_score : z_score

			if (abs_z <= 1) within_1sd++
			if (abs_z <= 2) within_2sd++
			if (abs_z <= 3) within_3sd++

			if (samples[i] < theoretical_min || samples[i] > theoretical_max) {
				outside_bounds++
			}
		}

		pct_1sd = within_1sd * 100 / NR
		pct_2sd = within_2sd * 100 / NR
		pct_3sd = within_3sd * 100 / NR
		pct_outside = outside_bounds * 100 / NR

		printf "ACTUAL_MEAN=%.2f\n", mean
		printf "ACTUAL_STDDEV=%.2f\n", stddev
		printf "MIN=%.0f\n", min
		printf "MAX=%.0f\n", max
		printf "PCT_1SD=%.1f\n", pct_1sd
		printf "PCT_2SD=%.1f\n", pct_2sd
		printf "PCT_3SD=%.1f\n", pct_3sd
		printf "PCT_OUTSIDE=%.1f\n", pct_outside
	}')

	# Parse the results
	eval "$stats"

	echo "Statistical Analysis:"
	echo "  Sample size: $sample_size"
	echo "  Range: [$MIN, $MAX]"
	echo "  Expected mean: $expected_mean"
	echo "  Actual mean: $ACTUAL_MEAN"
	echo "  Expected stddev: $expected_stddev"
	echo "  Actual stddev: $ACTUAL_STDDEV"

	# Test 1: Mean should be close to expected (within 3% of range)
	(( tests++ ))
	local mean_diff=$(echo "scale=2; if ($ACTUAL_MEAN - $expected_mean < 0) $expected_mean - $ACTUAL_MEAN else $ACTUAL_MEAN - $expected_mean" | bc -l)
	if (( $(echo "$mean_diff <= 3.0" | bc -l) )); then
		echo "✓ Mean test passed (diff: $mean_diff <= 3.0)"
	else
		echo "✗ Mean test failed: difference $mean_diff > 3.0" >&2
		(( fails++ ))
	fi

	# Test 2: Standard deviation should be close to expected (within 30%)
	(( tests++ ))
	local stddev_tolerance=$(echo "scale=2; $expected_stddev * 0.30" | bc -l)
	local stddev_diff=$(echo "scale=2; if ($ACTUAL_STDDEV - $expected_stddev < 0) $expected_stddev - $ACTUAL_STDDEV else $ACTUAL_STDDEV - $expected_stddev" | bc -l)
	if (( $(echo "$stddev_diff <= $stddev_tolerance" | bc -l) )); then
		echo "✓ Standard deviation test passed (diff: $stddev_diff <= $stddev_tolerance)"
	else
		echo "✗ Standard deviation test failed: difference $stddev_diff > $stddev_tolerance" >&2
		(( fails++ ))
	fi

	# Test 3: 68-95-99.7 rule
	(( tests++ ))
	echo "  Within 1σ: $PCT_1SD% (expected ~68%)"
	echo "  Within 2σ: $PCT_2SD% (expected ~95%)"
	echo "  Within 3σ: $PCT_3SD% (expected ~99.7%)"

	local normal_distribution=true
	if (( $(echo "$PCT_1SD < 55 || $PCT_1SD > 80" | bc -l) )); then
		echo "✗ 68-95-99.7 rule failed for 1σ: $PCT_1SD% not in [55%, 80%]" >&2
		normal_distribution=false
	fi
	if (( $(echo "$PCT_2SD < 85 || $PCT_2SD > 99" | bc -l) )); then
		echo "✗ 68-95-99.7 rule failed for 2σ: $PCT_2SD% not in [85%, 99%]" >&2
		normal_distribution=false
	fi
	if (( $(echo "$PCT_3SD < 98" | bc -l) )); then
		echo "✗ 68-95-99.7 rule failed for 3σ: $PCT_3SD% < 98%" >&2
		normal_distribution=false
	fi

	if $normal_distribution; then
		echo "✓ 68-95-99.7 rule test passed"
	else
		(( fails++ ))
	fi

	# Test 4: Range bounds test
	(( tests++ ))
	echo "  Outside 3σ theoretical bounds: $PCT_OUTSIDE% (should be < 2%)"

	if (( $(echo "$PCT_OUTSIDE < 2.0" | bc -l) )); then
		echo "✓ Bounds test passed"
	else
		echo "✗ Bounds test failed: $PCT_OUTSIDE% outside bounds (should be < 2%)" >&2
		(( fails++ ))
	fi

	# Test 5: --count flag outputs multiple numbers
	(( tests++ ))
	echo "Testing --count flag..."

	local count_output
	count_output=$(nrandom --count 5 0 100 2>/dev/null)
	local count_lines
	count_lines=$(printf '%s\n' "$count_output" | wc -l | tr -d ' ')

	if [ "$count_lines" -eq 5 ]; then
		# Verify all outputs are valid integers in range
		local all_valid=true
		while IFS= read -r line; do
			if ! [[ "$line" =~ ^-?[0-9]+$ ]] || [ "$line" -lt 0 ] || [ "$line" -gt 100 ]; then
				all_valid=false
				break
			fi
		done <<< "$count_output"

		if $all_valid; then
			echo "✓ --count flag test passed (got $count_lines lines)"
		else
			echo "✗ --count flag test failed: invalid output values" >&2
			(( fails++ ))
		fi
	else
		echo "✗ --count flag test failed: expected 5 lines, got $count_lines" >&2
		(( fails++ ))
	fi

	# Test 6: --count defaults to 1 when not specified with --binaryoutput
	(( tests++ ))
	echo "Testing --count default (1 without --binaryoutput)..."

	local default_count_output
	default_count_output=$(nrandom 0 100 2>/dev/null)
	local default_count_lines
	default_count_lines=$(printf '%s\n' "$default_count_output" | wc -l | tr -d ' ')

	if [ "$default_count_lines" -eq 1 ]; then
		echo "✓ --count default test passed (got 1 line)"
	else
		echo "✗ --count default test failed: expected 1 line, got $default_count_lines" >&2
		(( fails++ ))
	fi

	# Test 7: --binaryoutput produces binary data (0-255 bytes)
	(( tests++ ))
	echo "Testing --binaryoutput flag..."

	local binary_output
	binary_output=$(nrandom --binaryoutput --count 100 2>/dev/null | xxd -p | tr -d '\n')
	local byte_count
	byte_count=$((${#binary_output} / 2))

	if [ "$byte_count" -eq 100 ]; then
		echo "✓ --binaryoutput flag test passed (got $byte_count bytes)"
	else
		echo "✗ --binaryoutput flag test failed: expected 100 bytes, got $byte_count" >&2
		(( fails++ ))
	fi

	# Test 8: --binaryoutput defaults to 1024 bytes
	(( tests++ ))
	echo "Testing --binaryoutput default count (1024)..."

	local binary_default_output
	binary_default_output=$(nrandom --binaryoutput 2>/dev/null | xxd -p | tr -d '\n')
	local default_byte_count
	default_byte_count=$((${#binary_default_output} / 2))

	if [ "$default_byte_count" -eq 1024 ]; then
		echo "✓ --binaryoutput default count test passed (got $default_byte_count bytes)"
	else
		echo "✗ --binaryoutput default count test failed: expected 1024 bytes, got $default_byte_count" >&2
		(( fails++ ))
	fi

	# Test 9: --binaryoutput produces values that cover the full 0-255 range over many samples
	(( tests++ ))
	echo "Testing --binaryoutput byte range coverage..."

	local range_test_output
	range_test_output=$(nrandom --binaryoutput --count 5000 2>/dev/null | xxd -p | tr -d '\n')

	# Extract unique byte values
	local unique_bytes
	unique_bytes=$(echo "$range_test_output" | fold -w2 | sort -u | wc -l | tr -d ' ')

	# With normal distribution centered at 127.5, we should see good coverage
	# Allow for some spread - we expect at least 100 unique values with 5000 samples
	if [ "$unique_bytes" -ge 100 ]; then
		echo "✓ --binaryoutput range coverage test passed ($unique_bytes unique byte values)"
	else
		echo "✗ --binaryoutput range coverage test failed: only $unique_bytes unique values (expected >= 100)" >&2
		(( fails++ ))
	fi

	# Test 10: --count with short form -c
	(( tests++ ))
	echo "Testing -c short form for --count..."

	local short_count_output
	short_count_output=$(nrandom -c 3 0 50 2>/dev/null)
	local short_count_lines
	short_count_lines=$(printf '%s\n' "$short_count_output" | wc -l | tr -d ' ')

	if [ "$short_count_lines" -eq 3 ]; then
		echo "✓ -c short form test passed (got $short_count_lines lines)"
	else
		echo "✗ -c short form test failed: expected 3 lines, got $short_count_lines" >&2
		(( fails++ ))
	fi

	# Test 11: --binaryoutput with short form -b
	(( tests++ ))
	echo "Testing -b short form for --binaryoutput..."

	local short_binary_output
	short_binary_output=$(nrandom -b -c 50 2>/dev/null | xxd -p | tr -d '\n')
	local short_binary_bytes
	short_binary_bytes=$((${#short_binary_output} / 2))

	if [ "$short_binary_bytes" -eq 50 ]; then
		echo "✓ -b short form test passed (got $short_binary_bytes bytes)"
	else
		echo "✗ -b short form test failed: expected 50 bytes, got $short_binary_bytes" >&2
		(( fails++ ))
	fi

	# Test 12: --binaryoutput with custom range (lower entropy)
	(( tests++ ))
	echo "Testing --binaryoutput with custom range 64-192..."

	local custom_range_output
	custom_range_output=$(nrandom -b -c 500 64 192 2>/dev/null | xxd -p | tr -d '\n')
	local custom_bytes
	custom_bytes=$((${#custom_range_output} / 2))

	if [ "$custom_bytes" -eq 500 ]; then
		# Check all bytes are in range 64-192 (0x40-0xc0)
		local all_in_range=true
		for hex in $(echo "$custom_range_output" | fold -w2); do
			local decimal=$((16#$hex))
			if [ "$decimal" -lt 64 ] || [ "$decimal" -gt 192 ]; then
				all_in_range=false
				echo "  Found out-of-range byte: $decimal (0x$hex)" >&2
				break
			fi
		done

		if $all_in_range; then
			echo "✓ --binaryoutput custom range test passed"
		else
			echo "✗ --binaryoutput custom range test failed: bytes outside 64-192 range" >&2
			(( fails++ ))
		fi
	else
		echo "✗ --binaryoutput custom range test failed: expected 500 bytes, got $custom_bytes" >&2
		(( fails++ ))
	fi

	# Test 13: --binaryoutput with start < 0 should error
	(( tests++ ))
	echo "Testing --binaryoutput rejects start < 0..."

	local negative_start_output
	negative_start_output=$(nrandom -b -c 10 -1 100 2>&1)
	local negative_start_status=$?

	if [ $negative_start_status -ne 0 ] && echo "$negative_start_output" | grep -qi "error"; then
		echo "✓ --binaryoutput start < 0 rejection test passed"
	else
		echo "✗ --binaryoutput start < 0 rejection test failed: expected error, got status=$negative_start_status" >&2
		(( fails++ ))
	fi

	# Test 14: --binaryoutput with end > 255 should error
	(( tests++ ))
	echo "Testing --binaryoutput rejects end > 255..."

	local over255_output
	over255_output=$(nrandom -b -c 10 0 256 2>&1)
	local over255_status=$?

	if [ $over255_status -ne 0 ] && echo "$over255_output" | grep -qi "error"; then
		echo "✓ --binaryoutput end > 255 rejection test passed"
	else
		echo "✗ --binaryoutput end > 255 rejection test failed: expected error, got status=$over255_status" >&2
		(( fails++ ))
	fi

	# Test 15: start >= end should error (normal mode)
	(( tests++ ))
	echo "Testing start >= end rejection (normal mode)..."

	local start_ge_end_output
	start_ge_end_output=$(nrandom 50 50 2>&1)
	local start_ge_end_status=$?

	if [ $start_ge_end_status -ne 0 ] && echo "$start_ge_end_output" | grep -qi "error"; then
		echo "✓ start >= end rejection test passed (normal mode)"
	else
		echo "✗ start >= end rejection test failed: expected error, got status=$start_ge_end_status" >&2
		(( fails++ ))
	fi

	# Test 16: start > end should error (binary mode)
	(( tests++ ))
	echo "Testing start > end rejection (binary mode)..."

	local binary_start_gt_end_output
	binary_start_gt_end_output=$(nrandom -b 100 50 2>&1)
	local binary_start_gt_end_status=$?

	if [ $binary_start_gt_end_status -ne 0 ] && echo "$binary_start_gt_end_output" | grep -qi "error"; then
		echo "✓ start > end rejection test passed (binary mode)"
	else
		echo "✗ start > end rejection test failed: expected error, got status=$binary_start_gt_end_status" >&2
		(( fails++ ))
	fi

	if [ $fails -gt 0 ]; then
		echo "" >&2
		echo "nrandom statistical test FAILED: $fails of $tests tests failed" >&2
		echo "The nrandom function does not appear to generate a proper normal distribution." >&2
		return $fails
	else
		echo ""
		echo "nrandom statistical test PASSED: All $tests tests passed"
		return 0
	fi
}

# Run the test if this script is executed directly
if ! (return 0 2>/dev/null); then
	test_nrandom
	exit $?
fi
