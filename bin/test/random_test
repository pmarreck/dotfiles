#!/usr/bin/env bash

if [ "$RANDOM_TEST_DEPTH" = "1" ]; then
	exit 0
fi

# Test the random function
test_random() {
	local fails=0
	local tests=0

	echo "Testing uniform random number generator..."

	# Test 0: About flag should return a single-line summary
	(( tests++ ))
	echo "Testing --about/-a flags..."

	local about_output
	about_output=$(random --about 2>/dev/null)

	local about_lines
	about_lines=$(printf '%s\n' "$about_output" | wc -l | tr -d ' ')

	if [ -n "$about_output" ] && [ "$about_lines" -eq 1 ] && echo "$about_output" | grep -qi "uniform random"; then
		echo "✓ About flag test passed: single-line summary present"
	else
		echo "✗ About flag test failed: output='$about_output' (lines: $about_lines)" >&2
		(( fails++ ))
	fi

	# Test 0b: Help flags should show usage and exit 0
	(( tests++ ))
	echo "Testing --help/-h flags..."

	local help_output
	help_output=$(random -h)
	local help_status=$?

	if [ $help_status -eq 0 ] && echo "$help_output" | grep -q "Usage: random"; then
		echo "✓ Help flag test passed"
	else
		echo "✗ Help flag test failed: status=$help_status" >&2
		(( fails++ ))
	fi

	# Test 0c: --test should run silently and exit 0 when passing
	(( tests++ ))
	echo "Testing --test flag..."

	local test_output
	test_output=$(RANDOM_TEST_DEPTH=1 random --test 2>&1)
	local test_status=$?

	if [ $test_status -eq 0 ] && [ -z "$test_output" ]; then
		echo "✓ --test flag test passed: silent success"
	else
		echo "✗ --test flag test failed: status=$test_status, output='$test_output'" >&2
		(( fails++ ))
	fi

	# Test 1: Basic execution (runs without error)
	(( tests++ ))
	echo "Testing basic execution..."

	local random_output
	random_output=$(random 2>&1)
	local exit_code=$?

	if [ "$exit_code" -eq 0 ] && [ -n "$random_output" ]; then
		echo "✓ Basic execution test passed: runs without error and produces output"
	else
		echo "✗ Basic execution test failed:" >&2
		echo "  Exit code: $exit_code (expected 0)" >&2
		echo "  Output: '$random_output'" >&2
		(( fails++ ))
	fi

	# Test 2: Default range (0-100)
	(( tests++ ))
	echo "Testing default range (0-99)..."

	local num=$(random 2>/dev/null)

	if [ "$num" -ge 0 ] && [ "$num" -le 99 ]; then
		echo "✓ Default range test passed: $num is in range [0, 99]"
	else
		echo "✗ Default range test failed: $num is not in range [0, 99]" >&2
		(( fails++ ))
	fi

	# Test 3: Custom range (10-20)
	(( tests++ ))
	echo "Testing custom range (10-20)..."

	local custom_num=$(random 10 20 2>/dev/null)

	if [ "$custom_num" -ge 10 ] && [ "$custom_num" -le 20 ]; then
		echo "✓ Custom range test passed: $custom_num is in range [10, 20]"
	else
		echo "✗ Custom range test failed: $custom_num is not in range [10, 20]" >&2
		(( fails++ ))
	fi

	# Test 4: Single value range (should always return the same value)
	(( tests++ ))
	echo "Testing single value range (5-5)..."

	local single_val=$(random 5 5 2>/dev/null)

	if [ "$single_val" -eq 5 ]; then
		echo "✓ Single value range test passed: got $single_val"
	else
		echo "✗ Single value range test failed: got $single_val, expected 5" >&2
		(( fails++ ))
	fi

	# Test 5: Statistical uniformity test (range 1-10, 1000 samples)
	(( tests++ ))
	echo "Testing statistical uniformity (1000 samples, range 1-10)..."

	local samples=1000
	local range_start=1
	local range_end=10
	local expected_per_bucket=$((samples / (range_end - range_start + 1)))
	local tolerance=$((expected_per_bucket / 2))  # Allow 50% deviation

	# Count occurrences of each value
	declare -A counts
	for ((i=range_start; i<=range_end; i++)); do
		counts[$i]=0
	done

	# Generate samples
	for ((i=0; i<samples; i++)); do
		local val=$(random $range_start $range_end 2>/dev/null)
		if [ "$val" -ge $range_start ] && [ "$val" -le $range_end ]; then
			(( counts[$val]++ ))
		fi
	done

	# Check uniformity
	local uniformity_fails=0
	for ((i=range_start; i<=range_end; i++)); do
		local count=${counts[$i]}
		local deviation=$((count - expected_per_bucket))
		local abs_deviation=${deviation#-}  # absolute value

		if [ "$abs_deviation" -gt "$tolerance" ]; then
			(( uniformity_fails++ ))
		fi
	done

	if [ "$uniformity_fails" -le 2 ]; then  # Allow up to 2 buckets to be outside tolerance
		echo "✓ Statistical uniformity test passed: $uniformity_fails/10 buckets outside tolerance"
		echo "    Expected ~$expected_per_bucket per bucket, tolerance ±$tolerance"
	else
		echo "✗ Statistical uniformity test failed: $uniformity_fails/10 buckets outside tolerance" >&2
		echo "    Expected ~$expected_per_bucket per bucket, tolerance ±$tolerance" >&2
		echo "    Counts:" >&2
		for ((i=range_start; i<=range_end; i++)); do
			echo "      Value $i: ${counts[$i]} occurrences" >&2
		done
		(( fails++ ))
	fi

	# Test 6: Chi-square goodness of fit test (simple version)
	(( tests++ ))
	echo "Testing chi-square goodness of fit..."

	local chi_square=0
	for ((i=range_start; i<=range_end; i++)); do
		local observed=${counts[$i]}
		local expected=$expected_per_bucket
		local diff=$((observed - expected))
		local squared_diff=$((diff * diff))
		local contribution=$((squared_diff / expected))
		chi_square=$((chi_square + contribution))
	done

	# For 9 degrees of freedom (10 buckets - 1), critical value at p=0.05 is ~16.9
	# We'll use a more lenient threshold of 20 to account for variability
	if [ "$chi_square" -lt 20 ]; then
		echo "✓ Chi-square test passed: χ² = $chi_square (threshold: 20)"
	else
		echo "✗ Chi-square test failed: χ² = $chi_square (threshold: 20)" >&2
		echo "    This suggests non-uniform distribution" >&2
		(( fails++ ))
	fi

	# Test 7: Randomness between invocations (10 consecutive calls should have variety)
	(( tests++ ))
	echo "Testing randomness between invocations..."

	local consecutive_samples=()
	local unique_count=0

	for ((i=0; i<10; i++)); do
		consecutive_samples[i]=$(random 1 100 2>/dev/null)
	done

	# Count unique values
	printf '%s\n' "${consecutive_samples[@]}" | sort -u > /tmp/unique_random_samples.txt
	unique_count=$(cat /tmp/unique_random_samples.txt | wc -l)
	rm -f /tmp/unique_random_samples.txt

	# Expect at least 7 unique values out of 10 (lenient check)
	if [ "$unique_count" -ge 7 ]; then
		echo "✓ Consecutive randomness test passed: $unique_count/10 unique values"
	else
		echo "✗ Consecutive randomness test failed: only $unique_count/10 unique values" >&2
		echo "    Values:" >&2
		for ((i=0; i<10; i++)); do
			echo "      Call $((i+1)): ${consecutive_samples[i]}" >&2
		done
		(( fails++ ))
	fi

	# Test 8: --count flag outputs multiple numbers
	(( tests++ ))
	echo "Testing --count flag..."

	local count_output
	count_output=$(random --count 5 0 100 2>/dev/null)
	local count_lines
	count_lines=$(printf '%s\n' "$count_output" | wc -l | tr -d ' ')

	if [ "$count_lines" -eq 5 ]; then
		# Verify all outputs are valid integers in range
		local all_valid=true
		while IFS= read -r line; do
			if ! [[ "$line" =~ ^-?[0-9]+$ ]] || [ "$line" -lt 0 ] || [ "$line" -gt 100 ]; then
				all_valid=false
				break
			fi
		done <<< "$count_output"

		if $all_valid; then
			echo "✓ --count flag test passed (got $count_lines lines)"
		else
			echo "✗ --count flag test failed: invalid output values" >&2
			(( fails++ ))
		fi
	else
		echo "✗ --count flag test failed: expected 5 lines, got $count_lines" >&2
		(( fails++ ))
	fi

	# Test 9: --binaryoutput produces binary data (0-255 bytes)
	(( tests++ ))
	echo "Testing --binaryoutput flag..."

	local binary_output
	binary_output=$(random --binaryoutput --count 100 2>/dev/null | xxd -p | tr -d '\n')
	local byte_count
	byte_count=$((${#binary_output} / 2))

	if [ "$byte_count" -eq 100 ]; then
		echo "✓ --binaryoutput flag test passed (got $byte_count bytes)"
	else
		echo "✗ --binaryoutput flag test failed: expected 100 bytes, got $byte_count" >&2
		(( fails++ ))
	fi

	# Test 10: --binaryoutput defaults to 1024 bytes
	(( tests++ ))
	echo "Testing --binaryoutput default count (1024)..."

	local binary_default_output
	binary_default_output=$(random --binaryoutput 2>/dev/null | xxd -p | tr -d '\n')
	local default_byte_count
	default_byte_count=$((${#binary_default_output} / 2))

	if [ "$default_byte_count" -eq 1024 ]; then
		echo "✓ --binaryoutput default count test passed (got $default_byte_count bytes)"
	else
		echo "✗ --binaryoutput default count test failed: expected 1024 bytes, got $default_byte_count" >&2
		(( fails++ ))
	fi

	# Test 11: --binaryoutput with custom range
	(( tests++ ))
	echo "Testing --binaryoutput with custom range 64-192..."

	local custom_range_output
	custom_range_output=$(random -b -c 500 64 192 2>/dev/null | xxd -p | tr -d '\n')
	local custom_bytes
	custom_bytes=$((${#custom_range_output} / 2))

	if [ "$custom_bytes" -eq 500 ]; then
		# Check all bytes are in range 64-192
		local all_in_range=true
		for hex in $(echo "$custom_range_output" | fold -w2); do
			local decimal=$((16#$hex))
			if [ "$decimal" -lt 64 ] || [ "$decimal" -gt 192 ]; then
				all_in_range=false
				break
			fi
		done

		if $all_in_range; then
			echo "✓ --binaryoutput custom range test passed"
		else
			echo "✗ --binaryoutput custom range test failed: bytes outside 64-192 range" >&2
			(( fails++ ))
		fi
	else
		echo "✗ --binaryoutput custom range test failed: expected 500 bytes, got $custom_bytes" >&2
		(( fails++ ))
	fi

	# Test 12: --binaryoutput with start < 0 should error
	(( tests++ ))
	echo "Testing --binaryoutput rejects start < 0..."

	local negative_start_output
	negative_start_output=$(random -b -c 10 -1 100 2>&1)
	local negative_start_status=$?

	if [ $negative_start_status -ne 0 ] && echo "$negative_start_output" | grep -qi "error"; then
		echo "✓ --binaryoutput start < 0 rejection test passed"
	else
		echo "✗ --binaryoutput start < 0 rejection test failed: expected error, got status=$negative_start_status" >&2
		(( fails++ ))
	fi

	# Test 13: --binaryoutput with end > 255 should error
	(( tests++ ))
	echo "Testing --binaryoutput rejects end > 255..."

	local over255_output
	over255_output=$(random -b -c 10 0 256 2>&1)
	local over255_status=$?

	if [ $over255_status -ne 0 ] && echo "$over255_output" | grep -qi "error"; then
		echo "✓ --binaryoutput end > 255 rejection test passed"
	else
		echo "✗ --binaryoutput end > 255 rejection test failed: expected error, got status=$over255_status" >&2
		(( fails++ ))
	fi

	# Test 14: start > end should error
	(( tests++ ))
	echo "Testing start > end rejection..."

	local start_gt_end_output
	start_gt_end_output=$(random 50 40 2>&1)
	local start_gt_end_status=$?

	if [ $start_gt_end_status -ne 0 ] && echo "$start_gt_end_output" | grep -qi "error"; then
		echo "✓ start > end rejection test passed"
	else
		echo "✗ start > end rejection test failed: expected error, got status=$start_gt_end_status" >&2
		(( fails++ ))
	fi

	# Test 15: -c and -b short forms work
	(( tests++ ))
	echo "Testing -c and -b short forms..."

	local short_form_output
	short_form_output=$(random -b -c 50 2>/dev/null | xxd -p | tr -d '\n')
	local short_form_bytes
	short_form_bytes=$((${#short_form_output} / 2))

	if [ "$short_form_bytes" -eq 50 ]; then
		echo "✓ -c and -b short form test passed"
	else
		echo "✗ -c and -b short form test failed: expected 50 bytes, got $short_form_bytes" >&2
		(( fails++ ))
	fi

	# Final results
	if [ $fails -gt 0 ]; then
		echo ""
		echo "random test FAILED: $fails of $tests tests failed" >&2
		return $fails
	else
		echo ""
		echo "random test PASSED: All $tests tests passed"
		return 0
	fi
}

# Run the test if this script is executed directly
if ! (return 0 2>/dev/null); then
	test_random
	exit $?
fi
