#!/usr/bin/env bash

if [ "$RANDOM_TEST_DEPTH" = "1" ]; then
	exit 0
fi

# Sample sizes (FAST mode reduces iterations for quick --test runs)
SAMPLE_SIZE=${RANDOM_TEST_SAMPLE_SIZE:-1000}
BINARY_SAMPLE_SIZE=${RANDOM_TEST_BINARY_SIZE:-1000}
if [ -n "$FAST" ]; then
	SAMPLE_SIZE=100
	BINARY_SAMPLE_SIZE=100
fi

# Test the unified random function
test_random() {
	local fails=0
	local tests=0
	local state_home
	state_home=$(mktemp -d --tmpdir random-test.XXXXXX)
	if [ ! -d "$state_home" ]; then
		echo "✗ Failed to create temp state dir for tests" >&2
		return 1
	fi
	trap 'rm -rf "$state_home"' EXIT

	echo "Testing unified random number generator..."
	echo "============================================"

	# ===== SECTION 1: Basic functionality (uniform mode) =====
	echo ""
	echo "--- Section 1: Basic uniform random ---"

	# Test 1: About flag
	(( tests++ ))
	echo "Testing --about/-a flags..."

	local about_output
	about_output=$(random --about 2>/dev/null)
	local about_lines
	about_lines=$(printf '%s\n' "$about_output" | wc -l | tr -d ' ')

	if [ -n "$about_output" ] && [ "$about_lines" -eq 1 ]; then
		echo "✓ About flag test passed"
	else
		echo "✗ About flag test failed: output='$about_output' (lines: $about_lines)" >&2
		(( fails++ ))
	fi

	# Test 2: Help flag
	(( tests++ ))
	echo "Testing --help/-h flags..."

	local help_output
	help_output=$(random -h)
	local help_status=$?

	if [ $help_status -eq 0 ] && echo "$help_output" | grep -q "Usage: random"; then
		echo "✓ Help flag test passed"
	else
		echo "✗ Help flag test failed: status=$help_status" >&2
		(( fails++ ))
	fi

	# Test 3: --test flag
	(( tests++ ))
	echo "Testing --test flag..."

	local test_output
	test_output=$(RANDOM_TEST_DEPTH=1 random --test 2>&1)
	local test_status=$?

	if [ $test_status -eq 0 ] && [ -z "$test_output" ]; then
		echo "✓ --test flag test passed"
	else
		echo "✗ --test flag test failed: status=$test_status, output='$test_output'" >&2
		(( fails++ ))
	fi

	# Test 4: Basic execution
	(( tests++ ))
	echo "Testing basic execution..."

	local random_output
	random_output=$(random 2>&1)
	local exit_code=$?

	if [ "$exit_code" -eq 0 ] && [ -n "$random_output" ]; then
		echo "✓ Basic execution test passed"
	else
		echo "✗ Basic execution test failed: exit=$exit_code" >&2
		(( fails++ ))
	fi

	# Test 5: Default range (0-99)
	(( tests++ ))
	echo "Testing default range (0-99)..."

	local num=$(random 2>/dev/null)

	if [ "$num" -ge 0 ] && [ "$num" -le 99 ]; then
		echo "✓ Default range test passed: $num in [0, 99]"
	else
		echo "✗ Default range test failed: $num not in [0, 99]" >&2
		(( fails++ ))
	fi

	# Test 6: Custom range
	(( tests++ ))
	echo "Testing custom range (10-20)..."

	local custom_num=$(random 10 20 2>/dev/null)

	if [ "$custom_num" -ge 10 ] && [ "$custom_num" -le 20 ]; then
		echo "✓ Custom range test passed: $custom_num in [10, 20]"
	else
		echo "✗ Custom range test failed: $custom_num not in [10, 20]" >&2
		(( fails++ ))
	fi

	# Test 7: Single value range
	(( tests++ ))
	echo "Testing single value range (5-5)..."

	local single_val=$(random 5 5 2>/dev/null)

	if [ "$single_val" -eq 5 ]; then
		echo "✓ Single value range test passed"
	else
		echo "✗ Single value range test failed: got $single_val, expected 5" >&2
		(( fails++ ))
	fi

	# Test 8: start > end should error
	(( tests++ ))
	echo "Testing start > end rejection..."

	local start_gt_end_output
	start_gt_end_output=$(random 50 40 2>&1)
	local start_gt_end_status=$?

	if [ $start_gt_end_status -ne 0 ] && echo "$start_gt_end_output" | grep -qi "error"; then
		echo "✓ start > end rejection test passed"
	else
		echo "✗ start > end rejection test failed" >&2
		(( fails++ ))
	fi

	# ===== SECTION 2: --count and --binaryoutput =====
	echo ""
	echo "--- Section 2: --count and --binaryoutput ---"

	# Test 9: --count flag
	(( tests++ ))
	echo "Testing --count flag..."

	local count_output
	count_output=$(random --count 5 0 100 2>/dev/null)
	local count_lines
	count_lines=$(printf '%s\n' "$count_output" | wc -l | tr -d ' ')

	if [ "$count_lines" -eq 5 ]; then
		echo "✓ --count flag test passed (got $count_lines lines)"
	else
		echo "✗ --count flag test failed: expected 5 lines, got $count_lines" >&2
		(( fails++ ))
	fi

	# Test 10: --binaryoutput
	(( tests++ ))
	echo "Testing --binaryoutput flag..."

	local binary_output
	binary_output=$(random --binaryoutput --count 100 2>/dev/null | xxd -p | tr -d '\n')
	local byte_count
	byte_count=$((${#binary_output} / 2))

	if [ "$byte_count" -eq 100 ]; then
		echo "✓ --binaryoutput flag test passed (got $byte_count bytes)"
	else
		echo "✗ --binaryoutput flag test failed: expected 100 bytes, got $byte_count" >&2
		(( fails++ ))
	fi

	# Test 11: --binaryoutput default count (1024)
	(( tests++ ))
	echo "Testing --binaryoutput default count (1024)..."

	local binary_default_output
	binary_default_output=$(random --binaryoutput 2>/dev/null | xxd -p | tr -d '\n')
	local default_byte_count
	default_byte_count=$((${#binary_default_output} / 2))

	if [ "$default_byte_count" -eq 1024 ]; then
		echo "✓ --binaryoutput default count test passed"
	else
		echo "✗ --binaryoutput default count test failed: expected 1024, got $default_byte_count" >&2
		(( fails++ ))
	fi

	# Test 12: --binaryoutput with custom range
	(( tests++ ))
	echo "Testing --binaryoutput with custom range 64-192..."

	local custom_range_output
	custom_range_output=$(random -b -c 200 64 192 2>/dev/null | xxd -p | tr -d '\n')
	local custom_bytes
	custom_bytes=$((${#custom_range_output} / 2))

	if [ "$custom_bytes" -eq 200 ]; then
		local all_in_range=true
		for hex in $(echo "$custom_range_output" | fold -w2 | head -50); do
			local decimal=$((16#$hex))
			if [ "$decimal" -lt 64 ] || [ "$decimal" -gt 192 ]; then
				all_in_range=false
				break
			fi
		done

		if $all_in_range; then
			echo "✓ --binaryoutput custom range test passed"
		else
			echo "✗ --binaryoutput custom range test failed: bytes outside range" >&2
			(( fails++ ))
		fi
	else
		echo "✗ --binaryoutput custom range test failed: expected 200 bytes, got $custom_bytes" >&2
		(( fails++ ))
	fi

	# Test 13: --binaryoutput rejects start < 0
	(( tests++ ))
	echo "Testing --binaryoutput rejects start < 0..."

	local neg_output
	neg_output=$(random -b -c 10 -1 100 2>&1)
	local neg_status=$?

	if [ $neg_status -ne 0 ] && echo "$neg_output" | grep -qi "error"; then
		echo "✓ --binaryoutput start < 0 rejection test passed"
	else
		echo "✗ --binaryoutput start < 0 rejection test failed" >&2
		(( fails++ ))
	fi

	# Test 14: --binaryoutput rejects end > 255
	(( tests++ ))
	echo "Testing --binaryoutput rejects end > 255..."

	local over_output
	over_output=$(random -b -c 10 0 256 2>&1)
	local over_status=$?

	if [ $over_status -ne 0 ] && echo "$over_output" | grep -qi "error"; then
		echo "✓ --binaryoutput end > 255 rejection test passed"
	else
		echo "✗ --binaryoutput end > 255 rejection test failed" >&2
		(( fails++ ))
	fi

	# ===== SECTION 3: --deterministic mode =====
	echo ""
	echo "--- Section 3: --deterministic mode ---"

	# Test 15: --deterministic with --seed produces deterministic output
	(( tests++ ))
	echo "Testing --deterministic --seed determinism..."

	local det_seq1=$(random --deterministic --seed 12345 --count 5 2>/dev/null | tr '\n' ' ')
	local det_seq2=$(random --deterministic --seed 12345 --count 5 2>/dev/null | tr '\n' ' ')

	if [ "$det_seq1" = "$det_seq2" ] && [ -n "$det_seq1" ]; then
		echo "✓ Deterministic seed test passed"
	else
		echo "✗ Deterministic seed test failed: sequences differ" >&2
		echo "  Seq1: $det_seq1" >&2
		echo "  Seq2: $det_seq2" >&2
		(( fails++ ))
	fi

	# Test 16: Different seeds produce different sequences
	(( tests++ ))
	echo "Testing different seeds produce different sequences..."

	local seq_a=$(random -d --seed 11111 --count 5 2>/dev/null | tr '\n' ' ')
	local seq_b=$(random -d --seed 22222 --count 5 2>/dev/null | tr '\n' ' ')

	if [ "$seq_a" != "$seq_b" ]; then
		echo "✓ Different seeds test passed"
	else
		echo "✗ Different seeds test failed: sequences identical" >&2
		(( fails++ ))
	fi

	# Test 17: --deterministic without --seed outputs seed to stderr
	(( tests++ ))
	echo "Testing --deterministic auto-seed output..."

	local auto_seed_stderr
	auto_seed_stderr=$(random -d -c 1 2>&1 >/dev/null)

	if echo "$auto_seed_stderr" | grep -qiE "(seed|0x)"; then
		echo "✓ Auto-seed output test passed"
	else
		echo "✗ Auto-seed output test failed: no seed in stderr" >&2
		echo "  stderr: $auto_seed_stderr" >&2
		(( fails++ ))
	fi

	# Test 18: --seed implies --deterministic
	(( tests++ ))
	echo "Testing --seed implies --deterministic..."

	local seed_only_seq1=$(random --seed 99999 --count 3 2>/dev/null | tr '\n' ' ')
	local seed_only_seq2=$(random --seed 99999 --count 3 2>/dev/null | tr '\n' ' ')

	if [ "$seed_only_seq1" = "$seed_only_seq2" ] && [ -n "$seed_only_seq1" ]; then
		echo "✓ --seed implies --deterministic test passed"
	else
		echo "✗ --seed implies --deterministic test failed" >&2
		(( fails++ ))
	fi

	# Test 19: Hex seed support
	(( tests++ ))
	echo "Testing hex seed support..."

	local hex_seq1=$(random -d --seed 0xDEADBEEF --count 3 2>/dev/null | tr '\n' ' ')
	local hex_seq2=$(random -d --seed 0xDEADBEEF --count 3 2>/dev/null | tr '\n' ' ')

	if [ "$hex_seq1" = "$hex_seq2" ] && [ -n "$hex_seq1" ]; then
		echo "✓ Hex seed test passed"
	else
		echo "✗ Hex seed test failed" >&2
		(( fails++ ))
	fi

	# Test 20: PCG32 known output (ensures algorithm consistency)
	(( tests++ ))
	echo "Testing PCG32 known output..."

	local pcg_output
	pcg_output=$(random -d --seed 42 0 99 2>/dev/null)

	if [ "$pcg_output" = "26" ]; then
		echo "✓ PCG32 known output test passed"
	else
		echo "✗ PCG32 known output test failed: expected 26, got $pcg_output" >&2
		(( fails++ ))
	fi

	# ===== SECTION 4: --normalized mode =====
	echo ""
	echo "--- Section 4: --normalized mode ---"

	# Test 21: --normalized produces values in range
	(( tests++ ))
	echo "Testing --normalized produces values in range..."

	local norm_vals=$(random --normalized --count 20 0 100 2>/dev/null)
	local all_in_range=true
	while IFS= read -r val; do
		if [ "$val" -lt 0 ] || [ "$val" -gt 100 ]; then
			all_in_range=false
			break
		fi
	done <<< "$norm_vals"

	if $all_in_range; then
		echo "✓ Normalized range test passed"
	else
		echo "✗ Normalized range test failed: values outside range" >&2
		(( fails++ ))
	fi

	# Test 22: --normalized 68-95-99.7 rule statistical test
	(( tests++ ))
	echo "Testing --normalized 68-95-99.7 rule..."

	local range_start=0
	local range_end=100
	local expected_mean=50
	local expected_stddev=$(echo "scale=2; (100 - 0) / 6" | bc -l)

	local stats=$(random -n --count $SAMPLE_SIZE $range_start $range_end 2>/dev/null | awk -v expected_mean="$expected_mean" -v expected_stddev="$expected_stddev" '
	{
		samples[NR] = $1
		sum += $1
		if (NR == 1 || $1 < min) min = $1
		if (NR == 1 || $1 > max) max = $1
	}
	END {
		mean = sum / NR
		for (i = 1; i <= NR; i++) {
			variance_sum += (samples[i] - mean) * (samples[i] - mean)
		}
		stddev = sqrt(variance_sum / (NR - 1))

		within_1sd = 0
		within_2sd = 0
		within_3sd = 0

		for (i = 1; i <= NR; i++) {
			z_score = (samples[i] - mean) / stddev
			abs_z = (z_score < 0) ? -z_score : z_score
			if (abs_z <= 1) within_1sd++
			if (abs_z <= 2) within_2sd++
			if (abs_z <= 3) within_3sd++
		}

		pct_1sd = within_1sd * 100 / NR
		pct_2sd = within_2sd * 100 / NR
		pct_3sd = within_3sd * 100 / NR

		printf "ACTUAL_MEAN=%.2f\n", mean
		printf "ACTUAL_STDDEV=%.2f\n", stddev
		printf "PCT_1SD=%.1f\n", pct_1sd
		printf "PCT_2SD=%.1f\n", pct_2sd
		printf "PCT_3SD=%.1f\n", pct_3sd
	}')

	eval "$stats"

	echo "  Within 1σ: $PCT_1SD% (expected ~68%)"
	echo "  Within 2σ: $PCT_2SD% (expected ~95%)"
	echo "  Within 3σ: $PCT_3SD% (expected ~99.7%)"

	local normal_pass=true
	if (( $(echo "$PCT_1SD < 55 || $PCT_1SD > 80" | bc -l) )); then
		echo "  ✗ 1σ out of range [55%, 80%]" >&2
		normal_pass=false
	fi
	if (( $(echo "$PCT_2SD < 85 || $PCT_2SD > 99" | bc -l) )); then
		echo "  ✗ 2σ out of range [85%, 99%]" >&2
		normal_pass=false
	fi
	if (( $(echo "$PCT_3SD < 98" | bc -l) )); then
		echo "  ✗ 3σ < 98%" >&2
		normal_pass=false
	fi

	if $normal_pass; then
		echo "✓ 68-95-99.7 rule test passed"
	else
		(( fails++ ))
	fi

	# ===== SECTION 5: --deterministic --normalized combined =====
	echo ""
	echo "--- Section 5: --deterministic --normalized ---"

	# Test 22: Combined mode is reproducible
	(( tests++ ))
	echo "Testing --deterministic --normalized reproducibility..."

	local dn_seq1=$(random -d -n --seed 54321 --count 5 0 100 2>/dev/null | tr '\n' ' ')
	local dn_seq2=$(random -d -n --seed 54321 --count 5 0 100 2>/dev/null | tr '\n' ' ')

	if [ "$dn_seq1" = "$dn_seq2" ] && [ -n "$dn_seq1" ]; then
		echo "✓ Deterministic normalized reproducibility test passed"
	else
		echo "✗ Deterministic normalized reproducibility test failed" >&2
		echo "  Seq1: $dn_seq1" >&2
		echo "  Seq2: $dn_seq2" >&2
		(( fails++ ))
	fi

	# Test 23: Combined mode still has normal distribution
	(( tests++ ))
	echo "Testing --deterministic --normalized still center-heavy..."

	local dn_sample=$(random -d -n --seed 11111 --count $SAMPLE_SIZE 0 100 2>/dev/null)
	local dn_center=0
	local dn_total=0

	while IFS= read -r val; do
		(( dn_total++ ))
		if [ "$val" -ge 35 ] && [ "$val" -le 65 ]; then
			(( dn_center++ ))
		fi
	done <<< "$dn_sample"

	local dn_pct=$((dn_center * 100 / dn_total))

	if [ "$dn_pct" -ge 40 ]; then
		echo "✓ Deterministic normalized distribution test passed ($dn_pct% in center)"
	else
		echo "✗ Deterministic normalized distribution test failed: $dn_pct% in center" >&2
		(( fails++ ))
	fi

	# ===== SECTION 6: Symlink/invocation name behavior =====
	echo ""
	echo "--- Section 6: Symlink invocation behavior ---"

	# Test 24: nrandom symlink implies --normalized
	(( tests++ ))
	echo "Testing nrandom symlink implies --normalized..."

	# Check nrandom exists and is a symlink
	if [ -L "$HOME/bin/nrandom" ] || [ -x "$HOME/bin/nrandom" ]; then
		local nrandom_sample=$(nrandom --count 50 0 100 2>/dev/null)
		local nr_center=0
		local nr_total=0

		while IFS= read -r val; do
			(( nr_total++ ))
			if [ "$val" -ge 35 ] && [ "$val" -le 65 ]; then
				(( nr_center++ ))
			fi
		done <<< "$nrandom_sample"

		local nr_pct=$((nr_center * 100 / nr_total))

		if [ "$nr_pct" -ge 35 ]; then
			echo "✓ nrandom symlink test passed ($nr_pct% in center)"
		else
			echo "✗ nrandom symlink test failed: not center-heavy ($nr_pct%)" >&2
			(( fails++ ))
		fi
	else
		echo "✗ nrandom symlink test failed: nrandom not found" >&2
		(( fails++ ))
	fi

	# Test 25: drandom symlink implies --deterministic
	(( tests++ ))
	echo "Testing drandom symlink implies --deterministic..."

	if [ -L "$HOME/bin/drandom" ] || [ -x "$HOME/bin/drandom" ]; then
		# drandom with DRANDOM_SEED should be deterministic
		local dr_seq1=$(DRANDOM_SEED=77777 drandom --count 3 2>/dev/null | tr '\n' ' ')
		local dr_seq2=$(DRANDOM_SEED=77777 drandom --count 3 2>/dev/null | tr '\n' ' ')

		if [ "$dr_seq1" = "$dr_seq2" ] && [ -n "$dr_seq1" ]; then
			echo "✓ drandom symlink test passed"
		else
			echo "✗ drandom symlink test failed: not deterministic" >&2
			(( fails++ ))
		fi
	else
		echo "✗ drandom symlink test failed: drandom not found" >&2
		(( fails++ ))
	fi

	# ===== SECTION 7: Binary output with modes =====
	echo ""
	echo "--- Section 7: Binary output with modes ---"

	# Test 26: --binaryoutput with --deterministic
	(( tests++ ))
	echo "Testing --binaryoutput --deterministic..."

	local bd_out1=$(random -b -d --seed 12121 -c 32 2>/dev/null | xxd -p | tr -d '\n')
	local bd_out2=$(random -b -d --seed 12121 -c 32 2>/dev/null | xxd -p | tr -d '\n')

	if [ "$bd_out1" = "$bd_out2" ] && [ "${#bd_out1}" -eq 64 ]; then
		echo "✓ Binary deterministic test passed"
	else
		echo "✗ Binary deterministic test failed" >&2
		(( fails++ ))
	fi

	# Test 27: --binaryoutput with --normalized
	(( tests++ ))
	echo "Testing --binaryoutput --normalized..."

	local bn_out=$(random -b -n -c 200 2>/dev/null | xxd -p | tr -d '\n')
	local bn_bytes=$((${#bn_out} / 2))

	if [ "$bn_bytes" -eq 200 ]; then
		# Check center-heavy distribution (bytes 96-160 should be common)
		local bn_center=0
		for hex in $(echo "$bn_out" | fold -w2); do
			local decimal=$((16#$hex))
			if [ "$decimal" -ge 96 ] && [ "$decimal" -le 160 ]; then
				(( bn_center++ ))
			fi
		done
		local bn_pct=$((bn_center * 100 / bn_bytes))

		if [ "$bn_pct" -ge 35 ]; then
			echo "✓ Binary normalized test passed ($bn_pct% in center)"
		else
			echo "✗ Binary normalized test failed: $bn_pct% in center" >&2
			(( fails++ ))
		fi
	else
		echo "✗ Binary normalized test failed: expected 200 bytes, got $bn_bytes" >&2
		(( fails++ ))
	fi

	# ===== SECTION 8: Output encodings =====
	echo ""
	echo "--- Section 8: Output encodings (--hex, --base64) ---"

	# Test 28: --hex output
	(( tests++ ))
	echo "Testing --hex output..."

	local hex_out=$(random -d --seed 11111 -c 5 --hex 2>/dev/null)
	# Should be hex digits only, one per line
	local hex_valid=true
	local hex_count=0
	while IFS= read -r line; do
		(( hex_count++ ))
		if ! [[ "$line" =~ ^[0-9a-fA-F]+$ ]]; then
			hex_valid=false
		fi
	done <<< "$hex_out"

	if $hex_valid && [ "$hex_count" -eq 5 ]; then
		echo "✓ --hex output test passed"
	else
		echo "✗ --hex output test failed: invalid hex or count" >&2
		(( fails++ ))
	fi

	# Test 29: --base64 output
	(( tests++ ))
	echo "Testing --base64 output..."

	local b64_out=$(random -b -d --seed 22222 -c 30 --base64 2>/dev/null)
	# Should be valid base64 (A-Za-z0-9+/=)
	if [[ "$b64_out" =~ ^[A-Za-z0-9+/=]+$ ]] && [ -n "$b64_out" ]; then
		# Decode and verify length
		local decoded_len=$(echo "$b64_out" | base64 -d 2>/dev/null | wc -c | tr -d ' ')
		if [ "$decoded_len" -eq 30 ]; then
			echo "✓ --base64 output test passed"
		else
			echo "✗ --base64 output test failed: decoded length $decoded_len != 30" >&2
			(( fails++ ))
		fi
	else
		echo "✗ --base64 output test failed: invalid base64" >&2
		(( fails++ ))
	fi

	# ===== SECTION 9: Delimiter and stdin operations =====
	echo ""
	echo "--- Section 9: --delimiter, --choose, --shuffle, --weighted ---"

	# Test 30: --delimiter with --count
	(( tests++ ))
	echo "Testing --delimiter output..."

	local delim_out=$(random -d --seed 33333 -c 5 --delimiter "," 0 10 2>/dev/null)
	local comma_count=$(echo "$delim_out" | tr -cd ',' | wc -c | tr -d ' ')

	if [ "$comma_count" -eq 4 ]; then  # 5 numbers = 4 commas
		echo "✓ --delimiter output test passed"
	else
		echo "✗ --delimiter output test failed: expected 4 commas, got $comma_count" >&2
		(( fails++ ))
	fi

	# Test 31: --choose from stdin
	(( tests++ ))
	echo "Testing --choose from stdin..."

	local choose_input="apple
banana
cherry
date"
	local choose_out=$(echo "$choose_input" | random --choose -d --seed 44444 2>/dev/null)

	if [[ "$choose_out" =~ ^(apple|banana|cherry|date)$ ]]; then
		echo "✓ --choose test passed (got: $choose_out)"
	else
		echo "✗ --choose test failed: got '$choose_out'" >&2
		(( fails++ ))
	fi

	# Test 32: --choose is deterministic with seed
	(( tests++ ))
	echo "Testing --choose determinism..."

	local choose1=$(echo "$choose_input" | random --choose -d --seed 55555 2>/dev/null)
	local choose2=$(echo "$choose_input" | random --choose -d --seed 55555 2>/dev/null)

	if [ "$choose1" = "$choose2" ]; then
		echo "✓ --choose determinism test passed"
	else
		echo "✗ --choose determinism test failed" >&2
		(( fails++ ))
	fi

	# Test 33: --choose with custom delimiter
	(( tests++ ))
	echo "Testing --choose with --delimiter..."

	local choose_delim_out=$(echo "red,green,blue,yellow" | random --choose --delimiter "," -d --seed 66666 2>/dev/null)

	if [[ "$choose_delim_out" =~ ^(red|green|blue|yellow)$ ]]; then
		echo "✓ --choose with delimiter test passed (got: $choose_delim_out)"
	else
		echo "✗ --choose with delimiter test failed: got '$choose_delim_out'" >&2
		(( fails++ ))
	fi

	# Test 34: --shuffle from stdin
	(( tests++ ))
	echo "Testing --shuffle from stdin..."

	local shuffle_input="1
2
3
4
5"
	local shuffle_out=$(echo "$shuffle_input" | random --shuffle -d --seed 77777 2>/dev/null)
	local shuffle_sorted=$(echo "$shuffle_out" | sort -n | tr '\n' ' ')
	local input_sorted=$(echo "$shuffle_input" | sort -n | tr '\n' ' ')

	if [ "$shuffle_sorted" = "$input_sorted" ]; then
		# Check it's actually shuffled (not same order)
		local shuffle_order=$(echo "$shuffle_out" | tr '\n' ' ')
		local input_order=$(echo "$shuffle_input" | tr '\n' ' ')
		# With seed 77777, it should be different from original
		echo "✓ --shuffle test passed (order: $shuffle_order)"
	else
		echo "✗ --shuffle test failed: elements missing or added" >&2
		(( fails++ ))
	fi

	# Test 35: --shuffle is deterministic
	(( tests++ ))
	echo "Testing --shuffle determinism..."

	local shuf1=$(echo "$shuffle_input" | random --shuffle -d --seed 88888 2>/dev/null | tr '\n' ' ')
	local shuf2=$(echo "$shuffle_input" | random --shuffle -d --seed 88888 2>/dev/null | tr '\n' ' ')

	if [ "$shuf1" = "$shuf2" ]; then
		echo "✓ --shuffle determinism test passed"
	else
		echo "✗ --shuffle determinism test failed" >&2
		(( fails++ ))
	fi

	# Test 36: --weighted selection
	(( tests++ ))
	echo "Testing --weighted from stdin..."

	local weighted_input="rare:1
common:10
verycommon:100"
	local weighted_out=$(echo "$weighted_input" | random --weighted -d --seed 99999 2>/dev/null)

	if [[ "$weighted_out" =~ ^(rare|common|verycommon)$ ]]; then
		echo "✓ --weighted test passed (got: $weighted_out)"
	else
		echo "✗ --weighted test failed: got '$weighted_out'" >&2
		(( fails++ ))
	fi

	# Test 37: --weighted statistical bias (heavier weights more likely)
	(( tests++ ))
	echo "Testing --weighted statistical bias..."

	local w_rare=0
	local w_common=0
	local w_verycommon=0
	for i in $(seq 1 200); do
		local pick=$(echo "$weighted_input" | random --weighted -d --seed $i 2>/dev/null)
		case "$pick" in
			rare) (( w_rare++ )) ;;
			common) (( w_common++ )) ;;
			verycommon) (( w_verycommon++ )) ;;
		esac
	done

	# verycommon should be picked most often (weight 100 vs 10 vs 1)
	if [ "$w_verycommon" -gt "$w_common" ] && [ "$w_common" -gt "$w_rare" ]; then
		echo "✓ --weighted bias test passed (rare=$w_rare, common=$w_common, verycommon=$w_verycommon)"
	else
		echo "✗ --weighted bias test failed (rare=$w_rare, common=$w_common, verycommon=$w_verycommon)" >&2
		(( fails++ ))
	fi

	# Test 38: --weighted errors without colon
	(( tests++ ))
	echo "Testing --weighted error on missing colon..."

	local weighted_error weighted_status
	weighted_error=$(echo -e "good:5\nbad_no_colon" | random --weighted 2>&1)
	weighted_status=$?

	if [ $weighted_status -ne 0 ] && echo "$weighted_error" | grep -qi "error"; then
		echo "✓ --weighted missing colon error test passed"
	else
		echo "✗ --weighted missing colon error test failed" >&2
		(( fails++ ))
	fi

	# ===== SECTION 10: Normal distribution parameters =====
	echo ""
	echo "--- Section 10: --mean and --stddev ---"

	# Test 39: --mean and --stddev customize normal distribution
	(( tests++ ))
	echo "Testing --mean and --stddev parameters..."

	local custom_mean=75
	local custom_stddev=5
	local stats=$(random -n --mean $custom_mean --stddev $custom_stddev -c $SAMPLE_SIZE 2>/dev/null | awk '
	{
		sum += $1
		samples[NR] = $1
	}
	END {
		mean = sum / NR
		for (i = 1; i <= NR; i++) {
			variance_sum += (samples[i] - mean) * (samples[i] - mean)
		}
		stddev = sqrt(variance_sum / (NR - 1))
		printf "MEAN=%.2f STDDEV=%.2f\n", mean, stddev
	}')

	eval "$stats"
	local mean_diff=$(echo "scale=2; if ($MEAN - $custom_mean < 0) $custom_mean - $MEAN else $MEAN - $custom_mean" | bc -l)
	local stddev_diff=$(echo "scale=2; if ($STDDEV - $custom_stddev < 0) $custom_stddev - $STDDEV else $STDDEV - $custom_stddev" | bc -l)

	if (( $(echo "$mean_diff < 2" | bc -l) )) && (( $(echo "$stddev_diff < 2" | bc -l) )); then
		echo "✓ --mean/--stddev test passed (mean=$MEAN, stddev=$STDDEV)"
	else
		echo "✗ --mean/--stddev test failed (mean=$MEAN vs $custom_mean, stddev=$STDDEV vs $custom_stddev)" >&2
		(( fails++ ))
	fi

	# ===== SECTION 11: Additional distributions =====
	echo ""
	echo "--- Section 11: Distribution types (statistical validation) ---"

	# Test 40: --exponential distribution
	(( tests++ ))
	echo "Testing --exponential distribution..."

	# Exponential with rate=1 should have mean≈1, variance≈1
	local exp_stats=$(random --exponential -d --seed 11111 -c $SAMPLE_SIZE 2>/dev/null | awk '
	{
		sum += $1
		sumsq += $1 * $1
		if (NR == 1 || $1 < min) min = $1
	}
	END {
		mean = sum / NR
		variance = (sumsq / NR) - (mean * mean)
		printf "EXP_MEAN=%.3f EXP_VAR=%.3f EXP_MIN=%.3f\n", mean, variance, min
	}')

	eval "$exp_stats"
	# Exponential: mean ≈ 1/λ (we use λ=1 by default), all values >= 0
	if (( $(echo "$EXP_MEAN > 0.5 && $EXP_MEAN < 2.0" | bc -l) )) && \
	   (( $(echo "$EXP_MIN >= 0" | bc -l) )); then
		echo "✓ --exponential test passed (mean=$EXP_MEAN, min=$EXP_MIN)"
	else
		echo "✗ --exponential test failed (mean=$EXP_MEAN, min=$EXP_MIN)" >&2
		(( fails++ ))
	fi

	# Test 41: --poisson distribution
	(( tests++ ))
	echo "Testing --poisson distribution..."

	# Poisson with λ=5 should have mean≈5, variance≈5
	local pois_stats=$(random --poisson --mean 5 -d --seed 22222 -c $SAMPLE_SIZE 2>/dev/null | awk '
	{
		sum += $1
		sumsq += $1 * $1
		if ($1 != int($1)) non_int++
		if ($1 < 0) negative++
	}
	END {
		mean = sum / NR
		variance = (sumsq / NR) - (mean * mean)
		printf "POIS_MEAN=%.3f POIS_VAR=%.3f NON_INT=%d NEG=%d\n", mean, variance, non_int, negative
	}')

	eval "$pois_stats"
	# Poisson: mean ≈ λ, variance ≈ λ, all integers >= 0
	if (( $(echo "$POIS_MEAN > 3 && $POIS_MEAN < 7" | bc -l) )) && \
	   (( $(echo "$POIS_VAR > 3 && $POIS_VAR < 8" | bc -l) )) && \
	   [ "$NON_INT" -eq 0 ] && [ "$NEG" -eq 0 ]; then
		echo "✓ --poisson test passed (mean=$POIS_MEAN, var=$POIS_VAR)"
	else
		echo "✗ --poisson test failed (mean=$POIS_MEAN, var=$POIS_VAR, non_int=$NON_INT, neg=$NEG)" >&2
		(( fails++ ))
	fi

	# Test 42: --log-normal distribution
	(( tests++ ))
	echo "Testing --log-normal distribution..."

	# Log-normal: log of values should be normally distributed
	local ln_stats=$(random --log-normal -d --seed 33333 -c $SAMPLE_SIZE 2>/dev/null | awk '
	BEGIN { pi = 3.14159265359 }
	{
		if ($1 <= 0) { neg++; next }
		ln_val = log($1)
		sum += ln_val
		samples[NR] = ln_val
		count++
		if ($1 < 0) negative++
	}
	END {
		mean = sum / count
		for (i = 1; i <= count; i++) {
			variance_sum += (samples[i] - mean) * (samples[i] - mean)
		}
		stddev = sqrt(variance_sum / (count - 1))
		# For standard log-normal (mu=0, sigma=1), log values should have mean≈0, stddev≈1
		printf "LN_LOG_MEAN=%.3f LN_LOG_STDDEV=%.3f NEG=%d\n", mean, stddev, neg
	}')

	eval "$ln_stats"
	# Log of log-normal should be normal (mean≈0, stddev≈1 for standard params)
	if (( $(echo "$LN_LOG_MEAN > -0.5 && $LN_LOG_MEAN < 0.5" | bc -l) )) && \
	   (( $(echo "$LN_LOG_STDDEV > 0.7 && $LN_LOG_STDDEV < 1.3" | bc -l) )) && \
	   [ "$NEG" -eq 0 ]; then
		echo "✓ --log-normal test passed (log_mean=$LN_LOG_MEAN, log_stddev=$LN_LOG_STDDEV)"
	else
		echo "✗ --log-normal test failed (log_mean=$LN_LOG_MEAN, log_stddev=$LN_LOG_STDDEV, neg=$NEG)" >&2
		(( fails++ ))
	fi

	# Test 43: --beta distribution
	(( tests++ ))
	echo "Testing --beta distribution..."

	# Beta(2,5): mean = α/(α+β) = 2/7 ≈ 0.286, all values in [0,1]
	local beta_stats=$(random --beta --alpha 2 --beta-param 5 -d --seed 44444 -c $SAMPLE_SIZE 2>/dev/null | awk '
	{
		sum += $1
		if ($1 < 0 || $1 > 1) out_of_range++
	}
	END {
		mean = sum / NR
		printf "BETA_MEAN=%.3f OUT_OF_RANGE=%d\n", mean, out_of_range
	}')

	eval "$beta_stats"
	# Beta(2,5) mean ≈ 0.286
	if (( $(echo "$BETA_MEAN > 0.2 && $BETA_MEAN < 0.4" | bc -l) )) && \
	   [ "$OUT_OF_RANGE" -eq 0 ]; then
		echo "✓ --beta test passed (mean=$BETA_MEAN)"
	else
		echo "✗ --beta test failed (mean=$BETA_MEAN, out_of_range=$OUT_OF_RANGE)" >&2
		(( fails++ ))
	fi

	# Test 44: Multiple distributions error
	(( tests++ ))
	echo "Testing multiple distributions error..."

	local multi_dist_out multi_dist_status
	multi_dist_out=$(random --exponential --poisson 2>&1)
	multi_dist_status=$?

	if [ $multi_dist_status -ne 0 ] && echo "$multi_dist_out" | grep -qi "error"; then
		echo "✓ Multiple distributions error test passed"
	else
		echo "✗ Multiple distributions error test failed" >&2
		(( fails++ ))
	fi

	# ===== Final results =====
	echo ""
	echo "============================================"
	if [ $fails -gt 0 ]; then
		echo "random test FAILED: $fails of $tests tests failed" >&2
		return $fails
	else
		echo "random test PASSED: All $tests tests passed"
		return 0
	fi
}

# Run the test if this script is executed directly
if ! (return 0 2>/dev/null); then
	test_random
	exit $?
fi
