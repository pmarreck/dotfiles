#!/usr/bin/env bash
# set -euo pipefail # Safety first (temporarily disabled to ensure compatibility during refactor, will enable selectively)

### jpegxl: a bash function to make conversions to/from jpegxl easier!

# Usage: jpegxl [options] file1 [file2 ...]

# Future Improvements:
# -----------------------------------------------------------------------------------
# 1. Batch Processing:
#    - Implement a progress indicator for batch operations
#    - Add statistics summary for batch results
#
# 2. Additional Options:
#    - Add a --force flag to overwrite existing files without prompting
#    - Add a --dry-run option to show what would be done without making changes
#
# 3. Error Handling:
#    - Add timeout handling for conversion operations
#    - Implement disk space verification before large conversions
#    - Add file permission checks before writing output files
#
# 4. Performance:
#    - Implement parallel processing for batch operations
#    - Add memory usage limits for ImageMagick operations
#    - Use ramdisk for temporary files on supported systems
#
# 5. Documentation:
#    - Include benchmarks comparing different compression settings
#    - Add visual examples of quality vs. file size tradeoffs
#    - Create a man page for better system integration
#
# 6. Support for animated images (APNG, GIF) and maintaining animation in JXL format
# -----------------------------------------------------------------------------------

# Silence function - runs a command silently but preserves exit code
silence() {
	"$@" >/dev/null 2>&1
}

# Check for required dependencies
check_dependencies() {
	local missing_deps=()

	# Check for JPEG XL tools
	if ! silence command -v cjxl; then
		missing_deps+=("cjxl")
	fi

	if ! silence command -v djxl; then
		missing_deps+=("djxl")
	fi

	# Check for ImageMagick
	if ! silence command -v magick; then
		missing_deps+=("ImageMagick")
	fi

	# Determine which stat command to use
	if silence command -v gstat; then
		# Use GNU stat from coreutils if available (macOS with homebrew/nix)
		STAT="gstat"
	elif silence stat --version; then
		# Use GNU stat if available (Linux)
		STAT="stat"
	else
		# No GNU stat available
		missing_deps+=("GNU stat (gstat)")
	fi
	export STAT

	# Determine which date command to use
	if silence command -v gdate; then
		# Use GNU date from coreutils if available (macOS with homebrew/nix)
		DATE="gdate"
	elif silence date --version; then
		# Use GNU date if available (Linux)
		DATE="date"
	else
		# No GNU date available
		missing_deps+=("GNU date (gdate)")
	fi
	export DATE

	# Determine which numfmt command to use
	if silence command -v gnumfmt; then
		# Use GNU numfmt from coreutils if available (macOS with homebrew/nix)
		NUMFMT="gnumfmt"
	elif silence numfmt --version; then
		# Use GNU numfmt if available (Linux)
		NUMFMT="numfmt"
	else
		# No GNU numfmt available, but this is optional
		NUMFMT=""
	fi
	export NUMFMT

	if [[ ${#missing_deps[@]} -gt 0 ]]; then
		echo "Error: Missing required dependencies: ${missing_deps[*]}" >&2
		if [[ " ${missing_deps[*]} " =~ " GNU stat (gstat) " || " ${missing_deps[*]} " =~ " GNU date (gdate) " ]]; then
			echo "Note: This script requires GNU versions of stat and date." >&2
			echo "On macOS, install them with: brew install coreutils" >&2
			echo "Or with Nix/nix-darwin: nix-shell -p coreutils-prefixed (or add to global flake.nix)" >&2
		fi
		return 1
	fi

	return 0
}

# Debug output function
declare -F debug >/dev/null 2>&1 || \
debug() {
	[ -n "$DEBUG" ] && echo "DEBUG: $*" >&2
}

# Global array for temp files to ensure cleanup
declare -a TEMP_FILES=()

# Cleanup function
cleanup() {
	if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
		debug "Cleaning up ${#TEMP_FILES[@]} temporary files..."
		for temp_file in "${TEMP_FILES[@]}"; do
			if [[ -f "$temp_file" ]]; then
				rm -f "$temp_file"
			fi
		done
	fi
}

# Register cleanup trap
trap cleanup EXIT INT TERM

# Create a temporary file
create_temp_file() {
	local extension=$1
	local temp_file

	# Use universal mktemp --tmpdir syntax
	local base_temp=$(mktemp --tmpdir jpegxl.XXXXXX)

	# Rename it to have the correct extension
	temp_file="${base_temp}.${extension}"
	mv "$base_temp" "$temp_file"

	TEMP_FILES+=("$temp_file")

	debug "Created temporary file: $temp_file"
	echo "$temp_file"
}

# Compute the output path
compute_output_path() {
	local input_file="$1"
	local extension="${input_file##*.}"
	extension="${extension,,}"  # Convert to lowercase
	local to_format="${2:-jxl}"  # Default output format is jxl

	local output_path="${input_file%.*}.${to_format}"
	echo "$output_path"
}

# Display compression ratio
display_compression_ratio() {
	local original_file="$1"
	local new_file="$2"

	local original_size=$($STAT -c "%s" "$original_file")
	local new_size=$($STAT -c "%s" "$new_file")

	# Avoid division by zero
	if [[ "$original_size" -eq 0 ]]; then
		echo "$original_file (empty) → $new_file ($new_size bytes)"
		return
	fi

	local percentage=$(echo "scale=2; 100 * $new_size / $original_size" | bc)

	local original_size_display="$original_size"
	local new_size_display="$new_size"

	if [[ -n "$NUMFMT" ]]; then
		original_size_display=$(echo "$original_size" | $NUMFMT --to=iec)
		new_size_display=$(echo "$new_size" | $NUMFMT --to=iec)
	fi

	echo "$original_file → $new_file ($new_size_display, ${percentage}% of original)"
}

print_help() {
	cat << EOF
Usage: jpegxl [OPTIONS] FILES...

Convert images to and from JPEG XL format. Supports batch processing.

Options:
	--help, -h               Show this help message
	--about                  Show a brief description
	--effort=N               Set compression effort (1-10, default: 10)
	--distance=N             Set compression distance (0-15, default: 1)
													 0 is lossless, higher values = more lossy
	--quality=N              Set compression quality (1-100, default: 93)
													 Equivalent to setting distance, but in a more familiar scale
	--lossy                  Use lossy compression
	--lossless               Use lossless compression
	--basic                  Use basic compression settings (effort=5, lossy)
	--to=FORMAT              Convert JXL to another format (jpeg, png, etc.)
	--preserve-timestamps    Preserve original timestamps
	test                     Run self-test

Environment Variables:
	JPEGXL_DEFAULT_EFFORT    Set default compression effort (1-10, default: 10)
	JPEGXL_DEFAULT_DISTANCE  Set default compression distance (0-15, default: 1)
	DEBUG                    Enable debug output

Examples:
	# Convert a JPEG to JXL (lossless by default)
	jpegxl image.jpg

	# Convert multiple images to JXL
	jpegxl image1.jpg image2.png

	# Convert a JPEG to JXL with lossy compression
	jpegxl --lossy image.jpg

	# Convert a JPEG to JXL with specific quality
	jpegxl --quality=80 image.jpg

	# Convert a JXL back to JPEG
	jpegxl --to=jpeg image.jxl

	# Convert a JXL to PNG
	jpegxl --to=png image.jxl

	# Preserve original file timestamps
	jpegxl --preserve-timestamps image.jpg

Notes:
	- By default, the script preserves as much data as possible (lossless, HDR, metadata)
	- Use --lossy or --basic to sacrifice quality for compression

Dependencies:
	- JPEG XL tools (cjxl, djxl)
	- ImageMagick (convert, identify)
	- ExifTool (optional, for better metadata handling)
EOF
}

# Process a single file
process_file() {
	local file="$1"
	local effort="$2"
	local distance="$3"
	local lossy="$4"
	local preserve_timestamps="$5"
	local to_format="$6"
	local quality="$7"

	if [[ ! -f "$file" ]]; then
		echo "Error: File not found: $file" >&2
		return 1
	fi

	local extension="${file##*.}"
	extension="${extension,,}"
	debug "Processing $file ($extension)..."

	local original_file="$file"
	local output=""
	local temp_png=""

	# Determine output path
	if [[ "$extension" != "jxl" ]]; then
		output=$(compute_output_path "$file" "jxl")
	elif [[ -n "$to_format" ]]; then
		output=$(compute_output_path "$file" "$to_format")
	else
		# JXL input but no target format? Skip.
		debug "Skipping $file (JXL file, no --to format specified)"
		return 0
	fi

	debug "Output file: $output"

	# CASE 1: JXL -> Other Format
	if [[ "$extension" == "jxl" && -n "$to_format" ]]; then
		case "$to_format" in
			jpeg|jpg)
				debug "Converting JXL to JPEG: $file -> $output"
				if ! djxl -q "$quality" "$file" "$output" 2>/dev/null; then
					echo "Error converting $file to JPEG." >&2
					return 1
				fi
				;;
			png)
				debug "Converting JXL to PNG: $file -> $output"
				if ! djxl "$file" "$output" 2>/dev/null; then
					echo "Error converting $file to PNG." >&2
					return 1
				fi
				;;
			webp)
				debug "Converting JXL to WebP (via PNG): $file -> $output"
				temp_png=$(create_temp_file "png")
				if ! djxl "$file" "$temp_png" 2>/dev/null; then
					echo "Error converting $file to intermediate PNG." >&2
					return 1
				fi
				if ! magick "$temp_png" -quality "$quality" "$output" 2>/dev/null; then
					echo "Error converting intermediate PNG to WebP." >&2
					return 1
				fi
				;;
			*)
				echo "Unsupported target format: $to_format" >&2
				return 1
				;;
		esac

	# CASE 2: Other Format -> JXL
	else
		# Handle formats needing intermediate conversion (WebP, HEIC)
		if [[ "$extension" == "webp" || "$extension" == "heic" ]]; then
			temp_png=$(create_temp_file "png")
			debug "Converting $extension to intermediate PNG: $file -> $temp_png"

			if [[ "$extension" == "heic" ]]; then
				# Try ImageMagick first, then heif-convert
				if ! magick "$file" -alpha off -colorspace sRGB "$temp_png" 2>/dev/null; then
					if command -v heif-convert &>/dev/null; then
						if ! heif-convert "$file" "$temp_png" 2>/dev/null; then
							echo "Error: Failed to convert HEIC file $file to PNG." >&2
							return 1
						fi
					else
						echo "Error: Failed to convert HEIC $file. Please install heif-convert or update ImageMagick." >&2
						return 1
					fi
				fi
			elif [[ "$extension" == "webp" ]]; then
				if ! magick "$file" "$temp_png" 2>/dev/null; then
					if command -v dwebp &>/dev/null; then
						if ! dwebp "$file" -o "$temp_png" 2>/dev/null; then
							echo "Error: Failed to convert WebP $file to PNG." >&2
							return 1
						fi
					else
						echo "Error: Failed to convert WebP $file. Please install dwebp or update ImageMagick." >&2
						return 1
					fi
				fi
			fi

			# If intermediate PNG conversion failed, return
			if [[ ! -f "$temp_png" ]]; then
				echo "Error: Intermediate PNG file was not created for $original_file." >&2
				return 1
			fi
			file="$temp_png" # Use the intermediate PNG for JXL conversion
		fi

		# Perform JXL conversion
		if [[ "$extension" == "jpg" || "$extension" == "jpeg" ]]; then
			if [[ "$lossy" == "true" ]]; then
				debug "Converting JPEG to JXL (lossy, d=$distance): $file -> $output"
				if ! cjxl -e "$effort" -d "$distance" "$file" "$output" 2>/dev/null; then
					echo "Error converting $original_file to JXL." >&2
					return 1
				fi
			else
				debug "Converting JPEG to JXL (lossless JPEG transcoding): $file -> $output"
				if ! cjxl -e "$effort" --lossless_jpeg=1 "$file" "$output" 2>/dev/null; then
					echo "Error converting $original_file to JXL." >&2
					return 1
				fi
			fi
		else
			# For non-JPEG (PNG, or intermediate PNG), use distance
			# Note: For strict lossless, distance MUST be 0
			if [[ "$lossy" == "false" ]]; then
				debug "Converting $extension to JXL (lossless, d=0): $file -> $output"
				if ! cjxl -e "$effort" -d 0 "$file" "$output" 2>/dev/null; then
					echo "Error converting $original_file to JXL." >&2
					return 1
				fi
			else
				debug "Converting $extension to JXL (lossy, d=$distance): $file -> $output"
				if ! cjxl -e "$effort" -d "$distance" "$file" "$output" 2>/dev/null; then
					echo "Error converting $original_file to JXL." >&2
					return 1
				fi
			fi
		fi
	fi

	# Post-processing
	if [[ "$preserve_timestamps" == "true" ]]; then
		debug "Preserving timestamps from $original_file to $output"
		touch -r "$original_file" "$output"
	fi

	if [[ -f "$output" ]]; then
		display_compression_ratio "$original_file" "$output"
		return 0
	else
		echo "Error: Output file not produced for $original_file." >&2
		return 1
	fi
}

jpegxl() {
	check_dependencies || return 1

	# Default settings, potentially overridden by environment variables
	local effort=${JPEGXL_DEFAULT_EFFORT:-10}
	local distance=${JPEGXL_DEFAULT_DISTANCE:-1}
	local lossy=false
	local preserve_timestamps=false
	local to_format=""
	local quality=93 # Default quality for djxl and magick
	local files=()

	# Parse arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-h|--help) print_help; return 0 ;;
			--about) echo "jpegxl - Convert images to and from JPEG XL format with advanced controls"; return 0 ;;
			test)
				# We now defer to the separate test file
				"$HOME/dotfiles/bin/test/jpegxl_test"
				return $?
				;;
			--effort=*) effort="${1#*=}" ;;
			--distance=*) distance="${1#*=}" ;;
			--quality=*)
				quality="${1#*=}"
				# Convert quality to distance (inverse relationship)
				# quality 100 -> distance 0, quality 1 -> distance 15
				if [[ "$quality" -ge 100 ]]; then
					distance=0
				else
					distance=$(echo "scale=2; 15 - ($quality / 100 * 15)" | bc | awk '{printf "%.0f", $0}')
				fi
				;;
			--lossy) lossy=true ;;
			--lossless) lossy=false; distance=0 ;; # When explicitly set to lossless, ensure distance is 0
			--no-hdr)
				# Deprecated and unused now, kept for backward compatibility
				debug "Option --no-hdr is deprecated and has no effect"
				;;
			--basic) effort=5; lossy=true ;;
			--preserve-timestamps) preserve_timestamps=true ;;
			--to=*) to_format="${1#*=}" ;;
			-*) echo "Unknown option: $1" >&2; print_help; return 1 ;;
			*) files+=("$1") ;; # Collect all non-option arguments as files
		esac
		shift
	done

	# If no files are provided, show help
	if [[ ${#files[@]} -eq 0 ]]; then
		echo "Error: No input files specified" >&2
		print_help
		return 1
	fi

	# Check for conflicting options and make them consistent
	if [[ "$lossy" == "true" && "$distance" -eq 0 ]]; then
		echo "Warning: Conflicting options: --lossy and --distance=0 (lossless)" >&2
		echo "Using --lossless mode (--distance=0 takes precedence)" >&2
		lossy=false
	fi

	# If --lossless is specified but distance is not 0, adjust distance
	if [[ "$lossy" == "false" && "$distance" -ne 0 ]]; then
		echo "Warning: Setting distance to 0 for lossless mode" >&2
		distance=0
	fi

	# Debug mode
	if [[ "$DEBUG" == "true" ]]; then
		debug "Effort set to: $effort"
		debug "Distance set to: $distance"
		debug "Lossy mode: $lossy"
		debug "Preserve timestamps: $preserve_timestamps"
		debug "Target format: $to_format"
		debug "Quality: $quality"
		debug "Files to process: ${files[*]}"
	fi

	local failures=0
	for file in "${files[@]}"; do
		if ! process_file "$file" "$effort" "$distance" "$lossy" "$preserve_timestamps" "$to_format" "$quality"; then
			((failures++))
		fi
	done

	if [[ "$failures" -gt 0 ]]; then
		echo "Completed with $failures failures." >&2
		return 1
	else
		echo "All files processed successfully."
		return 0
	fi
}

# Run the function if this script is executed directly, avoiding double execution
if ! (return 0 2>/dev/null); then
	# If called directly, pass all arguments to the function
	jpegxl "$@"
fi
