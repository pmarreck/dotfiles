#!/usr/bin/env bash

declare -F debug >/dev/null 2>&1 || \
debug() {
	[ -n "$DEBUG" ] && echo "DEBUG: $*" >&2
}

silence() {
	"$@" >/dev/null 2>&1
}

glob() {
	# Help function
	_show_help() {
		cat << EOF
glob: A utility for controlled glob expansion

USAGE:
	glob [OPTIONS] PATTERN                   glob a glob pattern and print results
	glob [OPTIONS] COMMAND [ARG...]          Run a command with globbed arguments
	glob --test                              Run self-tests
	glob -h, --help                          Show this help message

OPTIONS:
	-i, --ignore-case                Case-insensitive pattern matching
	--double-quote                   Newline-separated, double-quoted output with embedded quotes escaped
	-n                               Space-separated output with shell escaping
	-0                               Null-separated output without escaping

EXAMPLES:
	glob "*.jpg"                   glob and print all jpg files (newline-separated)
	glob --double-quote "*.jpg"    glob jpg files (double-quoted newline-separated)
	glob -n "*.jpg"                glob jpg files (space-separated with escaping)
	glob -0 "*.jpg"                glob jpg files (null-separated)
	glob -i "*.JPG"                glob jpg files ignoring case
	glob ls -la "*.jpg"            Run ls -la with globbed jpg files
	glob --ignore-case ls "*.JPG"  Run ls with case-insensitive matching
	glob jpegxl --lossless "*.jpg" Run jpegxl with globbed jpg files
	
	# Multiple file types (quoted brace expansion):
	glob "*.{png,jpg,gif}"         Find png, jpg, and gif files
	glob -i "*.{png,jpg,gif}"      Case-insensitive multiple types
	
	# Multiple patterns (alternative to brace expansion):
	glob "*.png" "*.jpg" "*.gif"   Find png, jpg, and gif files
	
	# Recursive patterns:
	glob "**/*.jpg"                Find all jpg files in subdirectories
	glob -i "**/*.{png,jpg}"       Case-insensitive recursive search
	
	# Dotfiles (hidden files):
	glob ".*"                      Find dotfiles in current directory
	glob "**/.git"                 Find all .git directories recursively
	
	# Non-matching pattern behavior:
	glob "*.nonexistent"           Empty output, exit code 1
	glob "*.txt" "*.nonexistent"   Only shows *.txt files (skips non-matching)
	glob ls "*.txt" "*.missing"    ls only gets the *.txt arguments

DESCRIPTION:
	The glob function provides controlled glob expansion even when
	globbing is disabled (set -f). By default, output is newline-separated
	without shell escaping. Use -n for space-separated output with escaping,
	or -0 for null-separated output.

	When used with a command, it globs any glob patterns in the arguments
	before passing them to the command. Non-matching patterns are skipped
	entirely.

	PATTERN BEHAVIOR:
	- Standard glob patterns: * ? [abc]
	- Recursive patterns: ** (matches subdirectories)
	- Dotfiles: Hidden files (.*) are excluded by default unless explicitly matched
	- Case sensitivity: Patterns are case-sensitive by default
	- Brace expansion: Use quoted patterns like "*.{png,jpg}" for multiple types
	
	BRACE EXPANSION:
	The glob function supports quoted brace expansion, allowing you to match
	multiple file types or patterns in a single argument:
	
	glob "*.{jpg,png,gif}"         # Match all image files
	glob "file.{txt,log,bak}"      # Match specific file with different extensions
	glob "**/*.{js,ts,jsx,tsx}"    # Recursive search for JavaScript/TypeScript files
	glob -i "**/*.{JPG,PNG}"       # Case-insensitive recursive image search

	NON-MATCHING PATTERNS:
	When a glob pattern matches no files, it is SKIPPED entirely:
	- Direct mode: Returns empty result and exit code 1
	- Command mode: Runs command with only the matching patterns as arguments
	- Mixed patterns: Only matching patterns are included in the results

	EXIT CODES:
	- 0: At least one pattern matched files
	- 1: No patterns matched any files
	- 2: Invalid usage (no arguments, etc.)

	The -i/--ignore-case option enables case-insensitive pattern matching,
	so "*.jpg" will match "*.JPG", "*.Jpg", etc.
EOF
	}

	# Check for special arguments
	if [[ "$1" == "--help" || "$1" == "-h" ]]; then
		_show_help
		return 0
	fi
	if [[ $# -eq 0 ]]; then
		_show_help
		return 2
	fi

	# Parse flags
	local ignore_case=false
	local output_format="newline"  # default: newline-separated
	local double_quote=false
	local space_flag=false
	local null_flag=false
	local processed_argv=()
	
	# Process arguments to extract flags
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-i|--ignore-case)
				ignore_case=true
				shift
				;;
			--double-quote)
				output_format="double-quote"
				double_quote=true
				shift
				;;
			-n)
				space_flag=true
				output_format="space"
				shift
				;;
			-0)
				null_flag=true
				output_format="null"
				shift
				;;
			*)
				# Not a flag, add to processed arguments
				processed_argv+=("$1")
				shift
				;;
		esac
	done
	
	# Restore arguments without flags
	set -- "${processed_argv[@]}"

	# If double-quote is requested, it overrides other output formats; warn if conflicts
	if $double_quote; then
		if $space_flag; then
			echo "Warning: -n is ignored when --double-quote is used" >&2
		fi
		if $null_flag; then
			echo "Warning: -0 is ignored when --double-quote is used" >&2
		fi
		output_format="double-quote"
	fi
	
	if [[ $# -eq 0 ]]; then
		_show_help
		return 2
	fi

	# Preprocess arguments for brace expansion
	local brace_globbed_argv=()
	local arg
	
	for arg in "$@"; do
		# Check if argument contains brace expansion patterns
		# Regex matches: {word1,word2} or {word1,word2,word3} etc.
		# Must have at least one comma inside braces
		if [[ "$arg" =~ \{[^}]*,[^}]*\} ]]; then
			debug "Detected brace expansion in: $arg"
			
			# Use bash to glob the braces 
			# First escape spaces in the argument so bash treats it as one argument
			local escaped_arg="${arg// /\\ }"
			local globbed_items
			globbed_items=$(bash -c "printf '%s\\n' $escaped_arg" 2>/dev/null) || {
				debug "Brace expansion failed, using original: $arg"
				brace_globbed_argv+=("$arg")
				continue
			}
			
			# Add each globbed item to the array
			while IFS= read -r globbed_item; do
				[[ -n "$globbed_item" ]] && brace_globbed_argv+=("$globbed_item")
			done <<< "$globbed_items"
			
			debug "Brace expansion result: ${brace_globbed_argv[*]}"
		else
			# No brace expansion needed
			brace_globbed_argv+=("$arg")
		fi
	done
	
	# Replace the original arguments with brace-globbed ones
	set -- "${brace_globbed_argv[@]}"
	
	debug "Final arguments after brace expansion: $*"

	# Store original globbing states to restore later
	local glob_disabled nullglob_set dotglob_set nocaseglob_set
	
	glob_disabled=false
	if [[ $- == *f* ]]; then
		glob_disabled=true
		debug "Globbing is disabled (noglob is set)"
	fi

	# Store other globbing options
	[[ -o nullglob ]] && nullglob_set=true || nullglob_set=false
	[[ -o dotglob ]] && dotglob_set=true || dotglob_set=false
	shopt -q nocaseglob && nocaseglob_set=true || nocaseglob_set=false

	# Enable globbing but respect existing nullglob and dotglob settings
	set +f           # Enable globbing
	# We don't change nullglob and dotglob settings - respect user's preferences
	
	# Enable nocaseglob if ignore_case flag is set
	if $ignore_case; then
		debug "Enabling case-insensitive globbing"
		shopt -s nocaseglob
	fi

	# Step 1: Check if first arg is a command
	local exec_command=""
	local args=("$@")
	local found_any_matches=false

	# Use which + file to robustly detect if first arg is an executable command
	if [[ ${#args[@]} -gt 0 ]]; then
		local resolved_path
		# Try to resolve the first argument using which
		resolved_path=$(which "${args[0]}" 2>/dev/null)
		
		if [[ -n "$resolved_path" ]]; then
			debug "which resolved '${args[0]}' to: $resolved_path"
			
			# Check if the resolved path contains "executable" in file output
			local file_output
			file_output=$(file -L "$resolved_path" 2>/dev/null)
			debug "file output: $file_output"
			
			# Also check if this looks like a data file by extension
			local data_file_extensions="\.(jpg|jpeg|png|gif|pdf|mp4|avi|mp3|wav|doc|docx|txt|log|csv)$"
			
			if [[ "$file_output" == *"executable"* ]] && [[ ! "$resolved_path" =~ $data_file_extensions ]]; then
				exec_command="${args[0]}"
				debug "Found executable command: $exec_command (resolved to: $resolved_path)"
				# Remove the command from args
				args=("${args[@]:1}")

				# Special handling for nullglob in command mode
				if $nullglob_set; then
					debug "Command mode with nullglob set - will filter out non-matching patterns"
				fi
			else
				if [[ "$resolved_path" =~ $data_file_extensions ]]; then
					debug "which resolved '${args[0]}' but it has a data file extension: $resolved_path"
				else
					debug "which resolved '${args[0]}' but file says it's not executable: $file_output"
				fi
			fi
		else
			debug "which could not resolve '${args[0]}' - treating as pattern"
		fi
	fi
	if [[ -n "$exec_command" && "$double_quote" == true ]]; then
		echo "Error: --double-quote cannot be used with command execution" >&2
		# Restore original settings before exiting
		if $glob_disabled; then set -f; fi
		if $ignore_case; then
			if $nocaseglob_set; then
				shopt -s nocaseglob
			else
				shopt -u nocaseglob
			fi
		fi
		return 2
	fi

	local processed_args=()
	for arg in "${args[@]}"; do
		# If we have a command and arg starts with - or --, pass it through
		if [[ -n "$exec_command" && ("$arg" == -* || "$arg" == --*) ]]; then
			debug "Passing through option: $arg"
			processed_args+=("$arg")
		# If arg contains glob pattern
		elif [[ "$arg" == *[\*\?\[]* ]]; then
			debug "Processing glob pattern: $arg"

			# Special handling for command mode with nullglob
			if [[ -n "$exec_command" ]] && $nullglob_set; then
				debug "Command mode with nullglob set - checking if pattern matches any files"

				# Check if the pattern matches any files
				local matches=()

				# Temporarily enable nullglob for pattern matching
				shopt -s nullglob
				# Preserve case-insensitive setting during matching
				if $ignore_case && ! $nocaseglob_set; then
					shopt -s nocaseglob
				fi
				
				if [[ "$arg" == *" "* ]]; then
					# For patterns with spaces, use find
					while IFS= read -r -d $'\0' file; do
						# Remove ./ prefix if present
						file="${file#./}"
						matches+=("$file")
					done < <(find . -maxdepth 1 -name "$arg" -print0 2>/dev/null)
				else
					# For patterns without spaces, use bash globbing
					matches=($arg)
				fi
				
				shopt -u nullglob
				# Restore original nocaseglob setting if we changed it
				if $ignore_case && ! $nocaseglob_set; then
					shopt -u nocaseglob
				fi

				# If no matches and nullglob is set, skip this pattern entirely
				if [[ ${#matches[@]} -eq 0 ]]; then
					debug "No matches found for pattern '$arg' with nullglob set - skipping"
					continue
				fi

				# Otherwise, add the matches
				debug "Found ${#matches[@]} matches for pattern '$arg'"
				found_any_matches=true
				processed_args+=("${matches[@]}")
				continue
			fi

			# Handle patterns with spaces using find or absolute paths
			if [[ "$arg" == *" "* ]]; then
				debug "Pattern contains spaces, using find or absolute path matching"
				local found_files=()

				# Check if this is an absolute path pattern
				if [[ "$arg" == /* ]]; then
					debug "Absolute path pattern detected: $arg"
					
					# Extract the directory part and the pattern part
					local dir_part="${arg%/*}"
					local pattern_part="${arg##*/}"
					
					debug "Directory part: $dir_part"
					debug "Pattern part: $pattern_part"
					
					# Check if directory exists
					if [[ -d "$dir_part" ]]; then
						# Change to that directory temporarily
						local orig_pwd="$PWD"
						cd "$dir_part" 2>/dev/null || {
							debug "Failed to cd to $dir_part"
							processed_args+=("$arg")
							continue
						}
						
						# Use bash globbing in that directory
						local temp_files=()
						shopt -s nullglob
						# Preserve case-insensitive setting during matching
						if $ignore_case && ! $nocaseglob_set; then
							shopt -s nocaseglob
						fi
						
						temp_files=($pattern_part)
						
						shopt -u nullglob
						# Restore original nocaseglob setting if we changed it
						if $ignore_case && ! $nocaseglob_set; then
							shopt -u nocaseglob
						fi
						
						# Convert back to full paths
						for file in "${temp_files[@]}"; do
							found_files+=("$dir_part/$file")
						done
						
						# Return to original directory
						cd "$orig_pwd"
					else
						debug "Directory $dir_part does not exist"
						processed_args+=("$arg")
						continue
					fi
				else
					# Relative path with spaces - use find
					debug "Relative pattern with spaces, using find"
					
					# Check if pattern contains slash - if so, handle it specially
					if [[ "$arg" == */* ]]; then
						debug "Relative pattern contains slash; globbing inside directory"
						local dir_part="${arg%/*}"
						local pattern_part="${arg##*/}"
						local found_files=()
						
						if [[ -d "$dir_part" ]]; then
							local orig_pwd="$PWD"
							cd "$dir_part" 2>/dev/null || {
								debug "Failed to cd to $dir_part"
								processed_args+=("$arg")
								continue
							}
							
							local temp_files=()
							shopt -s nullglob
							if $ignore_case && ! $nocaseglob_set; then
								shopt -s nocaseglob
							fi

							temp_files=($pattern_part)

							shopt -u nullglob
							if $ignore_case && ! $nocaseglob_set; then
								shopt -u nocaseglob
							fi

							for file in "${temp_files[@]}"; do
								found_files+=("$dir_part/$file")
							done

							cd "$orig_pwd"
						else
							debug "Directory $dir_part does not exist"
						fi
						
						if [[ ${#found_files[@]} -eq 0 ]]; then
							debug "No matches found for pattern with spaces: $arg - skipping"
						else
							debug "Found ${#found_files[@]} matches for pattern with spaces: $arg"
							found_any_matches=true
							processed_args+=("${found_files[@]}")
						fi
						continue
					fi
					
					# Check if pattern contains ** for recursive globbing
					local is_recursive=false
					if [[ "$arg" == *"**"* ]]; then
						is_recursive=true
						debug "Detected recursive globbing pattern with **"
					fi

					# Adjust find command based on recursive flag
					local find_cmd="find ."
					if ! $is_recursive; then
						find_cmd="$find_cmd -maxdepth 1"
					fi

					# If dotglob is set, include hidden files
					if $dotglob_set; then
						debug "dotglob is set, including hidden files in find"
						find_cmd="$find_cmd -name \"$arg\" -print0"
					else
						debug "dotglob is not set, excluding hidden files in find"
						# Exclude files that start with a dot
						find_cmd="$find_cmd -name \"$arg\" -not -path \"*/\.*\" -print0"
					fi

					debug "Find command: $find_cmd"

					while IFS= read -r -d $'\0' file; do
						# Remove ./ prefix if present
						file="${file#./}"
						found_files+=("$file")
					done < <(eval "$find_cmd" 2>/dev/null)
				fi

				# If no matches found, skip the pattern (new default behavior for all modes)
				if [[ ${#found_files[@]} -eq 0 ]]; then
					debug "No matches found for pattern with spaces: $arg - skipping"
				else
					debug "Found ${#found_files[@]} matches for pattern with spaces: $arg"
					found_any_matches=true
					processed_args+=("${found_files[@]}")
				fi
			else
				# Check if pattern contains ** for recursive globbing
				if [[ "$arg" == *"**"* ]]; then
					debug "Detected recursive globbing pattern with **: $arg"

					# For recursive patterns, we use find to handle the traversal
					local found_files=()

					# Special handling for command mode with nullglob
					if [[ -n "$exec_command" ]] && $nullglob_set; then
						# First check if there are any matches using a quick find command
						local test_pattern="${arg//\*\*/\*}"
						local test_cmd="find . -path \"$test_pattern\" -print -quit 2>/dev/null"
						debug "Testing recursive pattern with nullglob: $test_cmd"

						local test_result=$(eval "$test_cmd")
						if [[ -z "$test_result" ]]; then
							debug "No matches found for recursive pattern with nullglob - skipping: $arg"
							continue
						fi
						debug "Found matches for recursive pattern, proceeding: $arg"
					fi

					# Convert the pattern to something find can use with -path
					# We need to handle the ** pattern specially
					local find_pattern="$arg"

					# Replace ** with a wildcard that find's -path can use
					# This handles the common case of **/*.ext
					find_pattern="${find_pattern//\*\*/\*}"

					# Build the find command
					local find_cmd="find ."

					# Add dotglob handling
					if ! $dotglob_set; then
						find_cmd="$find_cmd -not -path \"*/\.*\""
					fi

					# Add the pattern matching
					find_cmd="$find_cmd -path \"$find_pattern\" -print0"

					debug "Recursive find command: $find_cmd"

					# Execute the find command and collect results
					while IFS= read -r -d $'\0' file; do
						# Remove ./ prefix if present
						file="${file#./}"
						found_files+=("$file")
					done < <(eval "$find_cmd" 2>/dev/null)

					# Handle the results based on whether we found matches
					if [[ ${#found_files[@]} -eq 0 ]]; then
						debug "No matches found for recursive pattern: $arg - skipping"
					else
						# We found matches, add them to the processed args
						debug "Found ${#found_files[@]} matches for recursive pattern: $arg"
						found_any_matches=true
						processed_args+=("${found_files[@]}")
					fi

					# Skip the regular globbing for this pattern
					continue
				else
					# Use bash's built-in globbing for non-recursive patterns without spaces
					local files=()

					# Enable nullglob temporarily to detect if there are no matches
					shopt -s nullglob
					# Preserve case-insensitive setting during matching
					if $ignore_case && ! $nocaseglob_set; then
						shopt -s nocaseglob
					fi
					
					files=($arg)
					
					shopt -u nullglob
					# Restore original nocaseglob setting if we changed it
					if $ignore_case && ! $nocaseglob_set; then
						shopt -u nocaseglob
					fi
				fi

				# If no matches found, skip the pattern (new default behavior for all modes)
				if [[ ${#files[@]} -eq 0 ]]; then
					debug "No matches found for pattern: $arg - skipping"
				else
					debug "Found ${#files[@]} matches for pattern: $arg"
					found_any_matches=true
					processed_args+=("${files[@]}")
				fi
			fi
		else
			# Not a glob pattern, add as is
			debug "Adding non-glob argument: $arg"
			found_any_matches=true
			processed_args+=("$arg")
		fi
	done

	# Check if we found any matches
	if ! $found_any_matches; then
		debug "No matches found for any patterns"
		# Restore globbing states before returning
		if $glob_disabled; then set -f; fi
		if $ignore_case; then
			if $nocaseglob_set; then
				shopt -s nocaseglob
			else
				shopt -u nocaseglob
			fi
		fi
		return 1
	fi

	# Step 3: Sort and emit results
	local sorted_output
	if [[ ${#processed_args[@]} -gt 0 ]]; then
		# Sort the output using C locale for consistent behavior
		# This ensures predictable sorting regardless of system locale
		sorted_output=$(printf "%s\n" "${processed_args[@]}" | LC_ALL=C sort)

		# Step 4: Execute command or print results
		if [[ -n "$exec_command" ]]; then
			# Convert sorted output back to array
			local sorted_args=()
			while IFS= read -r line; do
				[[ -z "$line" ]] && continue

				# Special handling for nullglob in command mode
				# If we're in command mode with nullglob set, skip any non-matching patterns
				# This is a safety check to catch any patterns that might have slipped through
				if $nullglob_set && [[ "$line" == *[*?[]* ]] && [[ ! -e "$line" ]]; then
					debug "Skipping non-matching pattern in command mode with nullglob: $line"
					continue
				fi

				sorted_args+=("$line")
			done <<< "$sorted_output"

			debug "Executing: $exec_command ${sorted_args[*]}"
			"$exec_command" "${sorted_args[@]}"
			local retcode=$?

			# Only restore the globbing state (noglob) since we didn't change nullglob or dotglob
			if $glob_disabled; then set -f; fi
			
			# Restore original nocaseglob setting
			if $ignore_case; then
				if $nocaseglob_set; then
					shopt -s nocaseglob
				else
					shopt -u nocaseglob
				fi
			fi

			return $retcode
		else
			# Print results according to output format
			case "$output_format" in
				"double-quote")
					if ! command -v quote_lines >/dev/null 2>&1; then
						echo "Error: quote_lines not found on PATH" >&2
						return 2
					fi
					printf "%s\n" "${processed_args[@]}" | LC_ALL=C sort | quote_lines
					;;
				"space")
					# Space-separated output with quoting (original behavior)
					while IFS= read -r item; do
						[[ -z "$item" ]] && continue
						builtin printf "%q " "$item"
					done <<< "$sorted_output"
					echo
					;;
				"null")
					# Null-separated output without quoting
					while IFS= read -r item; do
						[[ -z "$item" ]] && continue
						builtin printf "%s\0" "$item"
					done <<< "$sorted_output"
					;;
				*)
					# Default: newline-separated output without quoting
					while IFS= read -r item; do
						[[ -z "$item" ]] && continue
						builtin printf "%s\n" "$item"
					done <<< "$sorted_output"
					;;
			esac
		fi
	else
		# No arguments to process - output depends on format
		case "$output_format" in
			"space")
				echo
				;;
			"null"|*)
				# For null and newline formats, output nothing when no args
				;;
		esac
	fi

	# Only restore the globbing state (noglob) since we didn't change nullglob or dotglob
	if $glob_disabled; then set -f; fi
	
	# Restore original nocaseglob setting
	if $ignore_case; then
		if $nocaseglob_set; then
			shopt -s nocaseglob
		else
			shopt -u nocaseglob
		fi
	fi

	return 0
}

# Run the function if this script is executed directly
if ! (return 0 2>/dev/null); then
	# Check if we are running tests
	if [ "$1" = "--test" ]; then
		# Run tests from the test file
		test_file="$(dirname "${BASH_SOURCE[0]}")/test/$(basename "${0##\-}")_test"
		if [ -f "$test_file" ]; then
			GLOB_TEST_VERBOSE=true "$test_file"
		else
			echo "Error: Test file not found: $test_file" >&2
			exit 1
		fi
	else
		# If called directly, pass all arguments to the function
		$(basename "${0##\-}") "$@"
	fi
fi
