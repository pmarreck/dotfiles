#!/usr/bin/env bash

script_path=$(command -v "$0" 2>/dev/null || echo "$0")
script_dir=$(cd "$(dirname "$script_path")" 2>/dev/null && pwd -P)
report_script="$script_dir/src/machine_report.sh"
update_url="https://raw.githubusercontent.com/usgraphics/usgc-machine-report/refs/heads/master/machine_report.sh"

show_help() {
	cat <<USAGE
Usage: machine_report [options]

Generate the TR-100 machine report, update the bundled upstream script, or display help.

Options:
  --help           Show this help message and exit.
  --update         Download the latest upstream machine_report.sh into src/.
  --upgrade        Alias for --update.

Without options, runs the bundled machine_report.sh to display the report.
USAGE
}

perform_update() {
	shopt -s expand_aliases
	tmp_file=$(mktemp)
	if fetch_with_get "$update_url" >"$tmp_file"; then
		mv "$tmp_file" "$report_script"
		chmod +x "$report_script"
		echo "Updated $report_script from upstream." >&2
		exit 0
	else
		echo "Failed to download machine_report.sh from upstream." >&2
		rm -f "$tmp_file"
		exit 1
	fi
}

fetch_with_get() {
	local url="$1"
	local local_get="$HOME/dotfiles/bin/get"
	if [ -x "$local_get" ]; then
		"$local_get" "$url"
	elif command -v get >/dev/null 2>&1; then
		get "$url"
	elif command -v wget >/dev/null 2>&1; then
		wget --xattr -c --progress=bar -O - -- "$url"
	elif command -v curl >/dev/null 2>&1; then
		curl -fL "$url"
	else
		return 127
	fi
}

if ! command -v lastlog >/dev/null 2>&1; then
	lastlog() {
		local user=""
		while [ $# -gt 0 ]; do
			case "$1" in
				-u)
					if [ $# -lt 2 ]; then
						echo "lastlog: option requires an argument -- 'u'" >&2
						return 1
					fi
					user="$2"
					shift 2
					continue
					;;
				*)
					shift
					;;
			esac
		done

		if [ -z "$user" ]; then
			echo "lastlog: custom implementation currently supports only '-u USER'." >&2
			return 1
		fi

		if ! command -v last >/dev/null 2>&1; then
			echo "lastlog: requires either lastlog or last to be available." >&2
			return 1
		fi

		local entry
		entry=$(last --time-format iso -n 5 "$user" 2>/dev/null | grep -Ev '^$' | head -n 1 || true)
		if [ -n "$entry" ]; then
			local ip_entry
			ip_entry=$(last --time-format iso -n 5 "$user" 2>/dev/null | grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n 1 || true)
			if [ -n "$ip_entry" ]; then
				entry="$ip_entry"
			fi
		fi

		printf '%-15s %-12s %-17s %s\n' "Username" "Port" "From" "Latest"

		if [ -z "$entry" ]; then
			printf '%-15s %-12s %-17s %s\n' "$user" "" "" "**Never logged in**"
			return 0
		fi

		set -- $entry
		local username tty from start_iso
		username=$1
		tty=$2
		from=$3

		start_iso=""
		for token in "$@"; do
			if [[ $token == [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]T* ]]; then
				start_iso=$token
				break
			fi
		done

		if [ -z "$start_iso" ]; then
			printf '%-15s %-12s %-17s %s\n' "$username" "$tty" "$from" "**Never logged in**"
			return 0
		fi

		if formatted=$(date -d "$start_iso" '+%a %b %e %H:%M:%S %z %Y' 2>/dev/null); then
			read -r dow mon day time tz year <<<"$formatted"
			if [[ $from =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
				printf '%-15s %-12s %-17s %s %s %s %s %s %s %s\n' \
					"$username" "$tty" "$from" "$dow" "-" "$mon" "$day" "$tz" "$year" "$time"
			else
				printf '%-15s %-12s %-17s %s %s %s %s %s %s\n' \
					"$username" "$tty" "$from" "$mon" "$day" "$tz" "$year" "$time" ""
			fi
		else
			printf '%-15s %-12s %-17s %s\n' "$username" "$tty" "$from" "$start_iso"
		fi
	}
fi

if ! command uptime -p >/dev/null 2>&1; then
	uptime() {
		if [ "$#" -gt 0 ] && [ "$1" = "-p" ]; then
			local raw
			raw=$(command uptime 2>/dev/null || true)
			raw=${raw#* up }
			raw=${raw%%,*load average*}
			raw=${raw%%,*load averages*}
			raw=${raw%%,*users*}
			raw=${raw%%,*user*}
			raw=${raw%,}
			local segments=()
			IFS=',' read -r -a segments <<< "$raw"
			local parts=()
			for segment in "${segments[@]}"; do
				local seg
				seg=$(printf '%s' "$segment" | sed 's/^ *//; s/ *$//')
				[ -n "$seg" ] || continue
				if [[ $seg =~ ^([0-9]+)[[:space:]]+day ]]; then
					local n=${BASH_REMATCH[1]}
					if [ "$n" -eq 1 ]; then
						parts+=("1 day")
					else
						parts+=("$n days")
					fi
				elif [[ $seg =~ ^([0-9]+):([0-9]{2})$ ]]; then
					local h=${BASH_REMATCH[1]}
					local m=${BASH_REMATCH[2]}
					h=$((10#$h))
					m=$((10#$m))
					if [ "$h" -gt 0 ]; then
						parts+=("$h hour"$([ "$h" -eq 1 ] || printf 's'))
					fi
					if [ "$m" -gt 0 ]; then
						parts+=("$m minute"$([ "$m" -eq 1 ] || printf 's'))
					fi
				elif [[ $seg =~ ^([0-9]+)[[:space:]]+hour ]]; then
					local n=${BASH_REMATCH[1]}
					parts+=("$n hour"$([ "$n" -eq 1 ] || printf 's'))
				elif [[ $seg =~ ^([0-9]+)[[:space:]]+min ]]; then
					local n=${BASH_REMATCH[1]}
					parts+=("$n minute"$([ "$n" -eq 1 ] || printf 's'))
				fi
			done
			if [ ${#parts[@]} -eq 0 ]; then
				parts=("0 minutes")
			fi
			local joined
			printf -v joined '%s, ' "${parts[@]}"
			printf 'up %s\n' "${joined%, }"
		else
			command uptime "$@"
		fi
	}
fi

args=()
while [ $# -gt 0 ]; do
	case "$1" in
		--help)
			show_help
			exit 0
			;;
		--update|--upgrade)
			perform_update
			;;
		*)
			args+=("$1")
			;;
	esac
	shift
done

if [ ${#args[@]} -gt 0 ]; then
	set -- "${args[@]}"
else
	set --
fi

if command -v grep >/dev/null 2>&1; then
	real_grep=$(command -v grep)
	grep() {
		local -a args=()
		local quiet=0
		local arg
		for arg in "$@"; do
			if [ "$arg" = "-q" ] || [ "$arg" = "--quiet" ]; then
				quiet=1
			fi
			args+=("$arg")
		done
		if [ $quiet -eq 1 ]; then
			if command "$real_grep" "${args[@]}"; then
				local last_arg_index=$(( ${#args[@]} - 1 ))
				local last_arg="${args[$last_arg_index]}"
				if [ "$last_arg" = "/proc/mounts" ]; then
					printf '1'
				fi
				return 0
			else
				return 1
			fi
		else
			command "$real_grep" "$@"
		fi
	}
fi

if command -v zfs >/dev/null 2>&1; then
	real_zfs=$(command -v zfs)
	real_zpool=$(command -v zpool 2>/dev/null || true)
	fallback_zfs_dataset=""
	fallback_zfs_pool=""
	candidate=$(df -P / | awk 'NR==2 {print $1}')
	if [ -n "$candidate" ] && command "$real_zfs" list "$candidate" >/dev/null 2>&1; then
		fallback_zfs_dataset="$candidate"
		fallback_zfs_pool=${fallback_zfs_dataset%%/*}
	fi
	if [ -n "$fallback_zfs_dataset" ]; then
		zfs() {
			local last_arg="${!#}"
			if [ "$last_arg" = "zroot/ROOT/os" ]; then
				set -- "${@:1:$#-1}" "$fallback_zfs_dataset"
			fi
			command "$real_zfs" "$@"
		}
		if [ -n "$real_zpool" ] && [ -n "$fallback_zfs_pool" ]; then
			zpool() {
				if [ "$1" = "status" ] && [ "${2:-}" = "-x" ] && [ "${3:-}" = "zroot" ]; then
					shift 3
					set -- status -x "$fallback_zfs_pool" "$@"
				fi
				command "$real_zpool" "$@"
			}
		fi
	fi
fi

source "$report_script"
