#!/usr/bin/env luajit

--[[
Unified random number generator
- Multiple distributions: uniform, normal, exponential, poisson, log-normal, beta
- True random from /dev/urandom (default) or deterministic PCG32 (--deterministic/-d)
- Stdin operations: --choose, --shuffle, --weighted
- Output formats: decimal, hex, base64, binary
- Symlink-aware: 'nrandom' implies --normalized, 'drandom' implies --deterministic
]]

local ffi = require("ffi")
local bit = require("bit")

local argv = arg or {}

-- ===== FFI declarations =====
ffi.cdef[[
	int getppid(void);
	int gettimeofday(struct timeval *tv, void *tz);
	typedef long time_t;
	struct timeval {
		time_t tv_sec;
		long tv_usec;
	};
]]

local u64 = ffi.typeof("uint64_t")

-- ===== Utility functions =====
local function stderr_write(msg)
	io.stderr:write(msg)
end

local function shell_quote(s)
	return "'" .. s:gsub("'", "'\\''") .. "'"
end

local function exec_status(cmd)
	local ok, reason, code = os.execute(cmd)
	if type(ok) == "number" then return ok end
	if ok == true then return 0 end
	if reason == "exit" and type(code) == "number" then return code end
	return 1
end

local function trim(s)
	return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

-- ===== Base64 encoding =====
local b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

local function base64_encode(data)
	local result = {}
	local len = #data
	local i = 1
	while i <= len do
		local a = string.byte(data, i) or 0
		local b = string.byte(data, i + 1) or 0
		local c = string.byte(data, i + 2) or 0

		local n = a * 65536 + b * 256 + c

		local c1 = bit.rshift(n, 18) % 64
		local c2 = bit.rshift(n, 12) % 64
		local c3 = bit.rshift(n, 6) % 64
		local c4 = n % 64

		result[#result + 1] = b64chars:sub(c1 + 1, c1 + 1)
		result[#result + 1] = b64chars:sub(c2 + 1, c2 + 1)

		if i + 1 <= len then
			result[#result + 1] = b64chars:sub(c3 + 1, c3 + 1)
		else
			result[#result + 1] = "="
		end

		if i + 2 <= len then
			result[#result + 1] = b64chars:sub(c4 + 1, c4 + 1)
		else
			result[#result + 1] = "="
		end

		i = i + 3
	end
	return table.concat(result)
end

-- ===== Seed parsing =====
local function parse_uint64_dec(s)
	local value = ffi.new(u64, 0)
	for i = 1, #s do
		local c = s:byte(i)
		if c < 48 or c > 57 then return nil end
		value = value * 10 + (c - 48)
	end
	return value
end

local function parse_uint64_hex(s)
	local value = ffi.new(u64, 0)
	s = s:gsub("^0[xX]", "")
	for i = 1, #s do
		local c = s:byte(i)
		local digit
		if c >= 48 and c <= 57 then digit = c - 48
		elseif c >= 65 and c <= 70 then digit = c - 55
		elseif c >= 97 and c <= 102 then digit = c - 87
		else return nil end
		value = value * 16 + digit
	end
	return value
end

local function parse_seed(seed_str, warn_on_implicit_hex)
	if not seed_str then return nil end
	local seed = trim(seed_str)
	if seed == "" then return nil end
	if seed:match("^0[xX][0-9A-Fa-f]+$") then
		return parse_uint64_hex(seed)
	end
	if seed:match("^[0-9A-Fa-f]+$") and seed:match("[A-Fa-f]") then
		if warn_on_implicit_hex then
			stderr_write("Warning: seed '" .. seed .. "' looks like hex without 0x prefix; interpreting as hex\n")
		end
		return parse_uint64_hex(seed)
	end
	return parse_uint64_dec(seed)
end

local function u64_to_hex(value)
	if value == nil then return "0x0" end
	local digits = {}
	local tmp = ffi.new(u64, value)
	if tmp == 0 then return "0x0" end
	while tmp > 0 do
		local nibble = tonumber(tmp % 16)
		if nibble < 10 then
			digits[#digits + 1] = string.char(48 + nibble)
		else
			digits[#digits + 1] = string.char(87 + nibble)
		end
		tmp = tmp / 16
	end
	return "0x" .. table.concat(digits):reverse()
end

-- ===== PCG32 PRNG =====
local pcg_state = ffi.new(u64, 0)
local pcg_inc = ffi.new(u64, 1442695040888963407ULL)
local pcg_mult = ffi.new(u64, 6364136223846793005ULL)

local function pcg32_random()
	local old = pcg_state
	pcg_state = old * pcg_mult + pcg_inc
	local xorshifted = bit.rshift(bit.bxor(bit.rshift(old, 18), old), 27)
	local rot = tonumber(bit.rshift(old, 59))
	local x = tonumber(ffi.cast("uint32_t", xorshifted))
	local res = bit.bor(bit.rshift(x, rot), bit.lshift(x, bit.band(-rot, 31)))
	return tonumber(ffi.cast("uint32_t", res))
end

local function pcg32_seed(seed)
	pcg_state = ffi.new(u64, 0)
	pcg_inc = ffi.new(u64, 1442695040888963407ULL)
	pcg32_random()
	pcg_state = pcg_state + seed
	pcg32_random()
end

local function pcg32_range(start_val, end_val)
	local range = end_val - start_val + 1
	if range <= 1 then return start_val end
	local bound = 4294967296 - (4294967296 % range)
	while true do
		local r = pcg32_random()
		if r < bound then
			return start_val + (r % range)
		end
	end
end

-- Get uniform random in [0, 1)
local function pcg32_uniform()
	return pcg32_random() / 4294967296
end

-- ===== /dev/urandom random =====
local function get_random_bytes(num_bytes)
	local urandom = io.open("/dev/urandom", "rb")
	if urandom then
		local bytes = urandom:read(num_bytes)
		urandom:close()
		if bytes and #bytes == num_bytes then return bytes end
	end
	local random_dev = io.open("/dev/random", "rb")
	if random_dev then
		local bytes = random_dev:read(num_bytes)
		random_dev:close()
		if bytes and #bytes == num_bytes then return bytes end
	end
	local result = ""
	for i = 1, num_bytes do
		local time_val = os.time() + os.clock() * 1000000 + i * 12345
		result = result .. string.char(math.floor(time_val % 256))
	end
	return result
end

local function bytes_to_integer(bytes)
	local result = 0
	for i = 1, #bytes do
		result = result * 256 + string.byte(bytes, i)
	end
	return result
end

local function urandom_range(start_val, end_val)
	local span = end_val - start_val + 1
	if span <= 1 then return start_val end
	local bytes_needed = math.ceil(math.log(span) / math.log(256)) + 1
	local max_val = 256^bytes_needed
	local limit = math.floor(max_val / span) * span
	while true do
		local bytes = get_random_bytes(bytes_needed)
		local random_val = bytes_to_integer(bytes)
		if random_val < limit then
			return start_val + (random_val % span)
		end
	end
end

-- Get uniform random in [0, 1) from urandom
local function urandom_uniform()
	local bytes = get_random_bytes(4)
	return bytes_to_integer(bytes) / 4294967296
end

-- ===== Distribution functions =====

-- Normal distribution (Box-Muller) - for integer output with range
local function normal_random_int(start_val, end_val, rand_func)
	local range = end_val - start_val
	local result
	repeat
		local u1 = (rand_func(1, 1000000)) / 1000000
		local u2 = (rand_func(1, 1000000)) / 1000000
		if u1 < 0.000001 then u1 = 0.000001 end
		local z0 = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2)
		local random_number = start_val + (z0 * (range / 6)) + (range / 2)
		result = math.floor(random_number + 0.5)
	until result >= start_val and result <= end_val
	return result
end

-- Normal distribution with mean/stddev - returns float
local function normal_random_float(mean, stddev, uniform_func)
	local u1 = uniform_func()
	local u2 = uniform_func()
	if u1 < 0.000001 then u1 = 0.000001 end
	local z0 = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2)
	return mean + z0 * stddev
end

-- Exponential distribution (rate = 1 by default)
local function exponential_random(rate, uniform_func)
	local u = uniform_func()
	if u < 0.000001 then u = 0.000001 end
	return -math.log(u) / rate
end

-- Poisson distribution using inverse transform
local function poisson_random(lambda, uniform_func)
	local L = math.exp(-lambda)
	local k = 0
	local p = 1
	repeat
		k = k + 1
		p = p * uniform_func()
	until p <= L
	return k - 1
end

-- Log-normal distribution
local function lognormal_random(mu, sigma, uniform_func)
	local normal = normal_random_float(mu, sigma, uniform_func)
	return math.exp(normal)
end

-- Beta distribution using Gamma variates (rejection method for small params)
local function gamma_random(alpha, uniform_func)
	if alpha < 1 then
		-- Ahrens-Dieter method for alpha < 1
		local u = uniform_func()
		return gamma_random(1 + alpha, uniform_func) * math.pow(u, 1 / alpha)
	end
	-- Marsaglia and Tsang's method for alpha >= 1
	local d = alpha - 1/3
	local c = 1 / math.sqrt(9 * d)
	while true do
		local x, v
		repeat
			x = normal_random_float(0, 1, uniform_func)
			v = 1 + c * x
		until v > 0
		v = v * v * v
		local u = uniform_func()
		if u < 1 - 0.0331 * (x * x) * (x * x) then
			return d * v
		end
		if math.log(u) < 0.5 * x * x + d * (1 - v + math.log(v)) then
			return d * v
		end
	end
end

local function beta_random(alpha, beta_param, uniform_func)
	local x = gamma_random(alpha, uniform_func)
	local y = gamma_random(beta_param, uniform_func)
	return x / (x + y)
end

-- ===== Time-based seed generation =====
local function now_seed()
	local tv = ffi.new("struct timeval")
	if ffi.C.gettimeofday(tv, nil) == 0 then
		local seconds = ffi.new(u64, tv.tv_sec)
		local micros = ffi.new(u64, tv.tv_usec)
		return seconds * 1000000 + micros
	end
	return ffi.new(u64, os.time())
end

-- ===== Invocation name detection =====
local function get_invocation_name()
	local script_path = argv[0] or "random"
	return script_path:match("([^/]+)$") or "random"
end

-- ===== Help and about =====
local function print_about(invocation)
	if invocation == "nrandom" then
		print("Normally distributed random integer between bounds via Box-Muller sampling")
	elseif invocation == "drandom" then
		print("Deterministic PCG32-based RNG with optional seeding for reproducible numbers")
	else
		print("Unified random number generator: multiple distributions, stdin ops, output formats")
	end
end

local function print_help(invocation)
	print("Usage: " .. invocation .. " [options] [start] [end]")
	print("       echo 'items' | " .. invocation .. " --choose")
	print("       echo 'items' | " .. invocation .. " --shuffle")
	print("")
	print("Unified random number generator with multiple modes and distributions.")
	print("")
	print("Distributions (mutually exclusive):")
	print("  (default)           Uniform distribution")
	print("  -n, --normalized    Normal (Gaussian) via Box-Muller")
	print("      --exponential   Exponential distribution (rate=1)")
	print("      --poisson       Poisson distribution (use --mean for λ)")
	print("      --log-normal    Log-normal distribution")
	print("      --beta          Beta distribution (use --alpha, --beta-param)")
	print("")
	print("Stdin operations:")
	print("      --choose        Pick one random item from stdin")
	print("      --shuffle       Shuffle all items from stdin")
	print("      --weighted      Pick from weighted stdin (format: value:weight)")
	print("")
	print("Options:")
	print("  -a, --about         Show a short description")
	print("  -b, --binaryoutput  Output binary bytes")
	print("  -c, --count N       Output N numbers (default: 1, or 1024 with -b)")
	print("  -d, --deterministic Use PCG32 PRNG (reproducible with seed)")
	print("      --delimiter S   Set delimiter for output/input (default: newline/$IFS)")
	print("  -h, --help          Show this help message")
	print("      --hex           Output as hexadecimal")
	print("      --base64        Output as base64 (for binary)")
	print("      --seed N        Set seed (implies -d)")
	print("      --mean M        Set mean for normal/poisson")
	print("      --stddev S      Set stddev for normal/log-normal")
	print("      --alpha A       Set alpha for beta distribution")
	print("      --beta-param B  Set beta for beta distribution")
	print("      --test          Run the test suite")
	print("")
	print("Symlink behavior:")
	print("  'nrandom' → implies --normalized")
	print("  'drandom' → implies --deterministic")
	print("")
	print("Environment variables:")
	print("  DRANDOM_CONTEXT   Session identifier for state persistence (default: PPID)")
	print("  DRANDOM_SEED      Seed value (overrides state file, implies -d)")
	print("  DRANDOM_STATE_HOME  Directory for state files (default: /tmp)")
	print("")
	print("State persistence (deterministic mode):")
	print("  State is saved per-session so sequences continue across calls.")
	print("  The session is identified by DRANDOM_CONTEXT or parent PID.")
	print("  NOTE: Pipes and $() subshells change the parent PID. For reliable")
	print("  state in scripts, add to your shell config:")
	print("    export DRANDOM_CONTEXT=$$")
	print("")
	print("Examples:")
	print("  random                    # Uniform random 0-99")
	print("  random -n --mean 50 --stddev 10  # Normal, custom params")
	print("  random -d --seed 42       # Deterministic")
	print("  random --hex -c 5         # 5 hex numbers")
	print("  echo -e 'a\\nb\\nc' | random --choose")
	print("  echo 'rare:1,common:10' | random --weighted --delimiter ','")
end

-- ===== State persistence =====
local function get_context()
	local env_ctx = os.getenv("DRANDOM_CONTEXT")
	if env_ctx and env_ctx ~= "" then return env_ctx end
	local ok, ppid = pcall(function() return ffi.C.getppid() end)
	if ok and ppid then return tostring(ppid) end
	return tostring(os.getenv("PPID") or "unknown")
end

local function get_user()
	local user = os.getenv("USER")
	if user and user ~= "" then return user end
	return "unknown"
end

local function read_seed_file(path)
	local f = io.open(path, "r")
	if not f then return nil end
	local line = f:read("*l")
	f:close()
	if not line then return nil end
	return parse_seed(line, false)
end

local function write_seed_file(path, value)
	local f = io.open(path, "w")
	if not f then return end
	f:write(u64_to_hex(value))
	f:write("\n")
	f:close()
end

-- ===== Stdin reading =====
local function read_stdin_items(delimiter)
	local content = io.read("*a")
	if not content or content == "" then return {} end
	content = trim(content)
	if content == "" then return {} end

	local items = {}
	if delimiter == "\n" then
		for line in content:gmatch("[^\n]+") do
			table.insert(items, line)
		end
	else
		for item in content:gmatch("[^" .. delimiter:gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])", "%%%1") .. "]+") do
			table.insert(items, trim(item))
		end
	end
	return items
end

-- Fisher-Yates shuffle
local function shuffle_array(arr, rand_func)
	local n = #arr
	for i = n, 2, -1 do
		local j = rand_func(1, i)
		arr[i], arr[j] = arr[j], arr[i]
	end
	return arr
end

-- ===== Argument parsing =====
local function parse_args()
	local invocation = get_invocation_name()

	local options = {
		deterministic = (invocation == "drandom"),
		normalized = (invocation == "nrandom"),
		exponential = false,
		poisson = false,
		log_normal = false,
		beta = false,
		binary_output = false,
		hex_output = false,
		base64_output = false,
		delimiter = nil,  -- nil means use default (newline or $IFS)
		choose = false,
		shuffle = false,
		weighted = false,
		count = nil,
		seed = nil,
		seed_provided = false,
		start_val = nil,
		end_val = nil,
		mean = nil,
		stddev = nil,
		alpha = nil,
		beta_param = nil,
	}

	local i = 1
	local positionals = {}

	while i <= #argv do
		local arg_val = argv[i]
		if arg_val == "--about" or arg_val == "-a" then
			print_about(invocation)
			os.exit(0)
		elseif arg_val == "--help" or arg_val == "-h" then
			print_help(invocation)
			os.exit(0)
		elseif arg_val == "--test" then
			local test_file = (os.getenv("HOME") or "") .. "/dotfiles/bin/test/random_test"
			local f = io.open(test_file, "r")
			if f then
				f:close()
				local cmd = "FAST=1 " .. shell_quote(test_file) .. " >/dev/null"
				local status = exec_status(cmd)
				os.exit(status)
			else
				stderr_write("Test file not found: " .. test_file .. "\n")
				os.exit(1)
			end
		elseif arg_val == "--deterministic" or arg_val == "-d" then
			options.deterministic = true
		elseif arg_val == "--normalized" or arg_val == "-n" then
			options.normalized = true
		elseif arg_val == "--exponential" then
			options.exponential = true
		elseif arg_val == "--poisson" then
			options.poisson = true
		elseif arg_val == "--log-normal" then
			options.log_normal = true
		elseif arg_val == "--beta" then
			options.beta = true
		elseif arg_val == "--binaryoutput" or arg_val == "-b" then
			options.binary_output = true
		elseif arg_val == "--hex" then
			options.hex_output = true
		elseif arg_val == "--base64" then
			options.base64_output = true
		elseif arg_val == "--choose" then
			options.choose = true
		elseif arg_val == "--shuffle" then
			options.shuffle = true
		elseif arg_val == "--weighted" then
			options.weighted = true
		elseif arg_val == "--delimiter" or arg_val == "--delim" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --delimiter requires a value\n")
				os.exit(1)
			end
			options.delimiter = argv[i]
		elseif arg_val == "--count" or arg_val == "-c" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --count requires a number\n")
				os.exit(1)
			end
			options.count = tonumber(argv[i])
			if not options.count then
				stderr_write("Error: --count value must be a number\n")
				os.exit(1)
			end
		elseif arg_val == "--seed" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --seed requires a value\n")
				os.exit(1)
			end
			options.seed = parse_seed(argv[i], true)
			options.seed_provided = true
			options.deterministic = true
		elseif arg_val == "--mean" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --mean requires a number\n")
				os.exit(1)
			end
			options.mean = tonumber(argv[i])
			if not options.mean then
				stderr_write("Error: --mean value must be a number\n")
				os.exit(1)
			end
		elseif arg_val == "--stddev" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --stddev requires a number\n")
				os.exit(1)
			end
			options.stddev = tonumber(argv[i])
			if not options.stddev then
				stderr_write("Error: --stddev value must be a number\n")
				os.exit(1)
			end
		elseif arg_val == "--alpha" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --alpha requires a number\n")
				os.exit(1)
			end
			options.alpha = tonumber(argv[i])
			if not options.alpha then
				stderr_write("Error: --alpha value must be a number\n")
				os.exit(1)
			end
		elseif arg_val == "--beta-param" then
			i = i + 1
			if i > #argv then
				stderr_write("Error: --beta-param requires a number\n")
				os.exit(1)
			end
			options.beta_param = tonumber(argv[i])
			if not options.beta_param then
				stderr_write("Error: --beta-param value must be a number\n")
				os.exit(1)
			end
		else
			table.insert(positionals, arg_val)
		end
		i = i + 1
	end

	-- Parse positional arguments
	if #positionals >= 1 then
		options.start_val = tonumber(positionals[1])
		if not options.start_val then
			stderr_write("Error: start value must be a number\n")
			os.exit(1)
		end
	end
	if #positionals >= 2 then
		options.end_val = tonumber(positionals[2])
		if not options.end_val then
			stderr_write("Error: end value must be a number\n")
			os.exit(1)
		end
	end

	-- Validate: only one distribution type
	local dist_count = 0
	if options.normalized then dist_count = dist_count + 1 end
	if options.exponential then dist_count = dist_count + 1 end
	if options.poisson then dist_count = dist_count + 1 end
	if options.log_normal then dist_count = dist_count + 1 end
	if options.beta then dist_count = dist_count + 1 end
	if dist_count > 1 then
		stderr_write("Error: only one distribution type can be specified\n")
		os.exit(1)
	end

	-- Default delimiter from $IFS or newline
	if options.delimiter == nil then
		local ifs = os.getenv("IFS")
		if ifs and #ifs > 0 then
			options.delimiter = ifs:sub(1, 1)
		else
			options.delimiter = "\n"
		end
	end

	return options, positionals, invocation
end

-- ===== Main =====
local function main()
	local options, positionals, invocation = parse_args()

	-- Setup RNG first (needed for all operations)
	local rand_func, uniform_func

	if options.deterministic then
		local env_seed_raw = os.getenv("DRANDOM_SEED")
		local env_seed_set = env_seed_raw ~= nil and env_seed_raw ~= ""

		-- Set up state file paths (needed for both explicit seed and auto-seed)
		local state_home = os.getenv("DRANDOM_STATE_HOME") or "/tmp"
		local context = get_context()
		local state_dir = state_home .. "/drandom/" .. get_user()
		local seed_file = state_dir .. "/" .. context .. ".seed"

		if options.seed_provided then
			pcg32_seed(options.seed or ffi.new(u64, 0))
			-- Save state so subsequent calls continue from this seed
			options._save_state = true
			options._state_dir = state_dir
			options._seed_file = seed_file
		elseif env_seed_set then
			local env_seed = parse_seed(env_seed_raw, true)
			pcg32_seed(env_seed or ffi.new(u64, 0))
		else
			local persisted = read_seed_file(seed_file)
			if persisted then
				pcg_state = persisted
			else
				local random_seed = now_seed()
				pcg32_seed(random_seed)
				stderr_write("(seed: " .. u64_to_hex(random_seed) .. ")\n")
			end

			options._save_state = true
			options._state_dir = state_dir
			options._seed_file = seed_file
		end

		rand_func = pcg32_range
		uniform_func = pcg32_uniform
	else
		rand_func = urandom_range
		uniform_func = urandom_uniform
	end

	-- Handle stdin operations
	if options.choose then
		local items = read_stdin_items(options.delimiter)
		if #items == 0 then
			stderr_write("Error: no items to choose from\n")
			os.exit(1)
		end
		local idx = rand_func(1, #items)
		print(items[idx])
		if options._save_state then
			os.execute("mkdir -p " .. shell_quote(options._state_dir) .. " 2>/dev/null")
			write_seed_file(options._seed_file, pcg_state)
		end
		return
	end

	if options.shuffle then
		local items = read_stdin_items(options.delimiter)
		if #items == 0 then
			stderr_write("Error: no items to shuffle\n")
			os.exit(1)
		end
		shuffle_array(items, rand_func)
		for _, item in ipairs(items) do
			print(item)
		end
		if options._save_state then
			os.execute("mkdir -p " .. shell_quote(options._state_dir) .. " 2>/dev/null")
			write_seed_file(options._seed_file, pcg_state)
		end
		return
	end

	if options.weighted then
		local items = read_stdin_items(options.delimiter)
		if #items == 0 then
			stderr_write("Error: no items for weighted selection\n")
			os.exit(1)
		end

		local weighted_items = {}
		local total_weight = 0
		for _, item in ipairs(items) do
			local value, weight = item:match("^(.+):(%d+)$")
			if not value or not weight then
				stderr_write("Error: weighted item must be in format 'value:weight', got: " .. item .. "\n")
				os.exit(1)
			end
			weight = tonumber(weight)
			table.insert(weighted_items, {value = value, weight = weight})
			total_weight = total_weight + weight
		end

		local pick = rand_func(1, total_weight)
		local cumulative = 0
		for _, wi in ipairs(weighted_items) do
			cumulative = cumulative + wi.weight
			if pick <= cumulative then
				print(wi.value)
				break
			end
		end

		if options._save_state then
			os.execute("mkdir -p " .. shell_quote(options._state_dir) .. " 2>/dev/null")
			write_seed_file(options._seed_file, pcg_state)
		end
		return
	end

	-- Regular number generation
	local start_val, end_val, count
	local show_defaults_msg = false

	if options.binary_output then
		start_val = options.start_val or 0
		end_val = options.end_val or 255
		count = options.count or 1024

		if start_val < 0 then
			stderr_write("Error: start value must be >= 0 for binary output\n")
			os.exit(1)
		end
		if end_val > 255 then
			stderr_write("Error: end value must be <= 255 for binary output\n")
			os.exit(1)
		end
	else
		if options.start_val == nil and options.end_val == nil then
			show_defaults_msg = true
		end
		start_val = options.start_val or 0
		end_val = options.end_val or 99
		count = options.count or 1
	end

	-- Validate range for integer distributions
	if not (options.exponential or options.poisson or options.log_normal or options.beta) then
		if start_val > end_val then
			stderr_write("Error: start value must be less than or equal to end value\n")
			os.exit(1)
		end
	end

	if show_defaults_msg and not options.binary_output then
		stderr_write("(with a start of 0 and an end of 99)\n")
	end

	-- Generate values
	local values = {}
	local binary_data = {}

	for _ = 1, count do
		local value

		if options.exponential then
			value = exponential_random(1, uniform_func)
		elseif options.poisson then
			local lambda = options.mean or 1
			value = poisson_random(lambda, uniform_func)
		elseif options.log_normal then
			local mu = options.mean or 0
			local sigma = options.stddev or 1
			value = lognormal_random(mu, sigma, uniform_func)
		elseif options.beta then
			local alpha = options.alpha or 2
			local beta_p = options.beta_param or 2
			value = beta_random(alpha, beta_p, uniform_func)
		elseif options.normalized then
			if options.mean and options.stddev then
				-- Use custom mean/stddev, output as float rounded to int
				value = math.floor(normal_random_float(options.mean, options.stddev, uniform_func) + 0.5)
			else
				value = normal_random_int(start_val, end_val, rand_func)
			end
		else
			value = rand_func(start_val, end_val)
		end

		if options.binary_output then
			table.insert(binary_data, string.char(math.floor(value) % 256))
		else
			table.insert(values, value)
		end
	end

	-- Output
	if options.binary_output then
		local data = table.concat(binary_data)
		if options.base64_output then
			print(base64_encode(data))
		elseif options.hex_output then
			local hex = {}
			for i = 1, #data do
				hex[i] = string.format("%02x", string.byte(data, i))
			end
			print(table.concat(hex))
		else
			io.stdout:write(data)
		end
	else
		local output_delimiter = options.delimiter
		if options.hex_output then
			for i, v in ipairs(values) do
				if i > 1 and output_delimiter ~= "\n" then
					io.stdout:write(output_delimiter)
				end
				local formatted
				if type(v) == "number" and v == math.floor(v) then
					formatted = string.format("%x", math.floor(v))
				else
					formatted = tostring(v)
				end
				if output_delimiter == "\n" then
					print(formatted)
				else
					io.stdout:write(formatted)
				end
			end
			if output_delimiter ~= "\n" then
				print("")
			end
		else
			for i, v in ipairs(values) do
				if i > 1 and output_delimiter ~= "\n" then
					io.stdout:write(output_delimiter)
				end
				local formatted
				if type(v) == "number" then
					if v == math.floor(v) then
						formatted = tostring(math.floor(v))
					else
						formatted = string.format("%.6f", v)
					end
				else
					formatted = tostring(v)
				end
				if output_delimiter == "\n" then
					print(formatted)
				else
					io.stdout:write(formatted)
				end
			end
			if output_delimiter ~= "\n" then
				print("")
			end
		end
	end

	-- Save state if needed
	if options._save_state then
		os.execute("mkdir -p " .. shell_quote(options._state_dir) .. " 2>/dev/null")
		write_seed_file(options._seed_file, pcg_state)
	end
end

main()
