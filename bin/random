#!/usr/bin/env yuerun

-- Get random bytes from /dev/urandom (or fallback)
get_random_bytes = (num_bytes) ->
	-- Try to read from /dev/urandom first (preferred)
	urandom = io.open("/dev/urandom", "rb")
	if urandom
		bytes = urandom\read(num_bytes)
		urandom\close!
		return bytes if bytes and #bytes == num_bytes

	-- Fallback: try /dev/random (may block, but more entropy)
	random_dev = io.open("/dev/random", "rb")
	if random_dev
		bytes = random_dev\read(num_bytes)
		random_dev\close!
		return bytes if bytes and #bytes == num_bytes

	-- Final fallback: generate pseudo-random bytes from time
	-- This shouldn't happen on Unix-like systems, but just in case
	result = ""
	for i = 1, num_bytes
		-- Use current time with some variation
		time_val = os.time! + os.clock! * 1000000 + i * 12345
		byte_val = math.floor(time_val % 256)
		result = result .. string.char(byte_val)
	result

-- Convert bytes to integer
bytes_to_integer = (bytes) ->
	result = 0
	for i = 1, #bytes
		result = result * 256 + string.byte(bytes, i)
	result

-- Main random function using /dev/urandom directly
random = (start_val = 0, end_val = 99) ->
	span = end_val - start_val + 1
	return start_val if span <= 1

	-- Use rejection sampling with /dev/urandom to get uniform distribution
	-- We need enough bytes to represent the range without bias
	bytes_needed = math.ceil(math.log(span) / math.log(256)) + 1  -- Extra byte to reduce bias
	max_val = 256^bytes_needed
	limit = math.floor(max_val / span) * span

	-- Rejection sampling loop
	while true
		bytes = get_random_bytes(bytes_needed)
		random_val = bytes_to_integer(bytes)

		-- Accept value if it's within the unbiased range
		if random_val < limit
			return start_val + (random_val % span)
		-- Otherwise, try again (rejection sampling)

-- Show help
show_help = ->
	print "Usage: random [options] [start] [end]"
	print ""
	print "High-quality uniform random number generator using system entropy."
	print "Outputs random integers between <start> and <end> (inclusive)."
	print "If <start> is not specified, it defaults to 0"
	print "If <end> is not specified, it defaults to 99"
	print ""
	print "Sources entropy directly from /dev/urandom (with /dev/random fallback)"
	print "and uses rejection sampling for perfect uniform distribution."
	print ""
	print "Options:"
	print "  -a, --about         Show a short description"
	print "  -b, --binaryoutput  Output binary bytes (default 0-255, custom range allowed)"
	print "  -c, --count N       Output N numbers (default: 1, or 1024 with -b)"
	print "  -h, --help          Show this help message"
	print "      --test          Run the test suite"

-- Show a one-line description
show_about = ->
	print "Uniform random integer generator using /dev/urandom with rejection sampling"

-- Test function
run_test = ->
	test_file = "#{os.getenv('HOME')}/dotfiles/bin/test/random_test"
	result = os.execute("#{test_file} >/dev/null")
	os.exit(result and 0 or 1)

-- Parse command line arguments
parse_args = ->
	options = {
		binary_output: false
		count: nil  -- nil means use default (1 or 1024 for binary)
		start: nil
		end_val: nil
	}

	i = 1
	positionals = {}

	while i <= #arg
		switch arg[i]
			when "--about", "-a"
				show_about!
				os.exit 0
			when "--help", "-h"
				show_help!
				os.exit 0
			when "--test"
				run_test!
				os.exit 0
			when "--binaryoutput", "-b"
				options.binary_output = true
			when "--count", "-c"
				i += 1
				if i > #arg
					io.stderr\write "Error: --count requires a number argument\n"
					os.exit 1
				options.count = tonumber arg[i]
				unless options.count
					io.stderr\write "Error: --count value must be a number\n"
					os.exit 1
			else
				-- Collect positional arguments
				table.insert positionals, arg[i]
		i += 1

	-- Parse positional arguments as start and end
	if #positionals >= 1
		options.start = tonumber positionals[1]
		unless options.start
			io.stderr\write "Error: start value must be a number\n"
			os.exit 1
	if #positionals >= 2
		options.end_val = tonumber positionals[2]
		unless options.end_val
			io.stderr\write "Error: end value must be a number\n"
			os.exit 1

	options

-- Output a single byte as binary
write_byte = (value) ->
	io.stdout\write string.char value

-- Main execution logic
main = ->
	-- Parse arguments
	options = parse_args!

	-- Set defaults based on mode
	if options.binary_output
		-- Binary mode: default range 0-255, but allow custom range within bounds
		options.start = options.start or 0
		options.end_val = options.end_val or 255
		options.count = options.count or 1024

		-- Validate binary range is within 0-255
		if options.start < 0
			io.stderr\write "Error: start value must be >= 0 for binary output\n"
			os.exit 1
		if options.end_val > 255
			io.stderr\write "Error: end value must be <= 255 for binary output\n"
			os.exit 1
	else
		-- Normal mode: use provided or default range
		-- Show note if using default range (before applying defaults)
		if options.start == nil and options.end_val == nil
			io.stderr\write "(with a start of 0 and an end of 99)\n"

		options.start = options.start or 0
		options.end_val = options.end_val or 99
		options.count = options.count or 1

	-- Validate start <= end (applies to both modes)
	if options.start > options.end_val
		io.stderr\write "Error: start value must be less than or equal to end value\n"
		os.exit 1

	-- Generate output
	if options.binary_output
		-- Binary output mode
		for _ = 1, options.count
			write_byte random options.start, options.end_val
	else
		-- Text output mode
		for _ = 1, options.count
			print random options.start, options.end_val

-- Run main function
main!
