#!/usr/bin/env bash

export DEFAULT_TABSIZE=2

zfs-status() {
	# bail fast on systems without ZFS
	if ! command -v zfs >/dev/null 2>&1 || ! command -v zpool >/dev/null 2>&1; then
		echo "zfs-status: zfs not found on this system." >&2
		return 127
	fi

	local pools=() p tsz=14 color=false
	local ESC=$'\033[' RESET="" DIM="" ULINE="" NULINE="" GREEN="" RED="" YELLOW=""

	# color only if stdout is a TTY
	if [ -t 1 ]; then
		color=true
		RESET="${ESC}0m"; DIM="${ESC}2m"; ULINE="${ESC}4m"; NULINE="${ESC}24m"
		GREEN="${ESC}32m"; RED="${ESC}31m"; YELLOW="${ESC}33m"
		tabs -${tsz} 2>/dev/null || true
	fi

	# helpers
	yesno_color() { case "$1" in on|yes|enabled|true|up) $color && printf "%s%s%s" "$GREEN" "$1" "$RESET" || printf "%s" "$1" ;;
															 off|no|disabled|false|down) $color && printf "%s%s%s" "$RED" "$1" "$RESET" || printf "%s" "$1" ;;
															 *) printf "%s" "$1" ;; esac; }
	comp_color() { case "$1" in on) $color && printf "%s%s%s" "$GREEN" "$1" "$RESET" || printf "%s" "$1" ;;
															off) $color && printf "%s%s%s" "$RED" "$1" "$RESET"  || printf "%s" "$1" ;;
															*) printf "%s" "$1" ;; esac; }
	health_color() { case "$1" in ONLINE)   $color && printf "%sONLINE%s" "$GREEN" "$RESET" || printf "ONLINE" ;;
															 DEGRADED) $color && printf "%sDEGRADED%s" "$YELLOW" "$RESET" || printf "DEGRADED" ;;
															 OFFLINE|FAULTED|UNAVAIL|REMOVED|SUSPENDED)
																					$color && printf "%s%s%s" "$RED" "$1" "$RESET" || printf "%s" "$1" ;;
															 *)         printf "%s" "$1" ;; esac; }
	features_msg() { local pool="$1"
		if zpool status "$pool" | grep -q 'features are not enabled'; then
			$color && printf "%snot fully enabled%s" "$RED" "$RESET" || printf "not fully enabled"
		else
			$color && printf "%sall features enabled%s" "$GREEN" "$RESET" || printf "all features enabled"
		fi; }
	ratio_color() { local r="${1%x}"
		if $color && awk -v r="$r" 'BEGIN{exit (r+0 < 1.10)?0:1}'; then printf "%s%s%s" "$RED" "$1" "$RESET"; else printf "%s" "$1"; fi; }
	frag_color() { local f="${1%\%}"
		if $color && awk -v f="$f" 'BEGIN{exit (f+0 >= 60)?0:1}'; then 
			printf "%s%s%s" "$RED" "$1" "$RESET"
		elif $color && awk -v f="$f" 'BEGIN{exit (f+0 >= 30)?0:1}'; then 
			printf "%s%s%s" "$YELLOW" "$1" "$RESET"
		else 
			printf "%s" "$1"
		fi; }
	cap_color() { local c="${1%\%}"
		if $color && awk -v c="$c" 'BEGIN{exit (c+0 >= 80)?0:1}'; then 
			printf "%s%s%s" "$RED" "$1" "$RESET"
		else 
			printf "%s" "$1"
		fi; }
	scan_color() { 
		case "$1" in 
			"scrub repaired 0B"*" 0 errors"*) 
				$color && printf "%s%s%s" "$GREEN" "$1" "$RESET" || printf "%s" "$1" ;;
			*) 
				$color && printf "%s%s%s" "$RED" "$1" "$RESET" || printf "%s" "$1" ;;
		esac
	}
	errors_color() { if [ "$1" = "No known data errors" ]; then $color && printf "%s%s%s" "$GREEN" "$1" "$RESET" || printf "%s" "$1"; else $color && printf "%s%s%s" "$RED" "$1" "$RESET" || printf "%s" "$1"; fi; }
	resolve_legacy_mount() { 
		local ds="$1" mp
		mp="$(findmnt -S "$ds" -no TARGET 2>/dev/null | head -1 | tr -d '\n')"
		if [ -n "$mp" ] && [ "$mp" != "$ds" ]; then
			printf "%s" "$mp"
		else
			printf "legacy"
		fi
	}

	if [ "$#" -gt 0 ]; then pools=("$@"); else mapfile -t pools < <(zpool list -H -o name); fi
	[ "${#pools[@]}" -eq 0 ] && { echo "No pools found." >&2; $color && tabs -$DEFAULT_TABSIZE 2>/dev/null; return 1; }

	for p in "${pools[@]}"; do
		# left-aligned labels, exactly one tab
		read -r SIZE ALLOC FREE CAP HEALTH < <(zpool list -H -o size,alloc,free,cap,health "$p")
		scan="$(zpool status "$p" | awk -F'scan: ' '/^\s*scan:/{print $2; exit}')" ; [ -z "$scan" ] && scan="none recorded"
		errs="$(zpool status "$p" | awk '/^errors:/{sub(/^errors: /,""); print; exit}')"
		autotrim="$(zpool get -H -o value autotrim "$p" 2>/dev/null || echo "?")"
		featmsg="$(features_msg "$p")"
		active_features="$(zpool get all "$p" | rg --color=never "$p +feature@[a-z0-9_]+ +active" | awk '$2 ~ /feature@/ {sub(/feature@/,"",$2); print $2}' | paste -sd, -)"
		dedup_active=false
		if echo "$active_features" | grep -q "dedup"; then dedup_active=true; fi
		pool_frag="$(zpool get -H -o value fragmentation "$p" 2>/dev/null || echo "0%")"

		$color && printf "%sPool%s\t%s\n" "$DIM" "$RESET" "$p" || printf "Pool\t%s\n" "$p"
		$color && printf "%sState%s\t%s\n" "$DIM" "$RESET" "$(health_color "$HEALTH")" || printf "State\t%s\n" "$(health_color "$HEALTH")"
		$color && printf "%sScan%s\t%s\n" "$DIM" "$RESET" "$(scan_color "$scan")" || printf "Scan\t%s\n" "$(scan_color "$scan")"
		$color && printf "%sCapacity%s\t%s / %s  (%s)  free %s\n" "$DIM" "$RESET" "$ALLOC" "$SIZE" "$(cap_color "$CAP")" "$FREE" || printf "Capacity\t%s / %s  (%s)  free %s\n" "$ALLOC" "$SIZE" "$CAP" "$FREE"
		$color && printf "%sAutotrim%s\t%s\n" "$DIM" "$RESET" "$(yesno_color "$autotrim")" || printf "Autotrim\t%s\n" "$(yesno_color "$autotrim")"
		$color && printf "%sFeatures%s\t%s\n" "$DIM" "$RESET" "$featmsg" || printf "Features\t%s\n" "$featmsg"
		$color && printf "%sâ””Active%s\t%s\n" "$DIM" "$RESET" "$active_features" || printf "Active\t%s\n" "$active_features"
		$color && printf "%sFragmentation%s\t%s\n" "$DIM" "$RESET" "$(frag_color "$pool_frag")" || printf "Fragmentation\t%s\n" "$pool_frag"
		[ -n "$errs" ] && { $color && printf "%sErrors%s\t%s\n" "$DIM" "$RESET" "$(errors_color "$errs")" || printf "Errors\t%s\n" "$(errors_color "$errs")"; }

		# header
		local header="name\tcompression\tlogical\tphysical\tratio"
		$dedup_active && header="${header}\tdedupratio"
		header="${header}\tlegacy\tmountpoint"
		
		$color && printf "%sDatasets:%s\n" "$DIM" "$RESET" || printf "Datasets:\n"
		$color && printf "%s%b%s\n" "$ULINE" "$header" "$NULINE" || printf "%b\n" "$header"

		# rows (depth=1), tight loop; no stray prints
		if $dedup_active; then
			while IFS=$'\t' read -r name comp lused used ratio dedupratio mnt; do
				local legacy="no" mp="$mnt"
				if [ "$mnt" = "legacy" ]; then 
					legacy="yes"
					mp="$(resolve_legacy_mount "$name")"
				fi
				local comp_out ratio_out legacy_out
				comp_out="$(comp_color "$comp")"
				ratio_out="$(ratio_color "$ratio")"
				legacy_out="$(yesno_color "$legacy")"
				printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
					"$name" "$comp_out" "$lused" "$used" "$ratio_out" "$dedupratio" "$legacy_out" "$mp"
			done < <(zfs list -H -r -d 1 -o name,compression,logicalused,used,compressratio,dedupratio,mountpoint "$p")
		else
			while IFS=$'\t' read -r name comp lused used ratio mnt; do
				local legacy="no" mp="$mnt"
				if [ "$mnt" = "legacy" ]; then 
					legacy="yes"
					mp="$(resolve_legacy_mount "$name")"
				fi
				local comp_out ratio_out legacy_out
				comp_out="$(comp_color "$comp")"
				ratio_out="$(ratio_color "$ratio")"
				legacy_out="$(yesno_color "$legacy")"
				printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
					"$name" "$comp_out" "$lused" "$used" "$ratio_out" "$legacy_out" "$mp"
			done < <(zfs list -H -r -d 1 -o name,compression,logicalused,used,compressratio,mountpoint "$p")
		fi

		# Check for performance warning conditions
		local frag_num="${pool_frag%\%}"
		local cap_num="${CAP%\%}"
		if awk -v f="$frag_num" -v c="$cap_num" 'BEGIN{exit (f+0 > 30 && c+0 > 80)?0:1}'; then
			echo
			$color && printf "%sWARNING: High fragmentation (%s) combined with low free space (%s available) may cause degraded performance. Consider freeing space or defragmenting.%s\n" "$RED" "$pool_frag" "$((100-cap_num))%" "$RESET" || printf "WARNING: High fragmentation (%s) combined with low free space (%s available) may cause degraded performance. Consider freeing space or defragmenting.\n" "$pool_frag" "$((100-cap_num))%"
		fi

		echo
	done

	$color && tabs -${DEFAULT_TABSIZE:-2}
}

# Run the function if this script is executed directly
if ! (return 0 2>/dev/null); then
	# Check if we are running tests
	if [ "$1" = "--test" ]; then
		# Run tests from the test file
		"$HOME/dotfiles/bin/test/$(basename "${0##\-}")_test"
	else
		# If called directly, pass all arguments to the function
		"$(basename "${0##\-}")" "$@"
	fi
fi
