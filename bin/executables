#!/usr/bin/env bash


# Format executable name, annotating symlinks for clarity
format_executable_display() {
	local entry="$1"
	local name
	name=$(basename "$entry")
	if [[ -L "$entry" ]]; then
		printf '%s (symlinked)' "$name"
	else
		printf '%s' "$name"
	fi
}

# Determine if the provided path is executable or resolves to an executable target
is_executable_entry() {
	local entry="$1"
	[[ -z "$entry" ]] && return 1
	if [[ -x "$entry" && ! -d "$entry" ]]; then
		return 0
	fi
	if [[ -L "$entry" ]]; then
		local target
		if ! target=$(readlink -f "$entry" 2>/dev/null); then
			return 1
		fi
		[[ -n "$target" && -x "$target" && ! -d "$target" ]]
		return
	fi
	return 1
}

# Print out the names of all executables available in your PATH
executables() {
	[ -n "${EDIT}" ] && unset EDIT && edit_function "${FUNCNAME[0]}" "$BASH_SOURCE" && return
	
	local show_scripts=false
	local path_filters=()
	local results=()
	
	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
			--scripts) show_scripts=true ; shift ;;
			-h|--help) 
				echo "executables - Print out the names of all executables available in your PATH"
				echo ""
				echo "Usage: executables [OPTIONS] [PATH ...]"
				echo ""
				echo "OPTIONS:"
				echo "  --scripts    Only show script files"
				echo "  -h, --help  Show this help message"
				echo "  -a, --about  Show brief description"
				echo ""
				echo "If one or more PATH values are provided, results are limited to executables"
				echo "found within those directories."
				return 0 ;;
			-a|--about)
				echo "Print out the names of all executables available in your PATH"
				return 0 ;;
			*)
				if [[ -d "$1" ]]; then
					local resolved_path
					if ! resolved_path=$(cd "$1" 2>/dev/null && pwd -P); then
						warn "Unable to resolve path: $1" >&2
						return 1
					fi
					path_filters+=("$resolved_path")
					shift
				else
					warn "Unknown option or invalid path: $1" >&2
					return 1
				fi
				;;
		esac
	done

	# Create a temporary directory for our search paths
	local search_paths=()
	local nonexistent_paths=()
	
	# Process PATH into valid directories
	IFS=: read -ra path_dirs <<<"$PATH"
	for dir in "${path_dirs[@]}"; do
		if [[ -d "$dir" ]]; then
			search_paths+=("$dir")
		else
			nonexistent_paths+=("$dir")
		fi
	done

	if [[ ${#path_filters[@]} -gt 0 ]]; then
		local filtered_paths=()
		for dir in "${search_paths[@]}"; do
			local resolved_dir
			if ! resolved_dir=$(cd "$dir" 2>/dev/null && pwd -P); then
				continue
			fi
			for filter_path in "${path_filters[@]}"; do
				if [[ "$resolved_dir" == "$filter_path" || "$resolved_dir" == "$filter_path"/* ]]; then
					filtered_paths+=("$dir")
					break
				fi
			done
		done
		search_paths=("${filtered_paths[@]}")
	fi

	# Use fd for faster searching if available
	if command -v fd >/dev/null 2>&1; then
		# Build base fd command
		local fd_cmd=(
			--max-depth 1
			--min-depth 1
			--type f
			--type l
			--absolute-path
			--print0
		)

		# Add search paths - use fd's --search-path for parallel processing
		if [[ ${#search_paths[@]} -gt 0 ]]; then
			# Build fd command with multiple --search-path arguments
			local search_path_args=()
			for path in "${search_paths[@]}"; do
				search_path_args+=(--search-path "$path")
			done
			
			while IFS= read -r -d $'\0' exe; do
				if ! is_executable_entry "$exe"; then
					continue
				fi
				if $show_scripts && ! file -L "$exe" 2>/dev/null | grep -q "script"; then
					continue
				fi
				results+=("$(format_executable_display "$exe")")
			done < <(fd "${fd_cmd[@]}" "${search_path_args[@]}" . 2>/dev/null)
		fi
	else
		# Fallback to find if fd is not available
		for dir in "${search_paths[@]}"; do
			local find_cmd
			if find /tmp -executable 2>/dev/null | grep -q .; then
				find_cmd='find -L "$dir" -mindepth 1 -maxdepth 1 -not -type d -executable -print 2>/dev/null'
			else
				find_cmd='find -L "$dir" -mindepth 1 -maxdepth 1 -not -type d -perm +111 -print 2>/dev/null'
			fi

			while IFS= read -r exe; do
				[[ -z "$exe" ]] && continue
				if ! is_executable_entry "$exe"; then
					continue
				fi
				if $show_scripts && ! file -L "$exe" 2>/dev/null | grep -q "script"; then
					continue
				fi
				results+=("$(format_executable_display "$exe")")
			done < <(eval "$find_cmd" 2>/dev/null)
		done
	fi

	# Output results if any were found
	if [[ ${#results[@]} -gt 0 ]]; then
		printf '%s\n' "${results[@]}" | sort -u
	fi


	# Show warnings if any
	if [[ ${#nonexistent_paths[@]} -gt 0 ]]; then
		for path in "${nonexistent_paths[@]}"; do
			note "Directory in PATH does not exist: $path"
		done
	fi
}

# Run the function if this script is executed directly
if ! (return 0 2>/dev/null); then
	# Check if we are running tests
	if [ "$1" = "--test" ]; then
		# Run tests from the test file
		exec "$HOME/dotfiles/bin/test/$(basename "${0##\-}")_test"
	else
		# If called directly, pass all arguments to the function
		$(basename "${0##\-}") "$@"
	fi
fi
