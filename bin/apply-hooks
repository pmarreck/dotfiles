#!/usr/bin/env bash

# Handle help and test flags if run directly
if ! (return 0 2>/dev/null); then
	case "$1" in
		-h|--help)
			echo "apply-hooks - Set up shell prompt hooks and integrations"
			echo "Usage: apply-hooks"
			echo "       source apply-hooks"
			echo ""
			echo "This script sets up prompt hooks for direnv, mcfly, starship,"
			echo "and other shell integrations. It should normally be sourced from your"
			echo "shell configuration, not executed directly."
			echo ""
			echo "Options:"
			echo "  -h, --help    Show this help message"
			echo "  --test        Run tests"
			exit 0
			;;
		--test)
			# Run tests from the test file
			exec "$HOME/dotfiles/bin/test/$(basename "${0##\-}")_test"
			;;
	esac
fi

[ -n "${DEBUG_SHELLCONFIG}" ] && echo "Entering $(echo "${BASH_SOURCE[0]}" | $SED "s|^$HOME|~|")"
[ -n "${DEBUG_PATHCONFIG}" ] && echo "$PATH"

# CRITICAL: Remove any DEBUG traps that may cause command hanging
trap - DEBUG

##### rust cargo hook and related environment dependencies
# [[ -s "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env"
# needs rustc "curl https://sh.rustup.rs -sSf | sh"
needs eza "cargo install eza"
needs tokei "cargo install --git https://github.com/XAMPPRocky/tokei.git tokei"


# start with a blank slate
unset PROMPT_COMMAND
unset precmd_functions
unset preexec_functions
unset PROMPT_ARRAY
PROMPT_COMMAND=""
declare -a precmd_functions
declare -a preexec_functions
declare -a PROMPT_ARRAY

# DEBUG_PROMPT_COMMANDS=1
report_prompt_commands() {
	truthy DEBUG_PROMPT_COMMANDS && echo "$1 $2: $(inspect PROMPT_COMMAND precmd_functions preexec_functions PROMPT_ARRAY)"
}

source $HOME/dotfiles/bin/src/inspect.bash

# We start with a clean PROMPT_COMMAND and precmd_functions slate in the event we rehash (which used to screw this up)
# unset PROMPT_COMMAND
# unset precmd_functions
# declare -a PROMPT_COMMAND
# declare -a precmd_functions
# PROMPT_COMMAND="" # initialized to a string for a reason, even though it can be an array
# unset PROMPT_COMMAND
# precmd_functions=()
# preexec_functions=()

# if [[ $- == *i* ]]; then echo "Interactive Shell" >&2; else echo "Non-Interactive Shell!!" >&2; fi

# Enable debug for any errors not caught
# trap '[[ $? -ne 0 ]] && echo "Error on line $LINENO in $BASH_SOURCE."' ERR
# set -o pipefail
# set -x

##### Guix integration
# [[ -s "$HOME/.guix-profile/etc/profile" ]] && source "$HOME/.guix-profile/etc/profile"

# TTY Bypassing for Integrated Terminals
# In VS Code / WezTerm integrated terminals, 'test -t 1' often fails.
# This flag tells bash-preexec to skip the TTY check and run hooks anyway.
export __bp_delay_install="true"

BASH_PREEXEC_LOCATION="$HOME/dotfiles/lib/bash-preexec.sh"

# NOTE: The wrap_prompt_command_initializer function has been removed.
# We now source bash-preexec directly and use its precmd_functions API.
# See the refactored hook initialization below.

#####

##### bash-preexec
# You'll want to pull down the file and add it to your bash profile/configuration (i.e ~/.bashrc, ~/.profile, ~/.bash_profile, etc).
# It must be the last thing imported in your bash profile!
# Pull down our file from GitHub and write it to your home directory as a hidden file.

update_bash_preexec() {
	[ -n "${EDIT}" ] && unset EDIT && edit_function "${FUNCNAME[0]}" "$BASH_SOURCE" && return
	mkdir -p ~/dotfiles/lib
	curl https://raw.githubusercontent.com/rcaloras/bash-preexec/master/bash-preexec.sh -o "$BASH_PREEXEC_LOCATION"
}

# NOTE: wezterm_status_support has been removed.
# We now use __wezterm_osc7 from utility_functions.bash added to precmd_functions.

# Run all initializers in the correct order
# CRITICAL: Source bash-preexec FIRST - it must be sourced, not cat+eval'd
# bash-preexec sets up the precmd_functions and preexec_functions arrays
# and installs the DEBUG trap properly

if [[ -f "$BASH_PREEXEC_LOCATION" ]]; then
	source "$BASH_PREEXEC_LOCATION" || {
		echo "Error: Failed to source bash-preexec from $BASH_PREEXEC_LOCATION" >&2
		echo "Run 'update_bash_preexec' to download it." >&2
	}
else
	echo "Error: bash-preexec not found at $BASH_PREEXEC_LOCATION" >&2
	echo "Run 'update_bash_preexec' to download it." >&2
fi

report_prompt_commands "after" "bash-preexec source"

# Now run tool initializers - they will add their hooks to precmd_functions
# Each tool's init script defines a function and adds it to PROMPT_COMMAND or precmd_functions

# direnv - defines _direnv_hook and adds to PROMPT_COMMAND
if command -v direnv >/dev/null 2>&1; then
	eval "$(direnv hook bash)" || err "direnv hook failed"
	report_prompt_commands "after" "direnv hook"
fi

# mcfly - defines mcfly_prompt_command and adds to PROMPT_COMMAND
if command -v mcfly >/dev/null 2>&1; then
	eval "$(mcfly init bash)" || err "mcfly init failed"
	report_prompt_commands "after" "mcfly init"
fi

# WezTerm OSC 7 support for current directory tracking
if [[ "$TERM_PROGRAM" = "WezTerm" ]]; then
	# Add OSC 7 escape sequence to track working directory
	precmd_functions+=(__wezterm_osc7)
	report_prompt_commands "after" "wezterm setup"
fi

# starship - defines starship_precmd and uses precmd_functions if bash-preexec is loaded
if command -v starship >/dev/null 2>&1; then
	eval "$(starship init bash)" || err "starship init failed"
	report_prompt_commands "after" "starship init"
fi

# Manual Starship Timing via PS0 (Native Bash Hook)
# This works reliably even if preexec/DEBUG traps are flaky or disabled.
# It captures the start time right before the command executes.
if [[ -n "${BASH_VERSION-}" ]] && [[ "${BASH_VERSINFO[0]}" -gt 4 || ( "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 ) ]]; then
	starship_preexec_ps0() {
		command starship time
	}
	# Magic string that sets STARSHIP_START_TIME when PS0 is expanded
	PS0='${STARSHIP_START_TIME:$((STARSHIP_START_TIME="$(starship_preexec_ps0)",0)):0}'"${PS0-}"
	export PS0
fi

# Add custom hooks directly to precmd_functions (bash-preexec API)
if ! array_contains_element precmd_functions __wezterm_osc7_home; then
	precmd_functions+=(__wezterm_osc7_home)
fi

report_prompt_commands "after" "custom hooks"

# ==============================================================================
# FINAL CONFIGURATION NORMALIZATION
# ==============================================================================
# Strategy: "Harvest and Normalize"
# 1. Harvest any hook functions currently in PROMPT_COMMAND (e.g. from VS Code, mcfly)
# 2. Add them to precmd_functions if not already present
# 3. Declaratively force PROMPT_COMMAND to use ONLY bash-preexec
# ==============================================================================

# Function to safely add a command to precmd_functions
add_to_precmd() {
	local cmd="$1"
	# Skip empty, pure bash-preexec calls, or internal delimiters
	[[ -z "$cmd" ]] && return
	[[ "$cmd" == ":" ]] && return
	[[ "$cmd" == "__bp_precmd_invoke_cmd" ]] && return
	[[ "$cmd" == "__bp_interactive_mode" ]] && return
	[[ "$cmd" == *"trap -p DEBUG"* ]] && return # Exclude bash-preexec internal artifact

	if ! array_contains_element precmd_functions "$cmd"; then
		precmd_functions+=("$cmd")
	fi
}

# 1. Harvest from PROMPT_COMMAND (handle both Array and String types)
if [[ "$(declare -p PROMPT_COMMAND 2>&1)" == "declare -a"* ]]; then
	# It's an array
	for entry in "${PROMPT_COMMAND[@]}"; do
		# Split potential multi-command strings (semicolon or newline separated)
		IFS=$';\n' read -ra subcmds <<< "$entry"
		for subcmd in "${subcmds[@]}"; do
			add_to_precmd "${subcmd}"
		done
	done
else
	# It's a string
	IFS=$';\n' read -ra subcmds <<< "$PROMPT_COMMAND"
	for subcmd in "${subcmds[@]}"; do
		add_to_precmd "${subcmd}"
	done
fi

# 2. Declaratively set PROMPT_COMMAND to bash-preexec ONLY
# This ensures a clean, deterministic state regardless of what previous initializers did
PROMPT_COMMAND=('__bp_precmd_invoke_cmd' '__bp_interactive_mode')

report_prompt_commands "final" "normalized"



[ -n "${DEBUG_SHELLCONFIG}" ] && echo "Exiting $(echo "${BASH_SOURCE[0]}" | $SED "s|^$HOME|~|")"
[ -n "${DEBUG_PATHCONFIG}" ] && echo "$PATH" || :
