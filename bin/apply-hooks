#!/usr/bin/env bash

[ -n "${DEBUG_SHELLCONFIG}" ] && echo "Entering $(echo "${BASH_SOURCE[0]}" | $SED "s|^$HOME|~|")"
[ -n "${DEBUG_PATHCONFIG}" ] && echo "$PATH"

##### rust cargo hook and related environment dependencies
# [[ -s "$HOME/.cargo/env" ]] && source "$HOME/.cargo/env"
# needs rustc "curl https://sh.rustup.rs -sSf | sh"
needs eza "cargo install eza"
needs tokei "cargo install --git https://github.com/XAMPPRocky/tokei.git tokei"


# start with a blank slate
unset PROMPT_COMMAND
unset precmd_functions
unset preexec_functions
unset PROMPT_ARRAY
PROMPT_COMMAND=""
declare -a precmd_functions
declare -a preexec_functions
declare -a PROMPT_ARRAY

# DEBUG_PROMPT_COMMANDS=1
report_prompt_commands() {
	truthy DEBUG_PROMPT_COMMANDS && echo "$1 $2: $(inspect PROMPT_COMMAND precmd_functions preexec_functions PROMPT_ARRAY)"
}

source $HOME/dotfiles/bin/src/inspect.bash

# We start with a clean PROMPT_COMMAND and precmd_functions slate in the event we rehash (which used to screw this up)
# unset PROMPT_COMMAND
# unset precmd_functions
# declare -a PROMPT_COMMAND
# declare -a precmd_functions
# PROMPT_COMMAND="" # initialized to a string for a reason, even though it can be an array
# unset PROMPT_COMMAND
# precmd_functions=()
# preexec_functions=()

# if [[ $- == *i* ]]; then echo "Interactive Shell" >&2; else echo "Non-Interactive Shell!!" >&2; fi

# Enable debug for any errors not caught
# trap '[[ $? -ne 0 ]] && echo "Error on line $LINENO in $BASH_SOURCE."' ERR
# set -o pipefail
# set -x

##### Guix integration
# [[ -s "$HOME/.guix-profile/etc/profile" ]] && source "$HOME/.guix-profile/etc/profile"

BASH_PREEXEC_LOCATION="$HOME/dotfiles/lib/bash-preexec.sh"

# Declare associative array to track initializer types
declare -A initializer_types

# Set known initializer types
initializer_types["direnv hook bash"]="produces_code_to_run"
initializer_types["mcfly init bash"]="produces_code_to_run"
initializer_types["zoxide init --cmd cd --hook pwd bash"]="produces_code_to_run"
initializer_types["wezterm_status_support"]="runs_code"
initializer_types["starship init bash"]="produces_code_to_run"
initializer_types["set_up_osc7_home"]="runs_code"
initializer_types["cat '$BASH_PREEXEC_LOCATION'"]="produces_code_to_run"

wrap_prompt_command_initializer() {
	local initializer_cmd="$1"
	local initializer_type="${initializer_types[$initializer_cmd]:-"unknown"}"
	local initializer_code_return_code=0

	report_prompt_commands "before" "$initializer_cmd"

	if [[ "$initializer_type" == "runs_code" ]]; then
		# The initializer runs code directly
		eval "$initializer_cmd"
		initializer_code_return_code=$?
		truthy DEBUG_PROMPT_COMMANDS && echo "Ran '$initializer_cmd' directly"

	elif [[ "$initializer_type" == "produces_code_to_run" ]]; then
		# The initializer produces code that should be evaluated
		local initializer_code
		initializer_code=$(eval "$initializer_cmd")
		initializer_code_return_code=$?

		if [[ $initializer_code_return_code -eq 0 ]]; then
			eval "$initializer_code"
			initializer_code_return_code=$?
			truthy DEBUG_PROMPT_COMMANDS && echo "Ran the code generated by '$initializer_cmd'"
		else
			echo "Error: Initializer '$initializer_cmd' failed with error code $initializer_code_return_code" >&2
			return $initializer_code_return_code
		fi

	else
		# For unknown initializers, try to detect type (fallback to old behavior)
		echo "Warning: Unknown initializer type for '$initializer_cmd', trying to detect type" >&2

		local initializer_code
		initializer_code=$(eval "$initializer_cmd")
		initializer_code_return_code=$?

		if [ -z "$initializer_code" ] && [ $initializer_code_return_code -eq 0 ]; then
			# If it returned nothing successfully, it was meant to be run directly
			eval "$initializer_cmd"
			initializer_code_return_code=$?
			truthy DEBUG_PROMPT_COMMANDS && echo "Detected and ran '$initializer_cmd' directly"
			# Record this type for future use
			initializer_types["$initializer_cmd"]="runs_code"
		elif ! [ -z "$initializer_code" ]; then
			# If it returned code, evaluate that code
			eval "$initializer_code"
			initializer_code_return_code=$?
			truthy DEBUG_PROMPT_COMMANDS && echo "Detected and ran code generated by '$initializer_cmd'"
			# Record this type for future use
			initializer_types["$initializer_cmd"]="produces_code_to_run"
		else
			echo "Error: Initializer '$initializer_cmd' returned nothing and an error code of $initializer_code_return_code" >&2
			return $initializer_code_return_code
		fi
	fi

	# Handle PROMPT_COMMAND updates
	if [[ -n "$PROMPT_COMMAND" ]]; then
		truthy DEBUG_PROMPT_COMMANDS && echo "Adding '$PROMPT_COMMAND' to PROMPT_ARRAY"
		PROMPT_ARRAY+=("$PROMPT_COMMAND")
		truthy DEBUG_PROMPT_COMMANDS && echo "PROMPT_ARRAY is now: ${PROMPT_ARRAY[@]}"
	fi

	report_prompt_commands "after" "$initializer_cmd"
	return $initializer_code_return_code
}

# echo "before direnv hook: $(declare -p PROMPT_COMMAND)"
# Wrapper function to preserve PROMPT_COMMAND when it's a Bash array
# wrap_prompt_command_initializer_old() {
#   local initializer_cmd="$1"
#   report_prompt_commands "before" "$initializer_cmd"
#   if ! [[ "$(declare -p precmd_functions 2>&1)" == "declare -a"* ]]; then
#     precmd_functions=()
#   fi

#   # Check if PROMPT_COMMAND is a Bash array
#   if [[ "$(declare -p PROMPT_COMMAND 2>&1)" == "declare -a"* ]]; then
#     # Add the current PROMPT_COMMAND array to precmd_functions
#     precmd_functions+=("${PROMPT_COMMAND[@]}")

#     # Set PROMPT_COMMAND to empty string
#     # unset PROMPT_COMMAND # since the following line won't erase its array type (!)
#     # PROMPT_COMMAND=""

#     # Run the initializer
#     eval "$($initializer_cmd)"

#     # Check if PROMPT_COMMAND is still a string (not an array)
#     if ! [[ "$(declare -p PROMPT_COMMAND 2>&1)" == "declare -a"* ]]; then
#       # Get the string value and append it as array elements to a new PROMPT_COMMAND
#       local prompt_cmd_string="$PROMPT_COMMAND"
#       # unset PROMPT_COMMAND
#       # declare -a PROMPT_COMMAND
#       IFS=';' read -ra PROMPT_COMMAND <<< "$prompt_cmd_string"
#     else
#       echo "Error: Initializer '$initializer_cmd' unexpectedly set PROMPT_COMMAND as an array" >&2
#       return 1
#     fi
#   elif [[ "$(declare -p PROMPT_COMMAND 2>&1)" == "declare --"* ]]; then
#     # If PROMPT_COMMAND is not an array, but has a value, just run the initializer,
#     # preserving old value in precmd_functions and setting PROMPT_COMMAND to a Bash array again
#     if [ "${PROMPT_COMMAND}" != "" ]; then
#       precmd_functions+=("${PROMPT_COMMAND[@]}")
#       # unset PROMPT_COMMAND
#       # PROMPT_COMMAND=""
#       # Run the initializer
#       eval "$($initializer_cmd)"
#       # Check if PROMPT_COMMAND is still a string (not an array)
#       if ! [[ "$(declare -p PROMPT_COMMAND 2>&1)" == "declare -a"* ]]; then
#         # Get the string value and append it as array elements to a new PROMPT_COMMAND
#         local prompt_cmd_string="$PROMPT_COMMAND"
#         PROMPT_ARRAY+=("$prompt_cmd_string")
#         # unset PROMPT_COMMAND
#         # PROMPT_COMMAND=""
#       else
#         echo "Error: Initializer '$initializer_cmd' unexpectedly set PROMPT_COMMAND as an array" >&2
#         return 1
#       fi
#     elif [ "${PROMPT_COMMAND}" == "" ]; then
#       :
#     else
#       echo "Error: Initializer '$initializer_cmd' couldn't cope with PROMPT_COMMAND value of '${PROMPT_COMMAND}'" >&2
#       return 1
#     fi
#   else
#     echo "Error: Initializer '$initializer_cmd' skipped since PROMPT_COMMAND is set to something unexpected" >&2
#     return 1
#   fi

#   report_prompt_commands "after" "$initializer_cmd"
# }

# The initializers are now centrally managed at the end of this file

##### direnv hook
# needs direnv
# if [ $? -eq 0 ]; then
#   wrap_prompt_command_initializer "direnv hook bash"
# fi

# echo "before mcfly hook: $(declare -p PROMPT_COMMAND)"
##### mcfly integration (access via ctrl-r)
# needs mcfly "curl -LSfs https://raw.githubusercontent.com/cantino/mcfly/master/ci/install.sh | sudo sh -s -- --git cantino/mcfly"
# if [ $? -eq 0 ]; then
#   wrap_prompt_command_initializer "mcfly init bash"
# fi

# echo "after mcfuckery:"
# declare -p PROMPT_COMMAND; declare -p precmd_functions

# So at this point we want to handle this more intelligently; let's assert
# on the state of the PROMPT_COMMAND hooks and value at this point:

# if [ "$PROMPT_COMMAND" = "mcfly_prompt_command;_direnv_hook;starship_precmd" ]; then
#   # and now let's split it into an array that bash-preexec will handle itself:
#   [[ -v precmd_functions ]] || declare -a precmd_functions
#   IFS=';' read -ra precmd_functions <<< "$PROMPT_COMMAND"
#   # and finally let's delete PROMPT_COMMAND and let bash-preexec recreate it
#   unset PROMPT_COMMAND
# else
# :
#   # Starship kept fucking these up on rehash, so we just force them to the proper values here
#   # PROMPT_COMMAND=([0]="__bp_precmd_invoke_cmd" [1]="__bp_interactive_mode")
#   # precmd_functions=([0]="mcfly_prompt_command" [1]="_direnv_hook" [2]="starship_precmd" [3]="precmd")
# fi

# NOW we merge the flat ;-separated strings into proper array elements
# move_PROMPT_COMMAND_to_precmd_functions
# and unique them
# uniquify_array precmd_functions

# echo "before starship hook: $(declare -p PROMPT_COMMAND)"
##### starship
# it claims it will work with bash-preexec if it's loaded, so we run this after that hook
# Actually, turns out it's full of shit and a dirty hack, so we actually run it first
# to minimize its brain damage to PROMPT_COMMAND hooking; see below
# needs starship
# if [ $? -eq 0 ]; then
#   wrap_prompt_command_initializer "starship init bash"
# fi

## SET UP CUSTOM HOOKS HERE
# set up default terminal directory using OSC 7
set_up_osc7_home() {
	if array_contains_element precmd_functions __wezterm_osc7_home; then
		:
	else
		precmd_functions+=(__wezterm_osc7_home)
	fi
}

# DO_NOT() { :; }; ONLY() { :; };

# DO_NOT ADD ANY MORE CUSTOM COMMANDLINE HOOKS/INITIALIZERS AFTER THIS POINT

# ONLY BASH_PREEXEC CONFIG SHOULD BE BELOW THIS LINE

# unset DO_NOT ONLY

# echo "before bash-preexec hook: $(declare -p PROMPT_COMMAND)"
##### bash-preexec
# You'll want to pull down the file and add it to your bash profile/configuration (i.e ~/.bashrc, ~/.profile, ~/.bash_profile, etc).
# It must be the last thing imported in your bash profile!
# Pull down our file from GitHub and write it to your home directory as a hidden file.

update_bash_preexec() {
	[ -n "${EDIT}" ] && unset EDIT && edit_function "${FUNCNAME[0]}" "$BASH_SOURCE" && return
	mkdir -p ~/dotfiles/lib
	curl https://raw.githubusercontent.com/rcaloras/bash-preexec/master/bash-preexec.sh -o "$BASH_PREEXEC_LOCATION"
}

wezterm_status_support() {
	PROMPT_COMMAND='printf "\e]7;file://%s%s\a" "$HOSTNAME" "$PWD"; '$PROMPT_COMMAND
}

# Run all initializers in the correct order
# First, run tools that modify PROMPT_COMMAND directly
command -v direnv >/dev/null 2>&1 && wrap_prompt_command_initializer "direnv hook bash" || err "direnv not found"
command -v mcfly >/dev/null 2>&1 && wrap_prompt_command_initializer "mcfly init bash" || err "mcfly not found"
if [ "$TERM_PROGRAM" = "WezTerm" ]; then
	wrap_prompt_command_initializer "wezterm_status_support"
fi

# Then run starship which uses precmd_functions
command -v starship >/dev/null 2>&1 && wrap_prompt_command_initializer "starship init bash" || err "starship not found"

# Run any custom hooks
wrap_prompt_command_initializer "set_up_osc7_home"

wrap_prompt_command_initializer "cat '$BASH_PREEXEC_LOCATION'" || err "bash-preexec not found"

command -v zoxide >/dev/null 2>&1 && wrap_prompt_command_initializer "zoxide init --cmd cd --hook pwd bash" || err "zoxide not found"

# Source bash-preexec LAST to ensure it can see all hooks
# [ -f "$BASH_PREEXEC_LOCATION" ] && source "$BASH_PREEXEC_LOCATION" || err "bash-preexec not found"

# if [ -f "$BASH_PREEXEC_LOCATION" ]; then
# 	# Source bash-preexec directly to ensure it works properly
# 	source "$BASH_PREEXEC_LOCATION" || \
# 		echo -e "Problem when setting up bash_preexec config from ${BASH_PREEXEC_LOCATION}; it errored.\n You may need to run update_bash_preexec to fix this."
# 	# Ensure precmd_functions are properly registered
# 	if [[ "$(declare -p precmd_functions 2>&1)" == "declare -a"* ]] && [[ "${#precmd_functions[@]}" -gt 0 ]]; then
# 		truthy DEBUG_PROMPT_COMMANDS && echo "Registered ${#precmd_functions[@]} precmd functions with bash-preexec"
# 	fi
# else
# 	echo -e "Problem when setting up bash_preexec config from ${BASH_PREEXEC_LOCATION}; it is nonexistent.\n You may need to run update_bash_preexec to fix this."
# fi

# and then force PROMPT_COMMAND to just be the bash_preexec hook
# PROMPT_COMMAND=([0]="__bp_precmd_invoke_cmd" [1]="__bp_interactive_mode")

# and then make sure precmd_functions contains precmd
# if array_contains_element precmd_functions precmd; then
#   :
# else
#   precmd_functions+=(precmd)
# fi

# _writehist() {
#   # echo "writing history..."
#   history -a
# }

# # add "history -a" to make all terminal windows use the same history
# if array_contains_element precmd_functions _writehist; then
#   :
# else
#   precmd_functions+=(_writehist)
# fi

# Just setting them declaratively here to avoid a lot of nondeterministic garbage with these hooks
# unset PROMPT_COMMAND
# unset precmd_functions
# declare -a PROMPT_COMMAND=([0]="__bp_precmd_invoke_cmd" [1]="__bp_interactive_mode")
# declare -a precmd_functions=([0]="mcfly_prompt_command" [1]="_direnv_hook" [2]="starship_precmd" [3]="__wezterm_osc7_home" [4]="precmd")

# echo "after bash_preexsuck:"
# declare -p PROMPT_COMMAND; declare -p precmd_functions; declare -p preexec_functions

[ -n "${DEBUG_SHELLCONFIG}" ] && echo "Exiting $(echo "${BASH_SOURCE[0]}" | $SED "s|^$HOME|~|")"
[ -n "${DEBUG_PATHCONFIG}" ] && echo "$PATH" || :
