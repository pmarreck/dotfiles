#!/usr/bin/env wasmrun
;; Emit the realtime clock in seconds.nanoseconds using WASI syscalls.
(module
  ;; Pull in the WASI APIs we need: stdout/stdin, clock access, argument parsing, and exiting.
  (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "fd_read" (func $fd_read (param i32 i32 i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "fd_fdstat_get" (func $fd_fdstat_get (param i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "clock_time_get" (func $clock_time_get (param i32 i64 i32) (result i32)))
  (import "wasi_snapshot_preview1" "args_get" (func $args_get (param i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "args_sizes_get" (func $args_sizes_get (param i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "proc_exit" (func $proc_exit (param i32)))

  ;; Reserve one 64 KiB page of linear memory. All scratch buffers live here.
  (memory (export "memory") 1)

  ;; Static data:
  ;;   offset 64    -> string ".\n" used for decimal point and newline
  ;;   offset 4096  -> about text (null terminated)
  ;;   offset 4208  -> help text (null terminated)
  ;;   offset 4608+ -> literal CLI tokens (null terminated)
  (data (i32.const 64) ".\0a")
  (data (i32.const 4096) "WASM/WASI realtime nanosecond clock demo with stdin override + args parsing.\0a\00")
  (data (i32.const 4208)
    "Usage: ns [OPTIONS]\0a\0a"
    "WASM/WASI demo that prints seconds.nanoseconds and accepts 8-byte stdin overrides.\0a"
    "  -a, --about  Show short description\0a"
    "  -h, --help   Show this help message\0a\00")
  (data (i32.const 4608) "-a\00")
  (data (i32.const 4616) "--about\00")
  (data (i32.const 4628) "-h\00")
  (data (i32.const 4636) "--help\00")
  ;; Runtime strlen because WAT/WASM has no compile-time macros 
  ;; or const-evaluated macros. This lets us edit the help/about text
  ;; freely without counting bytes by hand.
  (func $strlen (param $ptr i32) (result i32)
    (local $cursor i32)
    (local.set $cursor (local.get $ptr))
    (block $done
      (loop $loop
        (br_if $done (i32.eqz (i32.load8_u (local.get $cursor))))
        (local.set $cursor (i32.add (local.get $cursor) (i32.const 1)))
        (br $loop)))
    (i32.sub (local.get $cursor) (local.get $ptr))
  )

  ;; Compare a null-terminated string at `ptr` against the literal at `lit`.
  (func $eq_literal (param $ptr i32) (param $lit i32) (result i32)
    (local $offset i32)
    (local $lhs i32)
    (local $rhs i32)
    (loop $loop
      (local.set $lhs (i32.load8_u (i32.add (local.get $ptr) (local.get $offset))))
      (local.set $rhs (i32.load8_u (i32.add (local.get $lit) (local.get $offset))))
      (if (i32.ne (local.get $lhs) (local.get $rhs))
        (then (return (i32.const 0))))
      (if (i32.eq (local.get $rhs) (i32.const 0))
        (then (return (i32.const 1))))
      (local.set $offset (i32.add (local.get $offset) (i32.const 1)))
      (br $loop))
    (i32.const 0)
  )

  ;; Convert an unsigned 64-bit integer to ASCII digits. Result pointer/length
  ;; are written back through the `out` parameter (two i32 slots).
  (func $format_u64 (param $value i64) (param $out i32)
    (local $buf_end i32)
    (local $write_ptr i32)
    (local $len i32)
    (local $digit i32)
    (local $n i64)

    ;; Start writing from the end of a scratch buffer at address 48.
    (local.set $buf_end (i32.const 48))
    (local.set $write_ptr (local.get $buf_end))
    (local.set $len (i32.const 0))
    (local.set $n (local.get $value))

    ;; Peel digits in reverse (least significant first) until the quotient is 0.
    (loop $extract
      (local.set $digit
        (i32.wrap_i64
          (i64.rem_u (local.get $n) (i64.const 10))))
      (local.set $write_ptr (i32.sub (local.get $write_ptr) (i32.const 1)))
      (i32.store8
        (local.get $write_ptr)
        (i32.add (local.get $digit) (i32.const 48)))
      (local.set $len (i32.add (local.get $len) (i32.const 1)))
      (local.set $n (i64.div_u (local.get $n) (i64.const 10)))
      (br_if $extract (i64.ne (local.get $n) (i64.const 0))))

    ;; Write the resulting pointer/length to `out` (two 32-bit slots).
    (i32.store (local.get $out) (local.get $write_ptr))
    (i32.store offset=4 (local.get $out) (local.get $len))
  )

  ;; Format the fractional nanosecond component as exactly nine digits with
  ;; leading zeros. The digits are written at buffer base 96.
  (func $format_frac (param $value i64) (param $out i32)
    (local $buf i32)
    (local $i i32)
    (local $n i64)
    (local $digit i32)

    (local.set $buf (i32.const 96))
    (local.set $i (i32.const 8))
    (local.set $n (local.get $value))

    ;; Fill the buffer from right to left, zero-padding any unused slots.
    (block $done
      (loop $loop
        (local.set $digit
          (i32.wrap_i64
            (i64.rem_u (local.get $n) (i64.const 10))))
        (i32.store8
          (i32.add (local.get $buf) (local.get $i))
          (i32.add (local.get $digit) (i32.const 48)))
        (local.set $n (i64.div_u (local.get $n) (i64.const 10)))
        (br_if $done (i32.eqz (local.get $i)))
        (local.set $i (i32.sub (local.get $i) (i32.const 1)))
        (br $loop)))

    (i32.store (local.get $out) (local.get $buf))
    (i32.store offset=4 (local.get $out) (i32.const 9))
  )

  ;; Thin wrapper for WASI fd_write. Writes `len` bytes starting at `ptr` to
  ;; stdout (fd 1), exiting on any errno.
  (func $write (param $ptr i32) (param $len i32)
    (local $errno i32)
    (i32.store (i32.const 200) (local.get $ptr))
    (i32.store (i32.const 204) (local.get $len))
    (local.set $errno
      (call $fd_write
        (i32.const 1)
        (i32.const 200)
        (i32.const 1)
        (i32.const 208)))
    (if (i32.ne (local.get $errno) (i32.const 0))
      (then (call $proc_exit (local.get $errno))))
  )

  ;; Match known CLI switches. Returns 1 for about, 2 for help, 0 otherwise.
  (func $match_arg (param $ptr i32) (result i32)
    (if (call $eq_literal (local.get $ptr) (i32.const 4608))
      (then (return (i32.const 1))))
    (if (call $eq_literal (local.get $ptr) (i32.const 4616))
      (then (return (i32.const 1))))
    (if (call $eq_literal (local.get $ptr) (i32.const 4628))
      (then (return (i32.const 2))))
    (if (call $eq_literal (local.get $ptr) (i32.const 4636))
      (then (return (i32.const 2))))
    (i32.const 0)
  )

  ;; Entry point: optionally handle CLI flags, otherwise print the realtime clock.
  (func (export "_start")
    (local $errno i32)
    (local $timestamp i64)
    (local $seconds_ptr i32)
    (local $seconds_len i32)
    (local $remainder i64)
    (local $frac_ptr i32)
    (local $frac_len i32)
    (local $argc i32)
    (local $buf_size i32)
    (local $argv_base i32)
    (local $argv_buf i32)
    (local $mode i32)
    (local $i i32)
    (local $arg_ptr i32)
    (local $match i32)
    (local $use_override i32)
    (local $stdin_bytes i32)
    (local $filetype i32)

    (local.set $mode (i32.const 0))
    (local.set $use_override (i32.const 0))

    ;; Try to source a timestamp override from non-tty stdin.
    (local.set $errno (call $fd_fdstat_get (i32.const 0) (i32.const 768)))
    (if (i32.eq (local.get $errno) (i32.const 0))
      (then
        (local.set $filetype (i32.load8_u (i32.const 768)))
        (if (i32.ne (local.get $filetype) (i32.const 2))
          (then
            (i32.store (i32.const 784) (i32.const 1024))  ;; iovec.buf
            (i32.store (i32.const 788) (i32.const 8))      ;; iovec.len
            (local.set $errno
              (call $fd_read
                (i32.const 0)
                (i32.const 784)
                (i32.const 1)
                (i32.const 792)))
            (if (i32.eq (local.get $errno) (i32.const 0))
              (then
                (local.set $stdin_bytes (i32.load (i32.const 792)))
                (if (i32.ge_u (local.get $stdin_bytes) (i32.const 8))
                  (then
                    (local.set $timestamp (i64.load (i32.const 1024)))
                    (local.set $use_override (i32.const 1))))))))))

    ;; Discover argument buffer sizes.
    (local.set $errno (call $args_sizes_get (i32.const 240) (i32.const 244)))
    (if (i32.ne (local.get $errno) (i32.const 0))
      (then
        (call $proc_exit (local.get $errno))
        (return)))

    (local.set $argc (i32.load (i32.const 240)))
    (local.set $buf_size (i32.load (i32.const 244)))

    ;; Load argument strings when at least one option was supplied.
    (if (i32.gt_u (local.get $argc) (i32.const 1))
      (then
        (local.set $argv_base (i32.const 256))
        (local.set $argv_buf (i32.const 512))
        ;; Bail out if the declared buffer would overflow this demo's single page.
        (if (i32.gt_u (i32.add (local.get $argv_buf) (local.get $buf_size)) (i32.const 65536))
          (then
            (call $proc_exit (i32.const 75))
            (return)))
        (local.set $errno (call $args_get (local.get $argv_base) (local.get $argv_buf)))
        (if (i32.ne (local.get $errno) (i32.const 0))
          (then
            (call $proc_exit (local.get $errno))
            (return)))
        (local.set $i (i32.const 1))
        (block $scan_done
          (loop $scan
            (br_if $scan_done (i32.ge_u (local.get $i) (local.get $argc)))
            (local.set $arg_ptr
              (i32.load
                (i32.add (local.get $argv_base)
                  (i32.shl (local.get $i) (i32.const 2)))))
            (local.set $match (call $match_arg (local.get $arg_ptr)))
            (if (i32.ne (local.get $match) (i32.const 0))
              (then
                (local.set $mode (local.get $match))
                (br $scan_done)))
            (local.set $i (i32.add (local.get $i) (i32.const 1)))
            (br $scan)))))

    ;; Respond to --about or --help if present.
    (if (i32.eq (local.get $mode) (i32.const 1))
      (then
        (local.set $seconds_len (call $strlen (i32.const 4096)))
        (call $write (i32.const 4096) (local.get $seconds_len))
        (call $proc_exit (i32.const 0))
        (return)))

    (if (i32.eq (local.get $mode) (i32.const 2))
      (then
        (local.set $seconds_len (call $strlen (i32.const 4208)))
        (call $write (i32.const 4208) (local.get $seconds_len))
        (call $proc_exit (i32.const 0))
        (return)))

    ;; No flags: emit the realtime clock. If stdin provided 8 bytes
    ;; of data and is not a tty, treat that as the timestamp.
    (if (i32.eqz (local.get $use_override))
      (then
        (local.set $errno
          (call $clock_time_get
            (i32.const 0)
            (i64.const 0)
            (i32.const 0)))
        (if (i32.ne (local.get $errno) (i32.const 0))
          (then
            (call $proc_exit (local.get $errno))
            (return)))
        (local.set $timestamp (i64.load (i32.const 0)))))

    ;; Separate whole seconds and remainder nanoseconds.
    (local.set $remainder
      (i64.rem_u (local.get $timestamp) (i64.const 1000000000)))
    (local.set $timestamp
      (i64.div_u (local.get $timestamp) (i64.const 1000000000)))

    ;; Format the integer part.
    (call $format_u64 (local.get $timestamp) (i32.const 80))
    (local.set $seconds_ptr (i32.load (i32.const 80)))
    (local.set $seconds_len (i32.load offset=4 (i32.const 80)))

    ;; Format the fractional digits.
    (call $format_frac (local.get $remainder) (i32.const 120))
    (local.set $frac_ptr (i32.load (i32.const 120)))
    (local.set $frac_len (i32.load offset=4 (i32.const 120)))

    ;; Write "seconds.fraction\n" in three chunks.
    (call $write (local.get $seconds_ptr) (local.get $seconds_len))
    (call $write (i32.const 64) (i32.const 1))
    (call $write (local.get $frac_ptr) (local.get $frac_len))
    (call $write (i32.add (i32.const 64) (i32.const 1)) (i32.const 1))
  )
)
